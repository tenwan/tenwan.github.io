

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="刘金博">
  <meta name="keywords" content="">
  <title>高热度题参要 - xiaoliu‘s sapce</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>xiaoliu's space</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="高热度题参要">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-21 12:32" pubdate>
        2021年3月21日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      25k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      386
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">高热度题参要</h1>
            
            <div class="markdown-body">
              <h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><pre><code class="hljs inform7">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
给定 nums = <span class="hljs-comment">[2, 7, 11, 15]</span>, target = 9

因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> = 2 + 7 = 9
所以返回 <span class="hljs-comment">[0, 1]</span></code></pre>

<p><strong>双指针</strong></p>
<pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] twoSum(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target) &#123;
        <span class="hljs-built_in">int</span> p1 = <span class="hljs-number">0</span>, p2 = nums.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;
            <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = nums[p1] + nums[p2];
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> &lt; target) 
                p1++;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> &gt; target) 
                p2--;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> 
                <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;p1, p2&#125;;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;&#125;;
    &#125;
&#125;</code></pre>

<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><pre><code class="hljs clean">给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 <span class="hljs-number">0</span> 之外，这两个数都不会以 <span class="hljs-number">0</span> 开头。
输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)
输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span>
原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span></code></pre>

<ol>
<li>两个链表相加，先判断边界</li>
<li>创建一个新的链表</li>
<li>while中也要注意边界</li>
<li>两个链表的值、进位相加</li>
<li>是否赋值给进位</li>
<li>三个链表移动指针</li>
</ol>
<pre><code class="hljs yaml"><span class="hljs-string">class</span> <span class="hljs-string">Solution</span> &#123;
    <span class="hljs-string">public</span> <span class="hljs-string">ListNode</span> <span class="hljs-string">addTwoNumbers(ListNode</span> <span class="hljs-string">l1</span>, <span class="hljs-string">ListNode</span> <span class="hljs-string">l2)</span> &#123;
        <span class="hljs-string">if</span> <span class="hljs-string">(l1</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">l2</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> <span class="hljs-string">return</span> <span class="hljs-literal">null</span><span class="hljs-string">;</span>
        <span class="hljs-string">if</span> <span class="hljs-string">(l1</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> <span class="hljs-string">return</span> <span class="hljs-string">l2;</span>
        <span class="hljs-string">if</span> <span class="hljs-string">(l2</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> <span class="hljs-string">return</span> <span class="hljs-string">l1;</span>
        <span class="hljs-string">ListNode</span> <span class="hljs-string">p1</span> <span class="hljs-string">=</span> <span class="hljs-string">l1;</span>
        <span class="hljs-string">ListNode</span> <span class="hljs-string">p2</span> <span class="hljs-string">=</span> <span class="hljs-string">l2;</span>
        <span class="hljs-string">ListNode</span> <span class="hljs-string">l3</span> <span class="hljs-string">=</span> <span class="hljs-string">new</span> <span class="hljs-string">ListNode(-1);</span>
        <span class="hljs-string">ListNode</span> <span class="hljs-string">p3</span> <span class="hljs-string">=</span> <span class="hljs-string">l3;</span>
        <span class="hljs-string">int</span> <span class="hljs-string">carried</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
        <span class="hljs-string">while</span> <span class="hljs-string">(p1</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">||</span> <span class="hljs-string">p2</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> &#123;
            <span class="hljs-string">int</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> <span class="hljs-string">p1</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">?</span> <span class="hljs-attr">p1.val :</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
            <span class="hljs-string">int</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> <span class="hljs-string">p2</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">?</span> <span class="hljs-attr">p2.val :</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>
            <span class="hljs-string">p3.next</span> <span class="hljs-string">=</span> <span class="hljs-string">new</span> <span class="hljs-string">ListNode((a</span> <span class="hljs-string">+</span> <span class="hljs-string">b</span> <span class="hljs-string">+</span> <span class="hljs-string">carried)</span> <span class="hljs-string">%</span> <span class="hljs-number">10</span><span class="hljs-string">);</span>
            <span class="hljs-string">carried</span> <span class="hljs-string">=</span> <span class="hljs-string">(a</span> <span class="hljs-string">+</span> <span class="hljs-string">b</span> <span class="hljs-string">+</span> <span class="hljs-string">carried)</span> <span class="hljs-string">/</span> <span class="hljs-number">10</span><span class="hljs-string">;</span>
            <span class="hljs-string">p3</span> <span class="hljs-string">=</span> <span class="hljs-string">p3.next;</span>
            <span class="hljs-string">p1</span> <span class="hljs-string">=</span> <span class="hljs-string">p1</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">?</span> <span class="hljs-attr">p1.next :</span> <span class="hljs-literal">null</span><span class="hljs-string">;</span>
            <span class="hljs-string">p2</span> <span class="hljs-string">=</span> <span class="hljs-string">p2</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">?</span> <span class="hljs-attr">p2.next :</span> <span class="hljs-literal">null</span><span class="hljs-string">;</span>
        &#125;
        <span class="hljs-string">p3.next</span> <span class="hljs-string">=</span> <span class="hljs-string">carried</span> <span class="hljs-type">!=</span> <span class="hljs-number">0</span> <span class="hljs-string">?</span> <span class="hljs-string">new</span> <span class="hljs-string">ListNode(1)</span> <span class="hljs-string">:</span> <span class="hljs-literal">null</span><span class="hljs-string">;</span>
        <span class="hljs-string">return</span> <span class="hljs-string">l3.next;</span>
    &#125;
&#125;</code></pre>

<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><pre><code class="hljs makefile">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
<span class="hljs-section">输入: &quot;abcabcbb&quot;</span>
<span class="hljs-section">输出: 3 </span>
<span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span>

<span class="hljs-section">输入: &quot;bbbbb&quot;</span>
<span class="hljs-section">输出: 1</span>
<span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></code></pre>

<p>HashMap+两个指针 两个指针分别记录字母的起始和结束，用map来存</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLongestSubstring(String <span class="hljs-params">s</span>)</span> &#123;
        <span class="hljs-built_in">int</span> n = s.length<span class="hljs-literal">()</span>, ans = <span class="hljs-number">0</span>;
        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;
            <span class="hljs-keyword">if</span> (map.contains<span class="hljs-constructor">Key(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">j</span>)</span>)) &#123;
                i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(map.get(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>), i);
            &#125;
            ans = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(ans, j - i + <span class="hljs-number">1</span>);
            map.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>, j + <span class="hljs-number">1</span>);
        &#125;
        return ans;
    &#125;
&#125;</code></pre>

<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><pre><code class="hljs 1c">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 <span class="hljs-number">1000</span>。
输入: <span class="hljs-string">&quot;babad&quot;</span>
输出: <span class="hljs-string">&quot;bab&quot;</span>
注意: <span class="hljs-string">&quot;aba&quot;</span> 也是一个有效答案。</code></pre>

<p>中心扩展</p>
<ul>
<li>两种情况</li>
<li>奇数长度</li>
<li>偶数长度</li>
<li>取最长，求起始和结束位置</li>
<li>用substring即可</li>
</ul>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (s == null || s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;
        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, <span class="hljs-built_in">end</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录起始位置</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;
            <span class="hljs-comment">// 两种情况 以i为中心，以i和i+1为中心</span>
            <span class="hljs-keyword">int</span> len1 = expand(s, i - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 中心扩展 </span>
            <span class="hljs-keyword">int</span> len2 = expand(s, i, i + <span class="hljs-number">1</span>);
            <span class="hljs-keyword">int</span> len = Math.<span class="hljs-built_in">max</span>(len1, len2); <span class="hljs-comment">// 取最长的长度</span>
            <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-built_in">end</span> - start) &#123;
                start = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
                <span class="hljs-built_in">end</span> = i + len / <span class="hljs-number">2</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> s.substring(start, <span class="hljs-built_in">end</span> + <span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;
        <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;
            l--;
            r++;
        &#125;
        <span class="hljs-comment">// 这里要注意</span>
        <span class="hljs-keyword">return</span> r - l - <span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<h2 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a>6. Z 字形变换</h2><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
     <span class="hljs-comment">// 0|     1   5   9     13</span>
     <span class="hljs-comment">// 1|     2 4 6 8 10 12 14 16</span>
     <span class="hljs-comment">// 2|     3   7   11    15</span>
     <span class="hljs-comment">// 每一行右边的字符的 ’索引值’ 都是其左边的字符的 ’索引值’ 加上它 ’下面剩余行数’ 的两倍或 ’上面行数’ 的两倍（交替相加）</span>
    <span class="hljs-comment">// 以第二行为例，</span>
    <span class="hljs-comment">// 对于4这个字符而言， 4 = 2(左边的索引) + 2(两倍) * 1(下面有一行)</span>
    <span class="hljs-comment">// 6 = 4 + 2 * 1(上面有一行)</span>
    <span class="hljs-comment">// 8 = 6 + 2 * 1(下面有一行)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s, <span class="hljs-keyword">int</span> numRows)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (numRows &lt;= <span class="hljs-number">1</span>)
            <span class="hljs-keyword">return</span> s;
        
        <span class="hljs-keyword">char</span>[] cs = s.toCharArray();
        <span class="hljs-keyword">String</span> res = <span class="hljs-string">&quot;&quot;</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++)&#123;
            <span class="hljs-keyword">int</span> up = i; <span class="hljs-comment">// 上方的行数</span>
            <span class="hljs-keyword">int</span> down = numRows - <span class="hljs-number">1</span> - i; <span class="hljs-comment">// 下方的行数</span>
            <span class="hljs-keyword">int</span> temp = i;
            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (temp &lt; cs.length)&#123;
                <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; down != <span class="hljs-number">0</span>) &#123;
                    res += cs[temp];
                    temp += <span class="hljs-number">2</span> * down;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &amp;&amp; up != <span class="hljs-number">0</span>)&#123;
                    res += cs[temp];
                    temp += <span class="hljs-number">2</span> * up;
                &#125;
                cnt++;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre>

<h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><pre><code class="hljs arduino">给出一个 <span class="hljs-number">32</span> 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
输入: <span class="hljs-number">123</span>
输出: <span class="hljs-number">321</span>

输入: <span class="hljs-number">-123</span>
输出: <span class="hljs-number">-321</span>

输入: <span class="hljs-number">120</span>
输出: <span class="hljs-number">21</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;
        注意题目条件
        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// 常用公式</span>
            ans = ans * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;
            x /= <span class="hljs-number">10</span>;
        &#125;
        <span class="hljs-comment">// 判断是否溢出</span>
        <span class="hljs-keyword">if</span>(ans &gt; Integer.MAX_VALUE || ans &lt; Integer.MIN_VALUE) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)ans;
    &#125;
&#125;</code></pre>

<h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h2><pre><code class="hljs gml">判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
输入: <span class="hljs-number">121</span>
输出: <span class="hljs-literal">true</span>

输入: <span class="hljs-number">-121</span>
输出: <span class="hljs-literal">false</span>
解释: 从左向右读, 为 <span class="hljs-number">-121</span> 。 从右向左读, 为 <span class="hljs-number">121</span>- 。因此它不是一个回文数。

输入: <span class="hljs-number">10</span>
输出: <span class="hljs-literal">false</span>
解释: 从右向左读, 为 <span class="hljs-number">01</span> 。因此它不是一个回文数。
class Solution &#123;
    public boolean isPalindrome(int <span class="hljs-symbol">x</span>) &#123;
        <span class="hljs-comment">// 0也是回文数</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-symbol">x</span> == <span class="hljs-number">0</span>) 
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-comment">// 特殊条件</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-symbol">x</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-symbol">x</span> % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>) 
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-comment">// 只需要一半</span>
        int right = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> ( <span class="hljs-symbol">x</span> &gt; right) &#123;
            right = right * <span class="hljs-number">10</span> + <span class="hljs-symbol">x</span> % <span class="hljs-number">10</span>;
            <span class="hljs-symbol">x</span> /= <span class="hljs-number">10</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-symbol">x</span> == right || <span class="hljs-symbol">x</span> == right / <span class="hljs-number">10</span>;
    &#125;
&#125;</code></pre>

<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><pre><code class="hljs arduino">给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, <span class="hljs-number">0</span>)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 <span class="hljs-number">2</span>。
输入：[<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]
输出：<span class="hljs-number">49</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] <span class="hljs-built_in">height</span>)</span> </span>&#123;
        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-built_in">height</span>.length - <span class="hljs-number">1</span>; i &lt; j;) &#123;
            <span class="hljs-comment">// 双指针，谁小取谁，判断移动</span>
            <span class="hljs-keyword">int</span> minHeight = <span class="hljs-built_in">height</span>[i] &lt; <span class="hljs-built_in">height</span>[j] ? <span class="hljs-built_in">height</span>[i++] : <span class="hljs-built_in">height</span>[j--];
            <span class="hljs-comment">// 每一次都要维护最大值</span>
            <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, (j - i + <span class="hljs-number">1</span>) * minHeight);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;
    &#125;
&#125;</code></pre>

<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><pre><code class="hljs processing">编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 <span class="hljs-string">&quot;&quot;</span>。
输入: [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]
输出: <span class="hljs-string">&quot;fl&quot;</span>

输入: [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]
输出: <span class="hljs-string">&quot;&quot;</span>
解释: 输入不存在公共前缀。
class Solution &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> longestCommonPrefix(<span class="hljs-keyword">String</span>[] strs) &#123;
        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>) 
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;
        <span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = strs[<span class="hljs-number">0</span>];
        <span class="hljs-comment">// 循环用indexOf和substring</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;
            <span class="hljs-keyword">while</span>(strs[i].indexOf(<span class="hljs-built_in">str</span>) != <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 每次substring去掉最后一位</span>
                <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span>.substring(<span class="hljs-number">0</span>, <span class="hljs-built_in">str</span>.length() - <span class="hljs-number">1</span>);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>;
    &#125;
&#125;</code></pre>

<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><pre><code class="hljs inform7">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
给定数组 nums = <span class="hljs-comment">[-1, 0, 1, 2, -1, -4]</span>，

满足要求的三元组集合为：
<span class="hljs-comment">[</span>
<span class="hljs-comment">  <span class="hljs-comment">[-1, 0, 1]</span>,</span>
<span class="hljs-comment">  <span class="hljs-comment">[-1, -1, 2]</span></span>
<span class="hljs-comment">]</span></code></pre>

<p>这道题三要素：</p>
<ol>
<li>排序</li>
<li>双指针</li>
<li>去重复</li>
</ol>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; three<span class="hljs-constructor">Sum(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;
        <span class="hljs-comment">// 排序的目的就是来告别重复</span>
        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(nums);
        List&lt;List&lt;Integer&gt;&gt; ls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;
            <span class="hljs-comment">// 判断是否元素大于0,大于0，没必要操作了</span>
            <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &gt; <span class="hljs-number">0</span>) break; 
            <span class="hljs-comment">// 判断是否重复</span>
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span>) continue;
            <span class="hljs-comment">// 双指针操作</span>
            <span class="hljs-built_in">int</span> l = i + <span class="hljs-number">1</span>, r = nums.length - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (l &lt; r) &#123;
                <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> + nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span> &lt; -nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) l++;
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> + nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span> &gt; -nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) r--;
                <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-comment">// 相等了哈</span>
                    ls.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">nums</span>[<span class="hljs-params">i</span>], <span class="hljs-params">nums</span>[<span class="hljs-params">l</span>], <span class="hljs-params">nums</span>[<span class="hljs-params">r</span>])</span>);
                    <span class="hljs-comment">// 防止重复</span>
                    <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span> + <span class="hljs-number">1</span>]</span>) l++;
                    <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span> - <span class="hljs-number">1</span>]</span>) r--;
                    l++;
                    r--;
                &#125;
            &#125;
        &#125;
        return ls;
    &#125;
&#125;</code></pre>

<p>哪种代码好理解就用哪种</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; three<span class="hljs-constructor">Sum(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;
        <span class="hljs-comment">// 排序</span>
        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(nums);
        List&lt;List&lt;Integer&gt;&gt; ls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;
            <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>(i &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> != nums<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span>)) &#123; <span class="hljs-comment">//跳过可能重复的</span>
                <span class="hljs-comment">// 转化为两数之和</span>
                <span class="hljs-built_in">int</span> l = i + <span class="hljs-number">1</span>, r = nums.length - <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span> - nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;
                <span class="hljs-keyword">while</span>(l &lt; r) &#123;
                    <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> + nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span><span class="hljs-operator"> == </span>sum) &#123;
                        ls.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">nums</span>[<span class="hljs-params">i</span>], <span class="hljs-params">nums</span>[<span class="hljs-params">l</span>], <span class="hljs-params">nums</span>[<span class="hljs-params">r</span>])</span>);
                        <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span> + <span class="hljs-number">1</span>]</span>) l++; <span class="hljs-comment">// 还是一样，跳过重复</span>
                        <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span> - <span class="hljs-number">1</span>]</span>) r--;
                        l++;
                        r--;
                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> + nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span> &lt; sum) &#123;
                        <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span> + <span class="hljs-number">1</span>]</span>) l++;
                        l++;
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span> - <span class="hljs-number">1</span>]</span>) r--;
                        r--;
                    &#125;
                &#125;
            &#125;
        &#125;
        return ls;
    &#125;
&#125;</code></pre>

<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><pre><code class="hljs prolog">给定一个仅包含数字 <span class="hljs-number">2</span><span class="hljs-number">-9</span> 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 <span class="hljs-number">1</span> 不对应任何字母。
输入：<span class="hljs-string">&quot;23&quot;</span>
输出：[<span class="hljs-string">&quot;ad&quot;</span>, <span class="hljs-string">&quot;ae&quot;</span>, <span class="hljs-string">&quot;af&quot;</span>, <span class="hljs-string">&quot;bd&quot;</span>, <span class="hljs-string">&quot;be&quot;</span>, <span class="hljs-string">&quot;bf&quot;</span>, <span class="hljs-string">&quot;cd&quot;</span>, <span class="hljs-string">&quot;ce&quot;</span>, <span class="hljs-string">&quot;cf&quot;</span>].</code></pre>

<p>回溯 不需要标记 但是记得deleteCharAt</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    <span class="hljs-keyword">private</span> static final String<span class="hljs-literal">[]</span> KEYS = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;
    public List&lt;String&gt; letter<span class="hljs-constructor">Combinations(String <span class="hljs-params">digits</span>)</span> &#123;
        List&lt;String&gt; combinnations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;
        <span class="hljs-keyword">if</span> (digits<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>digits.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return combinnations;
        <span class="hljs-keyword">do</span><span class="hljs-constructor">Combination(<span class="hljs-params">new</span> StringBuilder()</span>, combinnations, digits);
        return combinnations;
    &#125;
    
    <span class="hljs-keyword">private</span> void <span class="hljs-keyword">do</span><span class="hljs-constructor">Combination(StringBuilder <span class="hljs-params">prefix</span>, List&lt;String&gt; <span class="hljs-params">combinnations</span>, <span class="hljs-params">final</span> String <span class="hljs-params">digits</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (prefix.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span>digits.length<span class="hljs-literal">()</span>) &#123;
            combinnations.add(prefix.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);
            return;
        &#125;
        <span class="hljs-built_in">int</span> curDigits = digits.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">prefix</span>.<span class="hljs-params">length</span>()</span>) - <span class="hljs-character">&#x27;0&#x27;</span>;
        String letters = KEYS<span class="hljs-literal">[<span class="hljs-identifier">curDigits</span>]</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">char</span> c : letters.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>) &#123;
            prefix.append(c);
            <span class="hljs-keyword">do</span><span class="hljs-constructor">Combination(<span class="hljs-params">prefix</span>, <span class="hljs-params">combinnations</span>, <span class="hljs-params">digits</span>)</span>;
            prefix.delete<span class="hljs-constructor">CharAt(<span class="hljs-params">prefix</span>.<span class="hljs-params">length</span>()</span> - <span class="hljs-number">1</span>);
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h2><pre><code class="hljs clean">给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 n = <span class="hljs-number">2.</span>

当删除了倒数第二个节点后，链表变为 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5.</span></code></pre>

<p>快慢指针 分情况</p>
<pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="hljs-built_in">int</span> n) &#123;
        ListNode fast = head;
        <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;
            fast = fast.<span class="hljs-keyword">next</span>;
        &#125;
        <span class="hljs-comment">// 这里没懂， 得举例子就懂了</span>
        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span>) 
            <span class="hljs-keyword">return</span> head.<span class="hljs-keyword">next</span>;
        ListNode slow = head;
        <span class="hljs-keyword">while</span> (fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;
            fast = fast.<span class="hljs-keyword">next</span>;
            slow = slow.<span class="hljs-keyword">next</span>;
        &#125;
        <span class="hljs-comment">// 这里也懂了...举个例子就行</span>
        slow.<span class="hljs-keyword">next</span> = slow.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;
        <span class="hljs-keyword">return</span> head;
    &#125;
&#125;</code></pre>

<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><pre><code class="hljs actionscript">给定一个只包括 <span class="hljs-string">&#x27;(&#x27;</span>，<span class="hljs-string">&#x27;)&#x27;</span>，<span class="hljs-string">&#x27;&#123;&#x27;</span>，<span class="hljs-string">&#x27;&#125;&#x27;</span>，<span class="hljs-string">&#x27;[&#x27;</span>，<span class="hljs-string">&#x27;]&#x27;</span> 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。
输入: <span class="hljs-string">&quot;()&quot;</span>
输出: <span class="hljs-literal">true</span>

输入: <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span>
输出: <span class="hljs-literal">true</span>

输入: <span class="hljs-string">&quot;(]&quot;</span>
输出: <span class="hljs-literal">false</span>

输入: <span class="hljs-string">&quot;([)]&quot;</span>
输出: <span class="hljs-literal">false</span></code></pre>

<p>栈思想</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;
        Stack&lt;Character&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span>.isEmpty()) 
                <span class="hljs-built_in">stack</span>.push(c);
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(isSym(<span class="hljs-built_in">stack</span>.<span class="hljs-built_in">peek</span>(), c)) 
                <span class="hljs-built_in">stack</span>.pop();
            <span class="hljs-keyword">else</span> 
                <span class="hljs-built_in">stack</span>.push(c);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>.isEmpty();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSym</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c1, <span class="hljs-keyword">char</span> c2)</span> </span>&#123;
        <span class="hljs-keyword">return</span> (c1 == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; c2 == <span class="hljs-string">&#x27;)&#x27;</span>)
            || (c1 == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; c2 == <span class="hljs-string">&#x27;&#125;&#x27;</span>)
            || (c1 == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; c2 == <span class="hljs-string">&#x27;]&#x27;</span>);
    &#125;
&#125;</code></pre>

<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><pre><code class="hljs haskell">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>
输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span>
<span class="hljs-class">    public <span class="hljs-type">ListNode</span> mergeTwoLists(<span class="hljs-type">ListNode</span> <span class="hljs-title">l1</span>, <span class="hljs-type">ListNode</span> <span class="hljs-title">l2</span>) &#123;</span>
<span class="hljs-class">        if (<span class="hljs-title">l1</span> == <span class="hljs-title">null</span>) return l2;</span>
<span class="hljs-class">        if (<span class="hljs-title">l2</span> == <span class="hljs-title">null</span>) return l1;</span>
<span class="hljs-class">        if (<span class="hljs-title">l1</span>.<span class="hljs-title">val</span> &lt; <span class="hljs-title">l2</span>.<span class="hljs-title">val</span>) &#123;</span>
<span class="hljs-class">            l1.next = mergeTwoLists(<span class="hljs-title">l1</span>.<span class="hljs-title">next</span>, <span class="hljs-title">l2</span>);</span>
<span class="hljs-class">            return l1;</span>
<span class="hljs-class">        &#125; else &#123;</span>
<span class="hljs-class">            l2.next = mergeTwoLists(<span class="hljs-title">l1</span>, <span class="hljs-title">l2</span>.<span class="hljs-title">next</span>);</span>
<span class="hljs-class">            return l2;</span>
<span class="hljs-class">        &#125;</span>
<span class="hljs-class">    &#125;</span>
<span class="hljs-class">&#125;</span></code></pre>

<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><blockquote>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：n = 3</span>
<span class="hljs-meta">&gt;</span><span class="bash">输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]</span></code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：n = 1</span>
<span class="hljs-meta">&gt;</span><span class="bash">输出：[<span class="hljs-string">&quot;()&quot;</span>]</span></code></pre>
</blockquote>
<pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    List&lt;<span class="hljs-built_in">String</span>&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">generateParenthesis</span>(<span class="hljs-params">int n</span>)</span> &#123;
        dfs(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);
        <span class="hljs-keyword">return</span> ret;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">dfs</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> ans, int cnt1, int cnt2, int n</span>)</span>&#123;
        <span class="hljs-keyword">if</span> (cnt1 &gt; n || cnt2 &gt; n)
            <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (cnt1 == n &amp;&amp; cnt2 == n)
            ret.add(ans);
        <span class="hljs-keyword">if</span> (cnt1 &gt;= cnt2)&#123;
            <span class="hljs-built_in">String</span> ans1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(ans);
            dfs(ans + <span class="hljs-string">&quot;(&quot;</span>, cnt1 + <span class="hljs-number">1</span>, cnt2, n);
            dfs(ans + <span class="hljs-string">&quot;)&quot;</span>, cnt1, cnt2 + <span class="hljs-number">1</span>, n);
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h2><blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<pre><code class="hljs accesslog">&gt;输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span>
&gt;输出：<span class="hljs-string">[2,1,4,3,5]</span></code></pre>

<pre><code class="hljs accesslog">&gt;输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">3</span>
&gt;输出：<span class="hljs-string">[3,2,1,4,5]</span></code></pre>

<pre><code class="hljs accesslog">&gt;输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">1</span>
&gt;输出：<span class="hljs-string">[1,2,3,4,5]</span></code></pre>

<pre><code class="hljs inform7">&gt;输入：head = <span class="hljs-comment">[1]</span>, k = 1
&gt;输出：<span class="hljs-comment">[1]</span></code></pre>
</blockquote>
<pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> ListNode reverseKGroup(ListNode head, <span class="hljs-built_in">int</span> k) &#123;
        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);
        ListNode pre = dummy, cur = head, <span class="hljs-keyword">next</span>;
        dummy.<span class="hljs-keyword">next</span> = head;
        ListNode p = head;
        <span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>)&#123;
            len++;
            p = p.<span class="hljs-keyword">next</span>;
        &#125;
        <span class="hljs-comment">// </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; len / k; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; k - <span class="hljs-number">1</span>; j++) &#123;
                <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;
                
                <span class="hljs-comment">// 注意这三步</span>
                cur.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;
                <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = pre.<span class="hljs-keyword">next</span>;
                pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;
            &#125;
            <span class="hljs-comment">// 移动的时候注意</span>
            pre = cur;
            cur = pre.<span class="hljs-keyword">next</span>;
        &#125;
        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;
    &#125;
&#125;</code></pre>

<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h2><pre><code class="hljs angelscript">给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(<span class="hljs-number">1</span>) 额外空间的条件下完成。
给定数组 nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], 

函数应该返回新的长度 <span class="hljs-number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="hljs-number">1</span>, <span class="hljs-number">2</span>。 

你不需要考虑数组中超出新长度后面的元素。
<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> removeDuplicates(<span class="hljs-built_in">int</span>[] nums) &#123;
        <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;
            <span class="hljs-keyword">if</span>(nums[p] != nums[i]) &#123;
                nums[++p] = nums[i];
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> p+<span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><pre><code class="hljs reasonml">给你一个数组 nums 和一个值 <span class="hljs-keyword">val</span>，你需要 原地 移除所有数值等于 <span class="hljs-keyword">val</span> 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 <span class="hljs-constructor">O(1)</span> 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
给定 nums = <span class="hljs-literal">[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span>, <span class="hljs-keyword">val</span> = <span class="hljs-number">3</span>,

函数应该返回新的长度 <span class="hljs-number">2</span>, 并且 nums 中的前两个元素均为 <span class="hljs-number">2</span>。

你不需要考虑数组中超出新长度后面的元素。
<span class="hljs-keyword">class</span> Solution &#123;
    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;
        <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> != <span class="hljs-keyword">val</span>) 
                nums<span class="hljs-literal">[<span class="hljs-identifier">p</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;
        &#125;
        return p;
    &#125;
&#125;</code></pre>

<h2 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h2><pre><code class="hljs pgsql">实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从<span class="hljs-number">0</span>开始)。如果不存在，则返回  <span class="hljs-number">-1</span>。
输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: <span class="hljs-number">2</span>
<span class="hljs-keyword">class</span> Solution &#123;
    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> strStr(String haystack, String needle) &#123;
       <span class="hljs-type">int</span> l = haystack.length(), n = needle.length();
       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-keyword">start</span> &lt; l - n + <span class="hljs-number">1</span>; <span class="hljs-keyword">start</span>++) &#123;
           // subtring + equals
           <span class="hljs-keyword">if</span>(haystack.substring(<span class="hljs-keyword">start</span>, <span class="hljs-keyword">start</span> + n).equals(needle)) &#123;
               <span class="hljs-keyword">return</span> <span class="hljs-keyword">start</span>;
           &#125;
       &#125;
       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
&#125;</code></pre>

<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h2><blockquote>
<p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。</p>
<pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">0</span>
&gt;输出：<span class="hljs-number">4</span></code></pre>

<pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">3</span>
&gt;输出：-<span class="hljs-number">1</span></code></pre>

<pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">0</span>
&gt;输出：-<span class="hljs-number">1</span></code></pre>
</blockquote>
<p>变相的二分</p>
<pre><code class="hljs excel">class Solution &#123;
    public <span class="hljs-built_in">int</span> <span class="hljs-built_in">search</span>(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target) &#123;
        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = nums.length;
        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = <span class="hljs-built_in">len</span> - <span class="hljs-number">1</span>;
        while (<span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span>) &#123;
            <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;
            <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] == target)
                return <span class="hljs-built_in">mid</span>;
            else <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>] &lt; nums[<span class="hljs-built_in">right</span>]) &#123;
                // 注意边界条件
                <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &lt; target &amp;&amp; target &lt;= nums[<span class="hljs-built_in">right</span>])
                    <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;
                else 
                    <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;
            &#125; else &#123;
                <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">left</span>] &lt;= target &amp;&amp; target &lt; nums[<span class="hljs-built_in">mid</span>])
                    <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;
                else 
                    <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;
            &#125;
        &#125;
        return -<span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><pre><code class="hljs makefile">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。
<span class="hljs-section">输入: [1,3,5,6], 5</span>
<span class="hljs-section">输出: 2</span>
<span class="hljs-section">输入: [1,3,5,6], 2</span>
<span class="hljs-section">输出: 1</span>
<span class="hljs-section">输入: [1,3,5,6], 7</span>
<span class="hljs-section">输出: 4</span>
<span class="hljs-section">输入: [1,3,5,6], 0</span>
<span class="hljs-section">输出: 0</span></code></pre>

<p>二分法 但要考虑边界</p>
<pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> h = nums.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;
            <span class="hljs-keyword">int</span> mid = l + (h - l) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (nums[mid] &lt; <span class="hljs-keyword">target</span>) 
                l = mid + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; <span class="hljs-keyword">target</span>) 
                h = mid - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> 
                <span class="hljs-keyword">return</span> mid;
        &#125;
        <span class="hljs-comment">// 注意边界</span>
        <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">0</span> &amp;&amp; l == <span class="hljs-number">0</span>) 
            <span class="hljs-keyword">return</span> (l + h) % <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> 
            <span class="hljs-keyword">return</span> (l + h) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h2><pre><code class="hljs excel">给定一个正整数 <span class="hljs-built_in">n</span>（<span class="hljs-number">1</span> ≤ <span class="hljs-built_in">n</span> ≤ <span class="hljs-number">30</span>），输出外观数列的第 <span class="hljs-built_in">n</span> 项。

注意：整数序列中的每一项将表示为一个字符串。

「外观数列」是一个整数序列，从数字 <span class="hljs-number">1</span> 开始，序列中的每一项都是对前一项的描述。前五项如下：

<span class="hljs-number">1</span>.     <span class="hljs-number">1</span>
<span class="hljs-number">2</span>.     <span class="hljs-number">11</span>
<span class="hljs-number">3</span>.     <span class="hljs-number">21</span>
<span class="hljs-number">4</span>.     <span class="hljs-number">1211</span>
<span class="hljs-number">5</span>.     <span class="hljs-number">111221</span>

第一项是数字 <span class="hljs-number">1</span>

描述前一项，这个数是 <span class="hljs-number">1</span> 即 “一个 <span class="hljs-number">1</span> ”，记作 <span class="hljs-number">11</span>

描述前一项，这个数是 <span class="hljs-number">11</span> 即 “两个 <span class="hljs-number">1</span> ” ，记作 <span class="hljs-number">21</span>

描述前一项，这个数是 <span class="hljs-number">21</span> 即 “一个 <span class="hljs-number">2</span> 一个 <span class="hljs-number">1</span> ” ，记作 <span class="hljs-number">1211</span>

描述前一项，这个数是 <span class="hljs-number">1211</span> 即 “一个 <span class="hljs-number">1</span> 一个 <span class="hljs-number">2</span> 两个 <span class="hljs-number">1</span> ” ，记作 <span class="hljs-number">111221</span>
输入<span class="hljs-symbol">:</span> <span class="hljs-number">1</span>
输出<span class="hljs-symbol">:</span> <span class="hljs-string">&quot;1&quot;</span>
解释：这是一个基本样例。

输入<span class="hljs-symbol">:</span> <span class="hljs-number">4</span>
输出<span class="hljs-symbol">:</span> <span class="hljs-string">&quot;1211&quot;</span>
解释：当 <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span> 时，序列是 <span class="hljs-string">&quot;21&quot;</span>，其中我们有 <span class="hljs-string">&quot;2&quot;</span> 和 <span class="hljs-string">&quot;1&quot;</span> 两组，<span class="hljs-string">&quot;2&quot;</span> 可以读作 <span class="hljs-string">&quot;12&quot;</span>，也就是出现频次 = <span class="hljs-number">1</span> 而 值 = <span class="hljs-number">2</span>；类似 <span class="hljs-string">&quot;1&quot;</span> 可以读作 <span class="hljs-string">&quot;11&quot;</span>。所以答案是 <span class="hljs-string">&quot;12&quot;</span> 和 <span class="hljs-string">&quot;11&quot;</span> 组合在一起，也就是 <span class="hljs-string">&quot;1211&quot;</span>。</code></pre>

<p>StringBuffer + cnt</p>
<pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> String countAndSay(<span class="hljs-built_in">int</span> n) &#123;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;
        &#125;
        String <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;1&quot;</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;
            StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();
            <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;
            <span class="hljs-built_in">char</span> code = <span class="hljs-built_in">str</span>.charAt(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">str</span>.length(); j++) &#123;
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">str</span>.charAt(j) != code) &#123;
                    sb.append(<span class="hljs-keyword">count</span>);
                    sb.append(code);
                    code = <span class="hljs-built_in">str</span>.charAt(j);
                    <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    <span class="hljs-keyword">count</span>++;
                &#125;
            &#125;
            sb.append(<span class="hljs-keyword">count</span>);
            sb.append(<span class="hljs-built_in">str</span>.charAt(<span class="hljs-built_in">str</span>.length() - <span class="hljs-number">1</span>));
            <span class="hljs-built_in">str</span> = sb.toString();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>;
    &#125;
&#125;</code></pre>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><blockquote>
<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<pre><code class="hljs dns">&gt;输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]
&gt;输出：<span class="hljs-number">6</span></code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：height = [4,2,0,3,2,5]</span>
<span class="hljs-meta">&gt;</span><span class="bash">输出：9</span></code></pre>

<p>在坐标系上绘画出高度图看。</p>
</blockquote>
<p>双指针</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] <span class="hljs-built_in">height</span>)</span> </span>&#123;
        <span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-built_in">height</span>.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(l &lt; r) &#123;
            <span class="hljs-comment">// 双指针维护最小值</span>
            <span class="hljs-built_in">min</span> = <span class="hljs-built_in">height</span>[<span class="hljs-built_in">height</span>[l] &lt; <span class="hljs-built_in">height</span>[r] ? l++ : r--];
            <span class="hljs-comment">// 接着维护最大值</span>
            <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span>);
            <span class="hljs-comment">// 累加差值</span>
            res += <span class="hljs-built_in">max</span> - <span class="hljs-built_in">min</span>;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre>

<h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h2><blockquote>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<pre><code class="hljs gcode">&gt;输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;3&quot;</span>
&gt;输出: <span class="hljs-string">&quot;6&quot;</span></code></pre>

<pre><code class="hljs gcode">&gt;输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;456&quot;</span>
&gt;输出: <span class="hljs-string">&quot;56088&quot;</span></code></pre>
</blockquote>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">String</span> num1, <span class="hljs-keyword">String</span> num2)</span> </span>&#123;
        <span class="hljs-keyword">int</span> len1 = num1.length();
        <span class="hljs-keyword">int</span> len2 = num2.length();
        <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span> || len2 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;
        <span class="hljs-keyword">int</span>[] mul = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1 + len2];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = len2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;
                <span class="hljs-keyword">int</span> n = (num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * (num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>) + mul[i + j + <span class="hljs-number">1</span>];
                mul[i + j + <span class="hljs-number">1</span>] = n % <span class="hljs-number">10</span>;
                mul[i + j] += n / <span class="hljs-number">10</span>;
            &#125;
        &#125;
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; len1 + len2 - <span class="hljs-number">1</span> &amp;&amp; mul[i] == <span class="hljs-number">0</span>) i++;
        <span class="hljs-keyword">while</span> (i &lt; len1 + len2) sb.append(mul[i++]);
        <span class="hljs-keyword">return</span> sb.toString();
    &#125;

&#125;</code></pre>

<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><pre><code class="hljs angelscript">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>],
输出: <span class="hljs-number">6</span>
解释: 连续子数组 [<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大，为 <span class="hljs-number">6</span>。
<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxSubArray(<span class="hljs-built_in">int</span>[] nums) &#123;
        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-built_in">int</span> preSum = nums[<span class="hljs-number">0</span>];
        <span class="hljs-built_in">int</span> maxSum = preSum;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;
            <span class="hljs-comment">// 注意条件</span>
            preSum = preSum &gt; <span class="hljs-number">0</span> ? preSum + nums[i] : nums[i];
            maxSum = Math.max(maxSum, preSum);
        &#125;
        <span class="hljs-keyword">return</span> maxSum;
    &#125;
&#125;</code></pre>

<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><pre><code class="hljs makefile">给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。
<span class="hljs-section">输入: [2,3,1,1,4]</span>
<span class="hljs-section">输出: true</span>
<span class="hljs-section">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span>

<span class="hljs-section">输入: [3,2,1,0,4]</span>
<span class="hljs-section">输出: false</span>
<span class="hljs-section">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span></code></pre>

<p>贪心</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">int</span> n = nums.length;
        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;
            <span class="hljs-comment">// 注意条件</span>
            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-built_in">max</span>) &#123;
                <span class="hljs-comment">// 最远索引</span>
                <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, nums[i] + i);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-comment">// 注意判断</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span> &gt;= n - <span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h2><pre><code class="hljs makefile">给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。
<span class="hljs-section">输入: [1,2,3]</span>
<span class="hljs-section">输出: [1,2,4]</span>
<span class="hljs-section">解释: 输入数组表示数字 123。</span>

<span class="hljs-section">输入: [4,3,2,1]</span>
<span class="hljs-section">输出: [4,3,2,2]</span>
<span class="hljs-section">解释: 输入数组表示数字 4321。</span></code></pre>

<p>正常操作 加法中常用 a = x % 10 b = x / 10</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> plus<span class="hljs-constructor">One(<span class="hljs-params">int</span>[] <span class="hljs-params">digits</span>)</span> &#123;
        <span class="hljs-built_in">int</span> length = digits.length;
        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">length</span> + <span class="hljs-number">1</span>]</span>;
        <span class="hljs-built_in">int</span> carry = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;
            <span class="hljs-built_in">int</span> sums = digits<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> + carry;
            res<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sums % <span class="hljs-number">10</span>;
            carry = sums<span class="hljs-operator"> / </span><span class="hljs-number">10</span>;
        &#125;
        <span class="hljs-keyword">if</span> (carry<span class="hljs-operator"> == </span><span class="hljs-number">1</span>) &#123;
            res<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">1</span>;
            return res;
        &#125;
        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">res</span>,0,<span class="hljs-params">length</span>)</span>;

    &#125;
&#125;</code></pre>

<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><pre><code class="hljs tap">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬<span class="hljs-number"> 1 </span>或<span class="hljs-number"> 2 </span>个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶
2. <span class="hljs-number"> 2 </span>阶

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶
2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶
3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶</code></pre>

<p>自底向上</p>
<pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> climbStairs(<span class="hljs-built_in">int</span> n) &#123;
        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;
        <span class="hljs-built_in">int</span> pre2 = <span class="hljs-number">1</span>, pre1 = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;
            <span class="hljs-built_in">int</span> cur = pre2 + pre1;
            pre2 = pre1;
            pre1 = cur;
        &#125;
        <span class="hljs-keyword">return</span> pre1;
    &#125;
&#125;</code></pre>

<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><pre><code class="hljs makefile">给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
<span class="hljs-section">说明:</span>

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
<span class="hljs-section">输入:</span>
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

<span class="hljs-section">输出: [1,2,2,3,5,6]</span></code></pre>

<p>三指针</p>
<pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> merge(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n) &#123;
    <span class="hljs-type">int</span> index1 = m - <span class="hljs-number">1</span>, index2 = n - <span class="hljs-number">1</span>;
    <span class="hljs-type">int</span> indexMerge = m + n - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (index1 &gt;= <span class="hljs-number">0</span> || index2 &gt;= <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">if</span> (index1 &lt; <span class="hljs-number">0</span>) &#123;
            nums1[indexMerge<span class="hljs-comment">--] = nums2[index2--];</span>
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index2 &lt; <span class="hljs-number">0</span>) &#123;
            nums1[indexMerge<span class="hljs-comment">--] = nums1[index1--];</span>
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;
            nums1[indexMerge<span class="hljs-comment">--] = nums1[index1--];</span>
        &#125; <span class="hljs-keyword">else</span> &#123;
            nums1[indexMerge<span class="hljs-comment">--] = nums2[index2--];</span>
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><pre><code class="hljs inform7">给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
    3
   / \
  9  20
    /  \
   15   7

<span class="hljs-comment">[</span>
<span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span>
<span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span>
<span class="hljs-comment">  <span class="hljs-comment">[15,7]</span></span>
<span class="hljs-comment">]</span></code></pre>

<p>队列</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
        List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        Queue&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
        <span class="hljs-built_in">queue</span>.add(root);
        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">queue</span>.isEmpty()) &#123;
            ArrayList&lt;Integer&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            <span class="hljs-keyword">int</span> cnt = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();
            <span class="hljs-keyword">while</span> (cnt-- &gt; <span class="hljs-number">0</span>) &#123;
                TreeNode node = <span class="hljs-built_in">queue</span>.poll();
                <span class="hljs-keyword">if</span> (node == null)
                    <span class="hljs-keyword">continue</span>;
                <span class="hljs-built_in">list</span>.add(node.val);
                <span class="hljs-built_in">queue</span>.add(node.left);
                <span class="hljs-built_in">queue</span>.add(node.right);
            &#125;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>)
                ret.add(<span class="hljs-built_in">list</span>);
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre>

<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><pre><code class="hljs glsl">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。
输入: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]
输出: <span class="hljs-number">5</span>
解释: 在第 <span class="hljs-number">2</span> 天（股票价格 = <span class="hljs-number">1</span>）的时候买入，在第 <span class="hljs-number">5</span> 天（股票价格 = <span class="hljs-number">6</span>）的时候卖出，最大利润 = <span class="hljs-number">6</span><span class="hljs-number">-1</span> = <span class="hljs-number">5</span> 。
     注意利润不能是 <span class="hljs-number">7</span><span class="hljs-number">-1</span> = <span class="hljs-number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票

输入: [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]
输出: <span class="hljs-number">0</span>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。
class Solution &#123;
    public <span class="hljs-type">int</span> maxProfit(<span class="hljs-type">int</span>[] prices) &#123;
        <span class="hljs-comment">// 边界</span>
        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">length</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 长度</span>
        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">length</span>;
        <span class="hljs-comment">// min</span>
        <span class="hljs-type">int</span> <span class="hljs-built_in">min</span> = prices[<span class="hljs-number">0</span>];
        <span class="hljs-comment">// max</span>
        <span class="hljs-type">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;
            <span class="hljs-comment">// 一直找最小的股</span>
            <span class="hljs-built_in">min</span> = prices[i] &lt; <span class="hljs-built_in">min</span> ? prices[i] : <span class="hljs-built_in">min</span>;
            <span class="hljs-comment">// 遍历一圈，存最大的利润</span>
            <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, prices[i] - <span class="hljs-built_in">min</span>);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;
    &#125;
&#125;</code></pre>

<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h2><pre><code class="hljs angelscript">给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/<span class="hljs-number">2</span> ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。
输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
输出: <span class="hljs-number">3</span>
<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> majorityElement(<span class="hljs-built_in">int</span>[] nums) &#123;
        Arrays.sort(nums);
        <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];
    &#125;
&#125;</code></pre>

<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><pre><code class="hljs tap">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
输入：[1,2,3,1]
输出：4
解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。
     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。

输入：[2,7,9,3,1]
输出：12
解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。
     偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。
class Solution &#123;
    public int rob(int[] nums) &#123;
        int pre2 = 0, pre1 = 0;
        for (int i = 0; i &lt; nums.length; i++) &#123;
            int cur = Math.max(pre2 + nums[i], pre1);
            pre2 = pre1;
            pre1 = cur;
        &#125;
        return pre1;
    &#125;
&#125;</code></pre>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><pre><code class="hljs gradle">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-keyword">NULL</span>
输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-keyword">NULL</span>
<span class="hljs-keyword">class</span> Solution &#123;
    <span class="hljs-keyword">public</span> ListNode reverseList(ListNode head) &#123;
        <span class="hljs-comment">// 尾递归</span>
        <span class="hljs-comment">// return reverse(null, head);</span>
        <span class="hljs-comment">// 头插</span>
        ListNode pre = <span class="hljs-keyword">null</span>;
        ListNode cur = head;
        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;
            ListNode <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;
            cur.<span class="hljs-keyword">next</span> = pre;
            pre = cur;
            cur = <span class="hljs-keyword">next</span>;
        &#125;
        <span class="hljs-keyword">return</span> pre;
    &#125;
    <span class="hljs-keyword">private</span> ListNode <span class="hljs-keyword">reverse</span>(ListNode pre, ListNode cur) &#123;
        <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> pre;
        ListNode <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;
        cur.<span class="hljs-keyword">next</span> = pre;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">reverse</span>(cur, <span class="hljs-keyword">next</span>);
    &#125;
&#125;</code></pre>

<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h2><pre><code class="hljs arduino">使用队列实现栈的下列操作：

push(x) -- 元素 x 入栈
pop() -- 移除栈顶元素
top() -- 获取栈顶元素
empty() -- 返回栈是否为空
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;</span>
    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; <span class="hljs-built_in">queue</span>;
    <span class="hljs-comment">/** Initialize your data structure here. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    &#125;
    
    <span class="hljs-comment">/** Push element x onto stack. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;
        <span class="hljs-built_in">queue</span>.add(x);
        <span class="hljs-comment">// 加完取长度</span>
        <span class="hljs-keyword">int</span> cnt = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();
        <span class="hljs-comment">// 倒置</span>
        <span class="hljs-keyword">while</span> (cnt-- &gt; <span class="hljs-number">1</span>) &#123;
            <span class="hljs-built_in">queue</span>.add(<span class="hljs-built_in">queue</span>.poll());
        &#125;
    &#125;
    
    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">remove</span>();
    &#125;
    
    <span class="hljs-comment">/** Get the top element. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">peek</span>();
    &#125;
    
    <span class="hljs-comment">/** Returns whether the stack is empty. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>.isEmpty();
    &#125;
&#125;</code></pre>

<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><pre><code class="hljs accesslog">输入: <span class="hljs-string">[0,1,0,3,12]</span>
输出: <span class="hljs-string">[1,3,12,0,0]</span></code></pre>

<ol>
<li>先把不是0的移动左</li>
<li>最后陆续加0</li>
</ol>
<pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    public <span class="hljs-keyword">void</span> moveZeroes(<span class="hljs-built_in">int</span>[] nums) &#123;
        <span class="hljs-built_in">int</span> idx = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums) &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">num</span> != <span class="hljs-number">0</span>) 
                nums[idx++] = <span class="hljs-built_in">num</span>;
        &#125;
        <span class="hljs-keyword">while</span> (idx &lt; nums.length) &#123;
            nums[idx++] =<span class="hljs-number">0</span>;
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="1103-分糖果-II"><a href="#1103-分糖果-II" class="headerlink" title="1103. 分糖果 II"></a>1103. 分糖果 II</h2><pre><code class="hljs inform7">排排坐，分糖果。

我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。

给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。

然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。

重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。

返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans<span class="hljs-comment">[i]</span> 表示第 i 个小朋友分到的糖果数）。
输入：candies = 7, num_people = 4
输出：<span class="hljs-comment">[1,2,3,1]</span>
解释：
第一次，ans<span class="hljs-comment">[0]</span> += 1，数组变为 <span class="hljs-comment">[1,0,0,0]</span>。
第二次，ans<span class="hljs-comment">[1]</span> += 2，数组变为 <span class="hljs-comment">[1,2,0,0]</span>。
第三次，ans<span class="hljs-comment">[2]</span> += 3，数组变为 <span class="hljs-comment">[1,2,3,0]</span>。
第四次，ans<span class="hljs-comment">[3]</span> += 1（因为此时只剩下 1 颗糖果），最终数组变为 <span class="hljs-comment">[1,2,3,1]</span>。

输入：candies = 10, num_people = 3
输出：<span class="hljs-comment">[5,2,3]</span>
解释：
第一次，ans<span class="hljs-comment">[0]</span> += 1，数组变为 <span class="hljs-comment">[1,0,0]</span>。
第二次，ans<span class="hljs-comment">[1]</span> += 2，数组变为 <span class="hljs-comment">[1,2,0]</span>。
第三次，ans<span class="hljs-comment">[2]</span> += 3，数组变为 <span class="hljs-comment">[1,2,3]</span>。
第四次，ans<span class="hljs-comment">[0]</span> += 4，最终数组变为 <span class="hljs-comment">[5,2,3]</span>。
class Solution &#123;
    public int<span class="hljs-comment">[]</span> distributeCandies(int candies, int num_people) &#123;
        int<span class="hljs-comment">[]</span> ans = new int<span class="hljs-comment">[num_people]</span>;
        int i;
        for (i = 0; candies &gt; 0; i++) &#123;
            ans<span class="hljs-comment">[i % num_people]</span> += i + 1;
            candies -= i + 1;
        &#125;
        ans<span class="hljs-comment">[(i - 1) % num_people]</span> += candies;
        return ans;
    &#125;
&#125;</code></pre>

<h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a>994. 腐烂的橘子</h2><blockquote>
<p>在给定的网格中，每个单元格可以有以下三个值之一：</p>
<p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p>
<p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1</p>
<pre><code class="hljs lua">&gt;输入：<span class="hljs-string">[[2,1,1],[1,1,0],[0,1,1]]</span>
&gt;输出：<span class="hljs-number">4</span></code></pre>

<pre><code class="hljs lua">&gt;输入：<span class="hljs-string">[[2,1,1],[0,1,1],[1,0,1]]</span>
&gt;输出：<span class="hljs-number">-1</span>
&gt;解释：左下角的橘子（第 <span class="hljs-number">2</span> 行， 第 <span class="hljs-number">0</span> 列）永远不会腐烂，因为腐烂只会发生在 <span class="hljs-number">4</span> 个正向上。</code></pre>
</blockquote>
<pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> int orangesRotting(int[][] grid) &#123;
        <span class="hljs-comment">// 俺就不判断了，直接上</span>
        int[][] dir = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;
        Queue&lt;Pair&lt;Integer, Integer&gt;&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedList</span>&lt;&gt;();
        int m = grid.length, n = grid[<span class="hljs-number">0</span>].length;
        int cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示新鲜的橘子</span>
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;
                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)
                    cnt++; <span class="hljs-comment">// 新鲜橘子计数</span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>)
                    q.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(i, j)); <span class="hljs-comment">// 腐烂橘子的坐标</span>
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span> || q.size() == m * n)
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        int step = <span class="hljs-number">0</span>; <span class="hljs-comment">// 轮数</span>
        <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">0</span> &amp;&amp; !q.isEmpty())&#123;
            int size = q.size();
            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;
                Pair&lt;Integer, Integer&gt; p = q.poll();
                int x = p.getKey(), y = p.getValue();
                <span class="hljs-keyword">for</span> (int[] d : <span class="hljs-type">dir</span>) &#123;
                    int <span class="hljs-keyword">new</span><span class="hljs-type">X</span> = x + d[<span class="hljs-number">0</span>];
                    int <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> = y + d[<span class="hljs-number">1</span>];
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">X</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">new</span><span class="hljs-type">X</span> &gt;= m || <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> &gt;= n) &#123;
                        <span class="hljs-keyword">continue</span>;
                    &#125;
                    <span class="hljs-keyword">if</span> (grid[<span class="hljs-keyword">new</span><span class="hljs-type">X</span>][<span class="hljs-keyword">new</span><span class="hljs-type">Y</span>] == <span class="hljs-number">1</span>) &#123;
                        grid[<span class="hljs-keyword">new</span><span class="hljs-type">X</span>][<span class="hljs-keyword">new</span><span class="hljs-type">Y</span>] = <span class="hljs-number">2</span>;
                        q.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(<span class="hljs-keyword">new</span><span class="hljs-type">X</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Y</span>));
                        cnt--;
                    &#125;
                &#125;
            &#125;
            step++;
        &#125;
        <span class="hljs-keyword">return</span> cnt &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-type">step</span>;
    &#125;
&#125;</code></pre>

<h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a>23. 合并K个排序链表</h2><pre><code class="hljs clean">输入:
[
  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,
  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,
  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span>
]
输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span></code></pre>

<p>最小堆</p>
<pre><code class="hljs livescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    public ListNode mergeKLists(ListNode[] lists) &#123;
        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;<span class="hljs-function"><span class="hljs-params">((o1, o2) -&gt; o1.val - o2.val)</span>;</span>
<span class="hljs-function">        <span class="hljs-title">ListNode</span> <span class="hljs-title">dummy</span> = <span class="hljs-title">new</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>;</span>
<span class="hljs-function">        <span class="hljs-title">ListNode</span> <span class="hljs-title">p</span> = <span class="hljs-title">dummy</span>;</span>
<span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(ListNode node : lists)</span> &#123;</span>
<span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-params">(node != <span class="hljs-literal">null</span>)</span> <span class="hljs-title">queue</span>.<span class="hljs-title">add</span><span class="hljs-params">(node)</span>;</span>
<span class="hljs-function">        &#125;</span>
<span class="hljs-function">        <span class="hljs-title">while</span> <span class="hljs-params">(!queue.isEmpty())</span> &#123;</span>
<span class="hljs-function">            <span class="hljs-title">p</span>.<span class="hljs-title">next</span> = <span class="hljs-title">queue</span>.<span class="hljs-title">poll</span><span class="hljs-params">()</span>;</span>
<span class="hljs-function">            <span class="hljs-title">p</span> = <span class="hljs-title">p</span>.<span class="hljs-title">next</span>;</span>
<span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-params">(p.next != <span class="hljs-literal">null</span>)</span> <span class="hljs-title">queue</span>.<span class="hljs-title">add</span><span class="hljs-params">(p.next)</span>;</span>
<span class="hljs-function">        &#125;</span>
<span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">dummy</span>.<span class="hljs-title">next</span>;</span>
<span class="hljs-function">    &#125;   </span>
<span class="hljs-function">&#125;</span></code></pre>

<p>分治</p>
<pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
   <span class="hljs-keyword">public</span> ListNode <span class="hljs-function"><span class="hljs-title">mergeKLists</span>(<span class="hljs-params">ListNode[] lists</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-keyword">private</span> ListNode <span class="hljs-function"><span class="hljs-title">merge</span>(<span class="hljs-params">ListNode[] lists, int left, int right</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span> lists[left];
        int mid = left + (right - left) / <span class="hljs-number">2</span>;
        ListNode l1 = merge(lists, left, mid);
        ListNode l2 = merge(lists, mid + <span class="hljs-number">1</span>, right);
        <span class="hljs-keyword">return</span> mergeTwoLists(l1, l2);
    &#125;

    <span class="hljs-keyword">private</span> ListNode <span class="hljs-function"><span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params">ListNode l1, ListNode l2</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l2;
        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l1;
        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;
            l1.next = mergeTwoLists(l1.next, l2);
            <span class="hljs-keyword">return</span> l1;
        &#125; <span class="hljs-keyword">else</span> &#123;
            l2.next = mergeTwoLists(l1,l2.next);
            <span class="hljs-keyword">return</span> l2;
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><pre><code class="hljs axapta">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
给定 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>, 你应该返回 <span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3.</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> ListNode swapPairs(ListNode head) &#123;
        ListNode node = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);
        node.<span class="hljs-keyword">next</span> = head;
        ListNode pre = node;
        <span class="hljs-keyword">while</span> (pre.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span> &amp;&amp; pre.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;
            ListNode l1 = pre.<span class="hljs-keyword">next</span>, l2 = pre.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;
            ListNode <span class="hljs-keyword">next</span> = l2.<span class="hljs-keyword">next</span>;
            l1.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;
            l2.<span class="hljs-keyword">next</span> = l1;
            pre.<span class="hljs-keyword">next</span> = l2;
            pre = l1;
        &#125;
        <span class="hljs-keyword">return</span> node.<span class="hljs-keyword">next</span>;
    &#125;
&#125;</code></pre>

<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h2><blockquote>
<p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;(()&quot;</span></span>
<span class="hljs-meta">&gt;</span><span class="bash">输出：2</span>
<span class="hljs-meta">&gt;</span><span class="bash">解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span></span></code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;)()())&quot;</span></span>
<span class="hljs-meta">&gt;</span><span class="bash">输出：4</span>
<span class="hljs-meta">&gt;</span><span class="bash">解释：最长有效括号子串是 <span class="hljs-string">&quot;()()&quot;</span></span></code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;&quot;</span></span>
<span class="hljs-meta">&gt;</span><span class="bash">输出：0</span></code></pre>
</blockquote>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public <span class="hljs-built_in">int</span> longest<span class="hljs-constructor">ValidParentheses(String <span class="hljs-params">s</span>)</span> &#123;
        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">s</span>.<span class="hljs-identifier">length</span>()]</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length<span class="hljs-literal">()</span>; i++)&#123;
            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;)&#x27;</span>) &#123;
                <span class="hljs-built_in">int</span> j = i - dp<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span> - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;(&#x27;</span>)
                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = (i - j + <span class="hljs-number">1</span>) + ((j - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span> ? dp<span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span> : <span class="hljs-number">0</span>);
            &#125;
            ans = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(ans, dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);
        &#125;
        return ans;
    &#125;
&#125;</code></pre>

<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><pre><code class="hljs inform7">给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 <span class="hljs-comment">[-1, -1]</span>。
输入: nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8
输出: <span class="hljs-comment">[3,4]</span>

输入: nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6
输出: <span class="hljs-comment">[-1,-1]</span></code></pre>

<p>双指针+二分法</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> search<span class="hljs-constructor">Range(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">target</span>)</span> &#123;
        <span class="hljs-built_in">int</span> first = find<span class="hljs-constructor">First(<span class="hljs-params">nums</span>, <span class="hljs-params">target</span>)</span>;
        <span class="hljs-built_in">int</span> last = find<span class="hljs-constructor">First(<span class="hljs-params">nums</span>, <span class="hljs-params">target</span> + 1)</span> - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (first<span class="hljs-operator"> == </span>nums.length<span class="hljs-operator"> || </span>nums<span class="hljs-literal">[<span class="hljs-identifier">first</span>]</span> != target) &#123;
            return <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;
        &#125; <span class="hljs-keyword">else</span> &#123;
            return <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;first, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(first, last)&#125;;
        &#125;
    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> find<span class="hljs-constructor">First(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">target</span>)</span> &#123;
        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, h = nums.length; <span class="hljs-comment">// h 的初始值和往常不一样</span>
        <span class="hljs-keyword">while</span> (l &lt; h) &#123;
            <span class="hljs-built_in">int</span> m = l + ( h - l)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span> &gt;= target) h = m;
            <span class="hljs-keyword">else</span> l = m + <span class="hljs-number">1</span>;
        &#125;
        return l;
    &#125;
&#125;</code></pre>

<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><pre><code class="hljs inform7">给定一个 没有重复 数字的序列，返回其所有可能的全排列。
输入: <span class="hljs-comment">[1,2,3]</span>
输出:
<span class="hljs-comment">[</span>
<span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span>
<span class="hljs-comment">  <span class="hljs-comment">[1,3,2]</span>,</span>
<span class="hljs-comment">  <span class="hljs-comment">[2,1,3]</span>,</span>
<span class="hljs-comment">  <span class="hljs-comment">[2,3,1]</span>,</span>
<span class="hljs-comment">  <span class="hljs-comment">[3,1,2]</span>,</span>
<span class="hljs-comment">  <span class="hljs-comment">[3,2,1]</span></span>
<span class="hljs-comment">]</span></code></pre>

<p>dfs</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">permute</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        List&lt;List&lt;Integer&gt;&gt; permutes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        List&lt;Integer&gt; permuteList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">boolean</span>[] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];
        backtracking(permuteList, permutes, hasVisited, nums);
        <span class="hljs-keyword">return</span> permutes;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (permuteList.<span class="hljs-built_in">size</span>() == nums.length) &#123;
            permutes.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(permuteList)); <span class="hljs-comment">// 重新构造一个List</span>
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; visited.length; i++) &#123;
            <span class="hljs-keyword">if</span> (visited[i]) <span class="hljs-keyword">continue</span>;
            visited[i] = <span class="hljs-literal">true</span>;
            permuteList.add(nums[i]);
            backtracking(permuteList, permutes, visited, nums);
            permuteList.<span class="hljs-built_in">remove</span>(permuteList.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);
            visited[i] = <span class="hljs-literal">false</span>;
        &#125;
        
    &#125;
&#125;</code></pre>

<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><pre><code class="hljs prolog">给出一个区间的集合，请合并所有重叠的区间。
输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]
输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]
解释: 区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].

输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]
输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]]
解释: 区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。
class <span class="hljs-symbol">Solution</span> &#123;
    public int[][] merge(int[][] intervals) &#123;
        if (intervals == null || intervals.length &lt;= <span class="hljs-number">1</span>) return intervals;
        <span class="hljs-symbol">Arrays</span>.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);
        <span class="hljs-symbol">List</span>&lt;int[]&gt; list = new <span class="hljs-symbol">ArrayList</span>&lt;&gt;();
        int i = <span class="hljs-number">0</span>;
        int n = intervals.length;
        while (i &lt; n) &#123;
            int l = intervals[i][<span class="hljs-number">0</span>];
            int r = intervals[i][<span class="hljs-number">1</span>];
            while (i &lt; n - <span class="hljs-number">1</span> &amp;&amp; r &gt;= intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;
                r = <span class="hljs-symbol">Math</span>.max(r, intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);
                i++;
            &#125;
            list.add(new int[] &#123;l, r&#125;);
            i++;
        &#125;
        return list.toArray(new int[list.size()][<span class="hljs-number">2</span>]);
    &#125;
&#125;</code></pre>

<h2 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h2><pre><code class="hljs typescript">给定一个仅包含大小写字母和空格 <span class="hljs-string">&#x27; &#x27;</span> 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。

如果不存在最后一个单词，请返回 <span class="hljs-number">0</span> 。

说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。
输入: <span class="hljs-string">&quot;Hello World&quot;</span>
输出: <span class="hljs-number">5</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">lengthOfLastWord</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;
        <span class="hljs-built_in">String</span>[] strs = s.split(<span class="hljs-string">&quot; &quot;</span>);
        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> strs[strs.length-<span class="hljs-number">1</span>].length();
    &#125;
&#125;</code></pre>

<h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h2><pre><code class="hljs reasonml">给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 <span class="hljs-number">1</span> 和 <span class="hljs-number">0</span>。
输入: a = <span class="hljs-string">&quot;11&quot;</span>, b = <span class="hljs-string">&quot;1&quot;</span>
输出: <span class="hljs-string">&quot;100&quot;</span>

输入: a = <span class="hljs-string">&quot;1010&quot;</span>, b = <span class="hljs-string">&quot;1011&quot;</span>
输出: <span class="hljs-string">&quot;10101&quot;</span>
<span class="hljs-keyword">class</span> Solution &#123;
    public String add<span class="hljs-constructor">Binary(String <span class="hljs-params">a</span>, String <span class="hljs-params">b</span>)</span> &#123;
        <span class="hljs-built_in">int</span> i = a.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>, j = b.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;
        StringBuilder str = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;
        <span class="hljs-keyword">while</span> (carry<span class="hljs-operator"> == </span><span class="hljs-number">1</span><span class="hljs-operator"> || </span>i &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> || </span>j &gt;= <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>a.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>--)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;1&#x27;</span>) carry++;
            <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>b.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>--)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;1&#x27;</span>) carry++;
            <span class="hljs-comment">// 注意这里</span>
            str.append(carry % <span class="hljs-number">2</span>);
            carry /= <span class="hljs-number">2</span>;
        &#125;
        return str.reverse<span class="hljs-literal">()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;
    &#125;</code></pre>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><pre><code class="hljs typescript">给定一个二叉树，检查它是否是镜像对称的。

    <span class="hljs-number">1</span>
   / \
  <span class="hljs-number">2</span>   <span class="hljs-number">2</span>
 / \ / \
<span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSymmetric</span>(<span class="hljs-params">TreeNode root</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> isSymmetric(root.left, root.right);
    &#125;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSymmetric</span>(<span class="hljs-params">TreeNode t1, TreeNode t2</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span> &amp;&amp; t2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span> || t2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (t1.val != t2.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t1.right, t2.left);
    &#125;
&#125;</code></pre>

<h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. 验证回文串</h2><pre><code class="hljs smalltalk">给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。
输入: <span class="hljs-comment">&quot;A man, a plan, a canal: Panama&quot;</span>
输出: <span class="hljs-keyword">true</span>

输入: <span class="hljs-comment">&quot;race a car&quot;</span>
输出: <span class="hljs-keyword">false</span></code></pre>

<p>双指针</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public boolean is<span class="hljs-constructor">Palindrome(String <span class="hljs-params">s</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">&quot;&quot;</span>)) return <span class="hljs-literal">true</span>;
        s = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;
        <span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> sChar = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;
        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = sChar.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;
            <span class="hljs-keyword">if</span> (sChar<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span><span class="hljs-operator"> == </span>sChar<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span>) &#123;
                l++;
                r--;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!is<span class="hljs-constructor">NormalChar(<span class="hljs-params">sChar</span>[<span class="hljs-params">l</span>])</span>) &#123;
                l++;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!is<span class="hljs-constructor">NormalChar(<span class="hljs-params">sChar</span>[<span class="hljs-params">r</span>])</span>) &#123;
                r--;
            &#125; <span class="hljs-keyword">else</span> &#123;
                return <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        return <span class="hljs-literal">true</span>;
    &#125;
    <span class="hljs-keyword">private</span> boolean is<span class="hljs-constructor">NormalChar(<span class="hljs-params">char</span> <span class="hljs-params">a</span>)</span>&#123;
        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Character</span>.</span></span>is<span class="hljs-constructor">LowerCase(<span class="hljs-params">a</span>)</span><span class="hljs-operator"> || </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Character</span>.</span></span>is<span class="hljs-constructor">UpperCase(<span class="hljs-params">a</span>)</span><span class="hljs-operator"> || </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Character</span>.</span></span>is<span class="hljs-constructor">Digit(<span class="hljs-params">a</span>)</span>;
    &#125;
&#125;</code></pre>

<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><pre><code class="hljs reasonml">给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。
    <span class="hljs-number">3</span>
<span class="hljs-operator">   / </span>\
  <span class="hljs-number">9</span>  <span class="hljs-number">20</span>
<span class="hljs-operator">    /  </span>\
   <span class="hljs-number">15</span>   <span class="hljs-number">7</span>
<span class="hljs-keyword">class</span> Solution &#123;
    public <span class="hljs-built_in">int</span> max<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>null) return <span class="hljs-number">0</span>;
        <span class="hljs-built_in">int</span> l = max<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;
        <span class="hljs-built_in">int</span> r = max<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;
        return <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(l, r);
    &#125;
&#125;</code></pre>

<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h2><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1]</span>
<span class="hljs-section">输出: 1</span></code></pre>

<p>异或</p>
<pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> singleNumber(<span class="hljs-built_in">int</span>[] nums) &#123;
        <span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> num : nums) 
            ret = ret ^ num;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><pre><code class="hljs hsp">给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 <span class="hljs-keyword">pos</span> 来表示链表尾连接到链表中的位置（索引从 <span class="hljs-number">0</span> 开始）。 如果 <span class="hljs-keyword">pos</span> 是 <span class="hljs-number">-1</span>，则在该链表中没有环。

输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], <span class="hljs-keyword">pos</span> = <span class="hljs-number">1</span>
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。</code></pre>

<p>快慢指针</p>
<pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> hasCycle(ListNode head) &#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        ListNode l1 = head, l2 = head.<span class="hljs-keyword">next</span>;
        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span> &amp;&amp; l2.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">if</span> (l1 == l2) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
            l1 = l1.<span class="hljs-keyword">next</span>;
            l2 = l2.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;</code></pre>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><pre><code class="hljs prolog">给你一个由 <span class="hljs-string">&#x27;1&#x27;</span>（陆地）和 <span class="hljs-string">&#x27;0&#x27;</span>（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。
输入:
[
[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],
[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],
[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],
[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>]
]
输出: <span class="hljs-number">1</span>

输入:
[
[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],
[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],
[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],
[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>]
]
输出: <span class="hljs-number">3</span>
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</code></pre>

<p>dfs</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m, n;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] direaction = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (grid == <span class="hljs-keyword">null</span> || grid.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        m = grid.length;
        n = grid[<span class="hljs-number">0</span>].length;
        <span class="hljs-keyword">int</span> islandsNum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;
                <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;
                    dfs(grid, i, j);
                    islandsNum++;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> islandsNum;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;=n || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] d : direaction) &#123;
            dfs(grid, i + d[<span class="hljs-number">0</span>], j + d[<span class="hljs-number">1</span>]);
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><pre><code class="hljs makefile">在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
<span class="hljs-section">输入: [3,2,1,5,6,4] 和 k = 2</span>
<span class="hljs-section">输出: 5</span>

<span class="hljs-section">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span>
<span class="hljs-section">输出: 4</span></code></pre>

<p>快排</p>
<pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> findKthLargest(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k) &#123;
        k = nums.length - k;
        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, h = nums.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (l &lt; h) &#123;
            <span class="hljs-built_in">int</span> j = partition(nums, l , h);
            <span class="hljs-keyword">if</span> (j == k) &#123;
                <span class="hljs-keyword">break</span>;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; k) &#123;
                l = j + <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                h = j - <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> nums[k];
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> partition(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r) &#123;
        <span class="hljs-built_in">int</span> pivot = l;
        <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = pivot + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-keyword">index</span>; i &lt;= r; i++) &#123;
            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;
                swap(arr, i, <span class="hljs-keyword">index</span>++);
            &#125;
        &#125;
        swap(arr, pivot, <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> swap(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;
        <span class="hljs-built_in">int</span> t = arr[i];
        arr[i] = arr[j];
        arr[j] = t; 
    &#125;
&#125;</code></pre>

<h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h2><pre><code class="hljs arduino">给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 <span class="hljs-string">&quot;Aa&quot;</span> 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 <span class="hljs-number">1010</span>。
输入:
<span class="hljs-string">&quot;abccccdd&quot;</span>

输出:
<span class="hljs-number">7</span>

解释:
我们可以构造的最长的回文串是<span class="hljs-string">&quot;dccaccd&quot;</span>, 它的长度是 <span class="hljs-number">7</span>。
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;
        <span class="hljs-keyword">int</span>[] cnts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;
            cnts[c]++;
        &#125;
        <span class="hljs-keyword">int</span> palindrome = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 偶数个字母加起来，就算不是偶数个，也拿偶数个，比如5拿4</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> cnt : cnts) &#123;
            palindrome += (cnt / <span class="hljs-number">2</span>) * <span class="hljs-number">2</span>;
        &#125;
        <span class="hljs-comment">// 小于，则说明有个字母或多个字母是奇数个，拿一放中间</span>
        <span class="hljs-keyword">if</span> (palindrome &lt; s.length()) &#123;
            palindrome++;
        &#125;
        <span class="hljs-keyword">return</span> palindrome;
    &#125;
&#125;</code></pre>

<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h2><pre><code class="hljs stylus">给定一个带有头结点 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。
输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
输出：此列表中的结点 <span class="hljs-number">3</span> (序列化形式：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])
返回的结点值为 <span class="hljs-number">3</span> 。 (测评系统对该结点序列化表述是 [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans<span class="hljs-selector-class">.val</span> = <span class="hljs-number">3</span>, ans<span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.val</span> = <span class="hljs-number">4</span>, ans<span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.val</span> = <span class="hljs-number">5</span>, 以及 ans<span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.next</span> = NULL.

输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
输出：此列表中的结点 <span class="hljs-number">4</span> (序列化形式：[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])
由于该列表有两个中间结点，值分别为 <span class="hljs-number">3</span> 和 <span class="hljs-number">4</span>，我们返回第二个结点。</code></pre>

<p>快慢指针</p>
<pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> ListNode middleNode(ListNode head) &#123;
        ListNode p = head, q = head;
        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">null</span> &amp;&amp; q.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;
            q = q.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;
            p = p.<span class="hljs-keyword">next</span>;
        &#125;
        <span class="hljs-keyword">return</span> p;
    &#125;
&#125;</code></pre>

<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><pre><code class="hljs makefile">给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
<span class="hljs-section">输入: [1,2,0]</span>
<span class="hljs-section">输出: 3</span>
<span class="hljs-section">输入: [3,4,-1,1]</span>
<span class="hljs-section">输出: 2</span>
<span class="hljs-section">输入: [7,8,9,11,12]</span>
<span class="hljs-section">输出: 1</span></code></pre>

<p>怎么会怎么来，排序，接着遍历。</p>
<pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> firstMissingPositive(<span class="hljs-built_in">int</span>[] nums) &#123;
        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">1</span>;
        Arrays.sort(nums);
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            <span class="hljs-keyword">if</span> (nums[i] &gt; ans) <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">if</span> (nums[i] == ans) ans++;
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;</code></pre>

<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h2><pre><code class="hljs clean">html
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？
输入: m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span>
输出: <span class="hljs-number">3</span>
解释:
从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。
<span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下
<span class="hljs-number">2.</span> 向右 -&gt; 向下 -&gt; 向右
<span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向右</code></pre>

<p>dp</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
        Arrays.<span class="hljs-built_in">fill</span>(dp, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;
                dp[j] += dp[j - <span class="hljs-number">1</span>];
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];
    &#125;
&#125;</code></pre>

<h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h2><pre><code class="hljs smalltalk">输入: <span class="hljs-comment">&quot;the sky is blue&quot;</span>
输出: <span class="hljs-comment">&quot;blue is sky the&quot;</span>

输入: <span class="hljs-comment">&quot;  hello world!  &quot;</span>
输出: <span class="hljs-comment">&quot;world! hello&quot;</span>
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

输入: <span class="hljs-comment">&quot;a good   example&quot;</span>
输出: <span class="hljs-comment">&quot;example good a&quot;</span>
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre>

<p>用了api</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public String reverse<span class="hljs-constructor">Words(String <span class="hljs-params">s</span>)</span> &#123;
        String<span class="hljs-literal">[]</span> words = s.trim<span class="hljs-literal">()</span>.split(<span class="hljs-string">&quot; +&quot;</span>);
        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>reverse(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">words</span>)</span>);
        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>join(<span class="hljs-string">&quot; &quot;</span>, words);
    &#125;
&#125;</code></pre>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h2><pre><code class="hljs stylus">设计一个支持 push ，pop ，<span class="hljs-attribute">top</span> 操作，并能在常数时间内检索到最小元素的栈。

<span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">(x)</span></span> —— 将元素 x 推入栈中。
<span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span> —— 删除栈顶的元素。
<span class="hljs-function"><span class="hljs-title">top</span><span class="hljs-params">()</span></span> —— 获取栈顶元素。
<span class="hljs-function"><span class="hljs-title">getMin</span><span class="hljs-params">()</span></span> —— 检索栈中的最小元素。</code></pre>

<p>辅助栈</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span>
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; dataStack;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; minStack;
    <span class="hljs-comment">/** initialize your data structure here. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;
        dataStack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        minStack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;
        dataStack.push(x);
        minStack.push(minStack.isEmpty() ? x : Math.<span class="hljs-built_in">min</span>(minStack.<span class="hljs-built_in">peek</span>(), x));
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        dataStack.pop();
        minStack.pop();
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> dataStack.<span class="hljs-built_in">peek</span>();
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>;
    &#125;
&#125;</code></pre>

<h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h2><pre><code class="hljs dns">给定一个无序的整数数组，找到其中最长上升子序列的长度。
输入: [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]
输出: <span class="hljs-number">4</span> 
解释: 最长的上升子序列是 [<span class="hljs-number">2,3,7,101</span>]，它的长度是 <span class="hljs-number">4</span>。</code></pre>

<p>dp</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLIS(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (nums.length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;
        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">nums</span>.<span class="hljs-identifier">length</span>]</span>;
        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>fill(dp, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;
                <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &gt; nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>) &#123;
                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, dp<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 关键这里，</span>
                &#125;
            &#125;
        &#125;
        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>stream(dp).max<span class="hljs-literal">()</span>.<span class="hljs-keyword">or</span><span class="hljs-constructor">Else(0)</span>;
    &#125;
&#125;</code></pre>

<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><pre><code class="hljs makefile">给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
<span class="hljs-section">输入: coins = [1, 2, 5], amount = 11</span>
<span class="hljs-section">输出: 3 </span>
<span class="hljs-section">解释: 11 = 5 + 5 + 1</span>

<span class="hljs-section">输入: coins = [2], amount = 3</span>
<span class="hljs-section">输出: -1</span></code></pre>

<p>完全背包</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = coin; i &lt;= amount; i++) &#123; <span class="hljs-comment">//将逆序遍历改为正序遍历</span>
                <span class="hljs-keyword">if</span> (i == coin) &#123;
                    dp[i] = <span class="hljs-number">1</span>;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">0</span> &amp;&amp; dp[i - coin] != <span class="hljs-number">0</span>) &#123;
                    dp[i] = dp[i - coin] + <span class="hljs-number">1</span>;

                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i - coin] != <span class="hljs-number">0</span>) &#123;
                    dp[i] = Math.<span class="hljs-built_in">min</span>(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : dp[amount];
    &#125;

&#125;</code></pre>

<h2 id="1013-将数组分成和相等的三个部分"><a href="#1013-将数组分成和相等的三个部分" class="headerlink" title="1013. 将数组分成和相等的三个部分"></a>1013. 将数组分成和相等的三个部分</h2><pre><code class="hljs axapta">给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 <span class="hljs-literal">true</span>，否则返回 <span class="hljs-literal">false</span>。

形式上，如果可以找出索引 i+<span class="hljs-number">1</span> &lt; j 且满足 A[<span class="hljs-number">0</span>] + A[<span class="hljs-number">1</span>] + ... + A[i] == A[i+<span class="hljs-number">1</span>] + A[i+<span class="hljs-number">2</span>] + ... + A[j<span class="hljs-number">-1</span>] == A[j] + A[j<span class="hljs-number">-1</span>] + ... + A[A.length - <span class="hljs-number">1</span>] 就可以将数组三等分。
输入：[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]
输出：<span class="hljs-literal">true</span>
解释：<span class="hljs-number">0</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">-6</span> + <span class="hljs-number">6</span> - <span class="hljs-number">7</span> + <span class="hljs-number">9</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span> + <span class="hljs-number">0</span> + <span class="hljs-number">1</span>

输入：[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]
输出：<span class="hljs-literal">false</span>

输入：[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-9</span>,<span class="hljs-number">4</span>]
输出：<span class="hljs-literal">true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> canThreePartsEqualSum(<span class="hljs-built_in">int</span>[] A) &#123;
        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 遍历数组求总和</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> num : A) &#123;
            <span class="hljs-keyword">sum</span> += num;
        &#125;
        <span class="hljs-comment">// 数组A的和如果不能被3整除直接返回false</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-comment">// 遍历数组累加，每累加到目标值cnt加1，表示又找到1段</span>
        <span class="hljs-keyword">sum</span> /= <span class="hljs-number">3</span>;
        <span class="hljs-built_in">int</span> curSum = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;
            curSum += A[i];
            <span class="hljs-keyword">if</span> (curSum == <span class="hljs-keyword">sum</span>) &#123;
                cnt++;
                curSum = <span class="hljs-number">0</span>;
            &#125;
        &#125;
        <span class="hljs-comment">// 最后判断是否找到了3段（注意如果目标值是0的话可以大于3段）</span>
        <span class="hljs-keyword">return</span> cnt == <span class="hljs-number">3</span> || (cnt &gt; <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-keyword">sum</span> == <span class="hljs-number">0</span>);
    &#125;
&#125;</code></pre>

<h2 id="1160-拼写单词"><a href="#1160-拼写单词" class="headerlink" title="1160. 拼写单词"></a>1160. 拼写单词</h2><pre><code class="hljs livecodeserver">给你一份『词汇表』（字符串数组） <span class="hljs-keyword">words</span> 和一张『字母表』（字符串） <span class="hljs-keyword">chars</span>。

假如你可以用 <span class="hljs-keyword">chars</span> 中的『字母』（字符）拼写出 <span class="hljs-keyword">words</span> 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。

注意：每次拼写（指拼写词汇表中的一个单词）时，<span class="hljs-keyword">chars</span> 中的每个字母都只能用一次。

返回词汇表 <span class="hljs-keyword">words</span> 中你掌握的所有单词的 长度之和。
输入：<span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;bt&quot;</span>,<span class="hljs-string">&quot;hat&quot;</span>,<span class="hljs-string">&quot;tree&quot;</span>], <span class="hljs-keyword">chars</span> = <span class="hljs-string">&quot;atach&quot;</span>
输出：<span class="hljs-number">6</span>
解释： 
可以形成字符串 <span class="hljs-string">&quot;cat&quot;</span> 和 <span class="hljs-string">&quot;hat&quot;</span>，所以答案是 <span class="hljs-number">3</span> + <span class="hljs-number">3</span> = <span class="hljs-number">6</span>。

输入：<span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;leetcode&quot;</span>], <span class="hljs-keyword">chars</span> = <span class="hljs-string">&quot;welldonehoneyr&quot;</span>
输出：<span class="hljs-number">10</span>
解释：
可以形成字符串 <span class="hljs-string">&quot;hello&quot;</span> 和 <span class="hljs-string">&quot;world&quot;</span>，所以答案是 <span class="hljs-number">5</span> + <span class="hljs-number">5</span> = <span class="hljs-number">10</span>。</code></pre>

<p>类似于map的数组即可。双map</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countCharacters</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] words, <span class="hljs-keyword">String</span> chars)</span> </span>&#123;
        <span class="hljs-keyword">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : chars.toCharArray()) &#123;
            hash[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;
        &#125;
        <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];
        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span> : words) &#123;
            Arrays.<span class="hljs-built_in">fill</span>(tmp, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : <span class="hljs-keyword">word</span>.toCharArray()) &#123;
                tmp[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;
                <span class="hljs-keyword">if</span> (tmp[ch - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; hash[ch - <span class="hljs-string">&#x27;a&#x27;</span>]) 
                    flag = <span class="hljs-literal">false</span>;
            &#125;
            len += flag ? <span class="hljs-keyword">word</span>.length() : <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> len;
    &#125;
&#125;</code></pre>

<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><pre><code class="hljs arduino">给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。
输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
输出:
[
  [<span class="hljs-number">3</span>],
  [<span class="hljs-number">1</span>],
  [<span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],
  [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],
  [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],
  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],
  []
]
class Solution &#123;
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;
        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        List&lt;Integer&gt; tempSubset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">size</span> &lt;= nums.length; <span class="hljs-built_in">size</span>++) &#123;
            backtracking(<span class="hljs-number">0</span>, tempSubset, subsets, <span class="hljs-built_in">size</span>, nums); <span class="hljs-comment">// 不同的子集大小</span>
        &#125;
        <span class="hljs-keyword">return</span> subsets;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets,</span></span>
<span class="hljs-function"><span class="hljs-params">                            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;

        <span class="hljs-keyword">if</span> (tempSubset.<span class="hljs-built_in">size</span>() == <span class="hljs-built_in">size</span>) &#123;
            subsets.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tempSubset));
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length; i++) &#123;
            tempSubset.add(nums[i]);
            backtracking(i + <span class="hljs-number">1</span>, tempSubset, subsets, <span class="hljs-built_in">size</span>, nums);
            tempSubset.<span class="hljs-built_in">remove</span>(tempSubset.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);
        &#125;
    &#125;

&#125;</code></pre>

<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h2><pre><code class="hljs xquery">给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>
输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>

输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">3</span>
输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>
class Solution &#123;
    public ListNode deleteDuplicates(ListNode<span class="hljs-built_in"> head</span>) &#123;
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(head</span> == null ||<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> == null) <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;
       <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = deleteDuplicates<span class="hljs-built_in">(head</span>.<span class="hljs-keyword">next</span>);
        <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>.val ==<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>.val ?<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> :<span class="hljs-built_in"> head</span>;
    &#125;
&#125;</code></pre>

<h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><pre><code class="hljs css">给定一个二叉树，返回它的中序 遍历。
输入: <span class="hljs-selector-attr">[1,null,2,3]</span>
   1
    \
     2
    /
   3

输出: <span class="hljs-selector-attr">[1,3,2]</span></code></pre>

<p>栈</p>
<pre><code class="hljs lasso">class Solution &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;
        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; ret = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">if</span> (root == <span class="hljs-built_in">null</span>) <span class="hljs-keyword">return</span> ret;
        <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();
        TreeNode cur = root;
        <span class="hljs-keyword">while</span> (cur != <span class="hljs-built_in">null</span> || !<span class="hljs-built_in">stack</span>.isEmpty()) &#123;
            <span class="hljs-keyword">while</span> (cur != <span class="hljs-built_in">null</span>) &#123;
                <span class="hljs-built_in">stack</span>.push(cur);
                cur = cur.left; <span class="hljs-comment">// 遍历到做左</span>
            &#125;
            TreeNode node = <span class="hljs-built_in">stack</span>.pop(); <span class="hljs-comment">// 从下往上弹</span>
            ret.add(node.val);
            cur = node.right; <span class="hljs-comment">// 弹完遍历右</span>
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre>

<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h2><pre><code class="hljs kotlin">给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
输入:       <span class="hljs-number">1</span>         <span class="hljs-number">1</span>
          / \       / \
         <span class="hljs-number">2</span>   <span class="hljs-number">3</span>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span>

        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],   [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]

输出: <span class="hljs-literal">true</span>

输入:      <span class="hljs-number">1</span>          <span class="hljs-number">1</span>
          /           \
         <span class="hljs-number">2</span>             <span class="hljs-number">2</span>

        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],     [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]

输出: <span class="hljs-literal">false</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> boolean isSameTree(TreeNode p, TreeNode q) &#123;
        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span>(p.<span class="hljs-keyword">val</span> != q.<span class="hljs-keyword">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
    &#125;
&#125;</code></pre>

<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h2><pre><code class="hljs csharp">输入: <span class="hljs-number">5</span>
输出:
[<span class="hljs-meta"></span>
<span class="hljs-meta">     [1</span>],
    [<span class="hljs-meta">1,1</span>],
   [<span class="hljs-meta">1,2,1</span>],
  [<span class="hljs-meta">1,3,3,1</span>],
 [<span class="hljs-meta">1,4,6,4,1</span>]
]
<span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="hljs-built_in">int</span> numRows) &#123;
        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;
            List&lt;Integer&gt; curRow = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;
                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || j == i) &#123;
                    curRow.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);
                    <span class="hljs-keyword">continue</span>;
                &#125;
                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == <span class="hljs-number">1</span>) &#123;
                    <span class="hljs-keyword">continue</span>;
                &#125;
                List&lt;Integer&gt; preRow = ans.<span class="hljs-keyword">get</span>(i - <span class="hljs-number">1</span>);
                <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = preRow.<span class="hljs-keyword">get</span>(j - <span class="hljs-number">1</span>) + preRow.<span class="hljs-keyword">get</span>(j);
                curRow.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">value</span>);
            &#125;
            ans.<span class="hljs-keyword">add</span>(curRow);
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;</code></pre>

<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>双指针，A走完，走B，B走完，走A</p>
<pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> ListNode <span class="hljs-function"><span class="hljs-title">getIntersectionNode</span>(<span class="hljs-params">ListNode headA, ListNode headB</span>)</span> &#123;
        ListNode l1 = headA, l2 = headB;
        <span class="hljs-keyword">while</span> (l1 != l2) &#123;
            l1 = (l1 == <span class="hljs-literal">null</span>) ? headB : l1.next;
            l2 = (l2 == <span class="hljs-literal">null</span>) ? headA : l2.next;
        &#125;
        <span class="hljs-keyword">return</span> l1;
    &#125;
&#125;</code></pre>

<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><pre><code class="hljs lasso">编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 <span class="hljs-number">1</span>，也可能是 无限循环 但始终变不到 <span class="hljs-number">1</span>。如果 可以变为  <span class="hljs-number">1</span>，那么这个数就是快乐数。

如果 n 是快乐数就返回 <span class="hljs-literal">True</span> ；不是，则返回 <span class="hljs-literal">False</span> 。
输入：<span class="hljs-number">19</span>
输出：<span class="hljs-literal">true</span>
解释：
<span class="hljs-number">12</span> + <span class="hljs-number">92</span> = <span class="hljs-number">82</span>
<span class="hljs-number">82</span> + <span class="hljs-number">22</span> = <span class="hljs-number">68</span>
<span class="hljs-number">62</span> + <span class="hljs-number">82</span> = <span class="hljs-number">100</span>
<span class="hljs-number">12</span> + <span class="hljs-number">02</span> + <span class="hljs-number">02</span> = <span class="hljs-number">1</span>
class Solution &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isHappy(int n) &#123;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        HashSet&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">set</span> = <span class="hljs-literal">new</span> HashSet&lt;&gt;();
        <span class="hljs-keyword">while</span>(<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>) &#123;
            int <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-keyword">sum</span> += (n % <span class="hljs-number">10</span>) *(n % <span class="hljs-number">10</span>);
                n /= <span class="hljs-number">10</span>;
            &#125;
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">set</span>.add(<span class="hljs-keyword">sum</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            n = <span class="hljs-keyword">sum</span>;
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>请判断一个链表是否为回文链表。</p>
<pre><code class="hljs axapta">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>
输出: <span class="hljs-literal">false</span>
输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>
输出: <span class="hljs-literal">true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isPalindrome(ListNode head) &#123;
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-comment">// 找中点</span>
        ListNode slow = head, fast = head.<span class="hljs-keyword">next</span>;
        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;
            slow = slow.<span class="hljs-keyword">next</span>;
            fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;
        &#125;
        <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>) slow = slow.<span class="hljs-keyword">next</span>;
        <span class="hljs-comment">// cut</span>
        cut(head, slow);
        <span class="hljs-comment">// 比较</span>
        <span class="hljs-keyword">return</span> isEqual(head, <span class="hljs-keyword">reverse</span>(slow));
        
    &#125;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> cut (ListNode head, ListNode cutNode) &#123;
        ListNode node = head;
        <span class="hljs-keyword">while</span>(node.<span class="hljs-keyword">next</span> != cutNode) &#123;
            node = node.<span class="hljs-keyword">next</span>;
        &#125;
        node.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;
    &#125;
    
    <span class="hljs-keyword">public</span> ListNode <span class="hljs-keyword">reverse</span>(ListNode head) &#123;
        ListNode pre = <span class="hljs-literal">null</span>;
        ListNode cur = head;
        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;
            ListNode nextNode = cur.<span class="hljs-keyword">next</span>;
            cur.<span class="hljs-keyword">next</span> = pre;
            pre = cur;
            cur = nextNode;
        &#125;
        <span class="hljs-keyword">return</span> pre;
    &#125;
    
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isEqual(ListNode l1, ListNode l2) &#123;
        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">if</span>(l1.val != l2.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            l1 = l1.<span class="hljs-keyword">next</span>;
            l2 = l2.<span class="hljs-keyword">next</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;</code></pre>

<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><pre><code class="hljs css">编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <span class="hljs-selector-tag">char</span><span class="hljs-selector-attr">[]</span> 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 <span class="hljs-selector-tag">O</span>(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 <span class="hljs-selector-tag">ASCII</span> 码表中的可打印字符。
输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]</span>
输出：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]</span>
输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]</span>
输出：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>]</span></code></pre>

<p>双指针</p>
<pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s)</span> </span>&#123;
        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = s.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(p1 &lt; p2 )&#123;
            swap(s, p1++, p2--);
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        <span class="hljs-keyword">char</span> temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    &#125;
&#125;</code></pre>

<h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h2><pre><code class="hljs angelscript">给定一个包含了一些 <span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 <span class="hljs-number">1</span> (代表土地) 构成的组合，这里的「相邻」要求两个 <span class="hljs-number">1</span> 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 <span class="hljs-number">0</span>（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 <span class="hljs-number">0</span> 。)
<span class="hljs-string">[[0,0,1,0,0,0,0,1,0,0,0,0,0]</span>,
<span class="hljs-string"> [0,0,0,0,0,0,0,1,1,1,0,0,0]</span>,
<span class="hljs-string"> [0,1,1,0,1,0,0,0,0,0,0,0,0]</span>,
<span class="hljs-string"> [0,1,0,0,1,1,0,0,1,0,1,0,0]</span>,
<span class="hljs-string"> [0,1,0,0,1,1,0,0,1,1,1,0,0]</span>,
<span class="hljs-string"> [0,0,0,0,0,0,0,0,0,0,1,0,0]</span>,
<span class="hljs-string"> [0,0,0,0,0,0,0,1,1,1,0,0,0]</span>,
<span class="hljs-string"> [0,0,0,0,0,0,0,1,1,0,0,0,0]</span>]
 对于上面这个给定矩阵应返回 <span class="hljs-number">6</span>。注意答案不应该是 <span class="hljs-number">11</span> ，因为岛屿只能包含水平或垂直的四个方向的 <span class="hljs-number">1</span> 。
<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m, n;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[][] direaction = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxAreaOfIsland(<span class="hljs-built_in">int</span>[][] grid) &#123;
        <span class="hljs-keyword">if</span>(grid == <span class="hljs-literal">null</span> || grid.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        m = grid.length;
        n = grid[<span class="hljs-number">0</span>].length;
        <span class="hljs-built_in">int</span> maxArea = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;
                maxArea = Math.max(maxArea, dfs(grid, i, j));
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> maxArea;
    &#125;   
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> dfs(<span class="hljs-built_in">int</span>[][] grid, <span class="hljs-built_in">int</span> r, <span class="hljs-built_in">int</span> c) &#123;
        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> || r &gt;= m || c &lt; <span class="hljs-number">0</span> || c &gt;= n || grid[r][c] == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        grid[r][c] = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">int</span> area = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span>[] d : direaction) &#123;
            area += dfs(grid, r + d[<span class="hljs-number">0</span>], c + d[<span class="hljs-number">1</span>]);
        &#125;
        <span class="hljs-keyword">return</span> area;
    &#125;
&#125;</code></pre>

<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><pre><code class="hljs inform7">请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = <span class="hljs-comment">[73, 74, 75, 71, 69, 72, 76, 73]</span>，你的输出应该是 <span class="hljs-comment">[1, 1, 4, 2, 1, 1, 0, 0]</span>。

提示：气温 列表长度的范围是 <span class="hljs-comment">[1, 30000]</span>。每个气温的值的均为华氏度，都是在 <span class="hljs-comment">[30, 100]</span> 范围内的整数。</code></pre>

<p>递减栈</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;
        Stack&lt;Integer&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T.length; i++) &#123;
            <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stack</span>.isEmpty() &amp;&amp; T[i] &gt; T[<span class="hljs-built_in">stack</span>.<span class="hljs-built_in">peek</span>()]) &#123;
                <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">stack</span>.pop();
                res[t] = i - t;
            &#125;
            <span class="hljs-built_in">stack</span>.push(i);
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;</code></pre>

<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><pre><code class="hljs fortran">给定一个无重复元素的数组 candidates 和一个目标数 <span class="hljs-keyword">target</span> ，找出 candidates 中所有可以使数字和为 <span class="hljs-keyword">target</span> 的组合。

candidates 中的数字可以无限制重复被选取。
输入: candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">7</span>,
所求解集为:
[
  [<span class="hljs-number">7</span>],
  [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
]

输入: candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">7</span>,
所求解集为:
[
  [<span class="hljs-number">7</span>],
  [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
]
<span class="hljs-keyword">class</span> Solution &#123;
    <span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; combinationSum(<span class="hljs-built_in">int</span>[] candidates, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;
        List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; combinations = new ArrayList&lt;&gt;();
        backtracking(new ArrayList&lt;&gt;(), combinations, <span class="hljs-number">0</span>, <span class="hljs-keyword">target</span>, candidates);
        <span class="hljs-keyword">return</span> combinations;
    &#125;

    <span class="hljs-keyword">private</span> void backtracking(List&lt;<span class="hljs-keyword">Integer</span>&gt; tempCombination, List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; combinations,
                            <span class="hljs-built_in">int</span> start, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>, <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span>[] candidates) &#123;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == <span class="hljs-number">0</span>) &#123;
            combinations<span class="hljs-number">.</span>add(new ArrayList&lt;&gt;(tempCombination));
            <span class="hljs-keyword">return</span>;
        &#125;
        for (<span class="hljs-built_in">int</span> i = start; i &lt; candidates<span class="hljs-number">.</span>length; i++) &#123;
            <span class="hljs-keyword">if</span> (candidates[i] &lt;= <span class="hljs-keyword">target</span>) &#123;
                tempCombination<span class="hljs-number">.</span>add(candidates[i]);
                backtracking(tempCombination, combinations, i, <span class="hljs-keyword">target</span> - candidates[i], candidates);
                tempCombination<span class="hljs-number">.</span>remove(tempCombination<span class="hljs-number">.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<pre><code class="hljs accesslog">​```html
输入: <span class="hljs-string">[2,0,2,1,1,0]</span>
输出: <span class="hljs-string">[0,0,1,1,2,2]</span></code></pre>

<p>zero和two作为双指针</p>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">int</span> zero = <span class="hljs-number">-1</span>, one = <span class="hljs-number">0</span>, two = nums.length;
        <span class="hljs-keyword">while</span> (one &lt; two) &#123;
            <span class="hljs-keyword">if</span> (nums[one] == <span class="hljs-number">0</span>) &#123;
                swap(nums, ++zero, one++);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[one] == <span class="hljs-number">2</span>)&#123;
                swap(nums, --two, one);
            &#125; <span class="hljs-keyword">else</span> &#123;
                ++one;
            &#125;
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        <span class="hljs-keyword">int</span> t = a[i];
        a[i] = a[j];
        a[j] = t;
    &#125;
&#125;</code></pre>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><pre><code class="hljs reasonml">给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

    <span class="hljs-number">3</span>
<span class="hljs-operator">   / </span>\
  <span class="hljs-number">9</span>  <span class="hljs-number">20</span>
<span class="hljs-operator">    /  </span>\
   <span class="hljs-number">15</span>   <span class="hljs-number">7</span>

<span class="hljs-number">2</span>
<span class="hljs-keyword">class</span> Solution &#123;
    public <span class="hljs-built_in">int</span> min<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>null) return <span class="hljs-number">0</span>;
        <span class="hljs-built_in">int</span> l = min<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;
        <span class="hljs-built_in">int</span> r = min<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;
        <span class="hljs-keyword">if</span>(l<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>r<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return l + r + <span class="hljs-number">1</span>;
        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(l, r) + <span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a>120. 三角形最小路径和</h2><pre><code class="hljs inform7">给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。
<span class="hljs-comment">[</span>
<span class="hljs-comment">     <span class="hljs-comment">[2]</span>,</span>
<span class="hljs-comment">    <span class="hljs-comment">[3,4]</span>,</span>
<span class="hljs-comment">   <span class="hljs-comment">[6,5,7]</span>,</span>
<span class="hljs-comment">  <span class="hljs-comment">[4,1,8,3]</span></span>
<span class="hljs-comment">]</span></code></pre>

<p>dp</p>
<pre><code class="hljs processing">class Solution &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> minimumTotal(List&lt;List&lt;Integer&gt;&gt; <span class="hljs-built_in">triangle</span>) &#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-built_in">int</span> row = <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[row][<span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(row - <span class="hljs-number">1</span>).<span class="hljs-built_in">size</span>()];
        <span class="hljs-comment">// 初始化</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j =<span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(i).<span class="hljs-built_in">size</span>(); j++) &#123;
                dp[i][j] = <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(i).<span class="hljs-built_in">get</span>(j);
            &#125;
        &#125;
        <span class="hljs-comment">// 从下往上， 初始化最后一行</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(row - <span class="hljs-number">1</span>).<span class="hljs-built_in">size</span>(); i++) &#123;
            dp[row - <span class="hljs-number">1</span>][i] = <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(row - <span class="hljs-number">1</span>).<span class="hljs-built_in">get</span>(i);
        &#125;
        <span class="hljs-comment">// 动态规划</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = row - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(i).<span class="hljs-built_in">size</span>(); j++) &#123;
                dp[i][j] = Math.<span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) + <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(i).<span class="hljs-built_in">get</span>(j);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
    &#125;
&#125;</code></pre>

<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h2><pre><code class="hljs cpp">输入: [<span class="hljs-number">1</span>,null,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]  
   <span class="hljs-number">1</span>
    \
     <span class="hljs-number">2</span>
    /
   <span class="hljs-number">3</span> 

输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        Stack&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        <span class="hljs-built_in">stack</span>.push(root);
        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stack</span>.isEmpty()) &#123;
            TreeNode node = <span class="hljs-built_in">stack</span>.pop();
            <span class="hljs-keyword">if</span> (node == null) <span class="hljs-keyword">continue</span>;
            ret.add(node.val);
            <span class="hljs-built_in">stack</span>.push(node.right);
            <span class="hljs-built_in">stack</span>.push(node.left);
        &#125;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;</code></pre>

<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h2><pre><code class="hljs stata">输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
<span class="hljs-keyword">class</span> Solution &#123;
    public <span class="hljs-keyword">List</span>&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
        <span class="hljs-keyword">List</span>&lt;Integer&gt; <span class="hljs-keyword">ret</span> = new ArrayList&lt;&gt;();
        <span class="hljs-keyword">Stack</span>&lt;TreeNode&gt; <span class="hljs-keyword">stack</span> = new <span class="hljs-keyword">Stack</span>&lt;&gt;();
        <span class="hljs-keyword">stack</span>.push(root);
        <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">stack</span>.isEmpty()) &#123;
            TreeNode node = <span class="hljs-keyword">stack</span>.pop();
            <span class="hljs-keyword">if</span> (node == null) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">ret</span>.add(node.val);
            <span class="hljs-keyword">stack</span>.push(node.left);
            <span class="hljs-keyword">stack</span>.push(node.right);
        &#125;
        Collections.<span class="hljs-built_in">reverse</span>(<span class="hljs-keyword">ret</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;
    &#125;
&#125;</code></pre>

<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><pre><code class="hljs makefile">给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
<span class="hljs-section">输入: [2,3,-2,4]</span>
<span class="hljs-section">输出: 6</span>
<span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span>

<span class="hljs-section">输入: [-2,0,-1]</span>
<span class="hljs-section">输出: 0</span>
<span class="hljs-section">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span></code></pre>

<p>dp</p>
<pre><code class="hljs inform7">class Solution &#123;
    public int maxProduct(int<span class="hljs-comment">[]</span> nums) &#123;
        if (nums.length == 0) return 0;
        int ans = Integer.MIN_VALUE;
        int<span class="hljs-comment">[]</span> dpMax = new int<span class="hljs-comment">[nums.length + 1]</span>;
        int<span class="hljs-comment">[]</span> dpMin = new int<span class="hljs-comment">[nums.length + 1]</span>;
        dpMax<span class="hljs-comment">[0]</span> = 1;
        dpMin<span class="hljs-comment">[0]</span> = 1;
        for (int i = 1; i &lt;= nums.length; i++) &#123;
            if (nums<span class="hljs-comment">[i-1]</span> &lt; 0) &#123;
                int temp = dpMax<span class="hljs-comment">[i-1]</span>;
                dpMax<span class="hljs-comment">[i-1]</span> = dpMin<span class="hljs-comment">[i-1]</span>;
                dpMin<span class="hljs-comment">[i-1]</span> = temp;
            &#125;
            dpMax<span class="hljs-comment">[i]</span> = Math.max(dpMax<span class="hljs-comment">[i-1]</span>*nums<span class="hljs-comment">[i-1]</span>, nums<span class="hljs-comment">[i-1]</span>);
            dpMin<span class="hljs-comment">[i]</span> = Math.min(dpMin<span class="hljs-comment">[i-1]</span>*nums<span class="hljs-comment">[i-1]</span>, nums<span class="hljs-comment">[i-1]</span>);
            ans = Math.max(ans, dpMax<span class="hljs-comment">[i]</span>);
        &#125;
        return ans;
    &#125;
&#125;</code></pre>

<h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h2><pre><code class="hljs axapta">给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
输入: numbers = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], target = <span class="hljs-number">9</span>
输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
解释: <span class="hljs-number">2</span> 与 <span class="hljs-number">7</span> 之和等于目标数 <span class="hljs-number">9</span> 。因此 index1 = <span class="hljs-number">1</span>, index2 = <span class="hljs-number">2</span> 。
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] twoSum(<span class="hljs-built_in">int</span>[] numbers, <span class="hljs-built_in">int</span> target) &#123;
        <span class="hljs-keyword">if</span> (numbers == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-comment">// 双指针</span>
        <span class="hljs-built_in">int</span> p1 = <span class="hljs-number">0</span>, p2 = numbers.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;
            <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = numbers[p1] + numbers[p2];
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> == target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;p1+<span class="hljs-number">1</span>, p2+<span class="hljs-number">1</span>&#125;;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> &lt; target) p1++;
            <span class="hljs-keyword">else</span> p2--;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    &#125;
&#125;</code></pre>

<h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<pre><code class="hljs pgsql">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] 和 k = <span class="hljs-number">3</span>
输出: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
解释:
向右旋转 <span class="hljs-number">1</span> 步: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
向右旋转 <span class="hljs-number">2</span> 步: [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
向右旋转 <span class="hljs-number">3</span> 步: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]

输入: [<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>,<span class="hljs-number">3</span>,<span class="hljs-number">99</span>] 和 k = <span class="hljs-number">2</span>
输出: [<span class="hljs-number">3</span>,<span class="hljs-number">99</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>]
解释: 
向右旋转 <span class="hljs-number">1</span> 步: [<span class="hljs-number">99</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>,<span class="hljs-number">3</span>]
向右旋转 <span class="hljs-number">2</span> 步: [<span class="hljs-number">3</span>,<span class="hljs-number">99</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>]
<span class="hljs-keyword">class</span> Solution &#123;
    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> rotate(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;
        <span class="hljs-type">int</span> n = nums.length;
        k %= n;
        reverse(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);
        reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);
        reverse(nums, k, n - <span class="hljs-number">1</span>);
    &#125;
    private <span class="hljs-type">void</span> reverse(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>) &#123;
        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;
            <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[<span class="hljs-keyword">start</span>];
            nums[<span class="hljs-keyword">start</span>++] = nums[<span class="hljs-keyword">end</span>];
            nums[<span class="hljs-keyword">end</span><span class="hljs-comment">--] = temp;</span>
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><pre><code class="hljs livescript">     <span class="hljs-number">4</span>
   /   <span class="hljs-string">\</span>
  <span class="hljs-number">2</span>     <span class="hljs-number">7</span>
 / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span>
<span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span>

     <span class="hljs-number">4</span>
   /   <span class="hljs-string">\</span>
  <span class="hljs-number">7</span>     <span class="hljs-number">2</span>
 / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span>
<span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    public TreeNode invertTree(TreeNode root) &#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        TreeNode left = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(left);
        <span class="hljs-keyword">return</span> root;
    &#125;
&#125;</code></pre>

<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h2><pre><code class="hljs groovy">给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
输入: s = <span class="hljs-string">&quot;anagram&quot;</span>, t = <span class="hljs-string">&quot;nagaram&quot;</span>
输出: <span class="hljs-literal">true</span>

输入: s = <span class="hljs-string">&quot;rat&quot;</span>, t = <span class="hljs-string">&quot;car&quot;</span>
输出: <span class="hljs-literal">false</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isAnagram(String s, String t) &#123;
        <span class="hljs-keyword">int</span>[] cnts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> <span class="hljs-attr">c :</span> s.toCharArray()) &#123;
            cnts[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> <span class="hljs-attr">c :</span> t.toCharArray()) &#123;
            cnts[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-attr">c :</span> cnts) &#123;
            <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;</code></pre>

<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h2><pre><code class="hljs makefile">给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

<span class="hljs-section">输入: [1,3,4,2,2]</span>
<span class="hljs-section">输出: 2</span>

<span class="hljs-section">输入: [3,1,3,4,2]</span>
<span class="hljs-section">输出: 3</span></code></pre>

<p>快慢指针</p>
<pre><code class="hljs nginx"><span class="hljs-attribute">class</span> Solution &#123;
    <span class="hljs-attribute">public</span> int findDuplicate(int[] nums) &#123;
        <span class="hljs-attribute">int</span> slow = nums[<span class="hljs-number">0</span>], fast = nums[nums[<span class="hljs-number">0</span>]];
        <span class="hljs-attribute">while</span> (slow != fast) &#123;
            <span class="hljs-attribute">slow</span> = nums[slow];
            <span class="hljs-attribute">fast</span> = nums[nums[fast]];
        &#125;
        <span class="hljs-attribute">fast</span> = <span class="hljs-number">0</span>;
        <span class="hljs-attribute">while</span> (slow != fast) &#123;
            <span class="hljs-attribute">slow</span> = nums[slow];
            <span class="hljs-attribute">fast</span> = nums[fast];
        &#125;
        <span class="hljs-attribute">return</span> slow;
    &#125;
&#125;</code></pre>

<h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h2><pre><code class="hljs typescript">给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= <span class="hljs-number">500</span>,<span class="hljs-number">000</span>），而 s 是个短字符串（长度 &lt;=<span class="hljs-number">100</span>）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<span class="hljs-string">&quot;ace&quot;</span>是<span class="hljs-string">&quot;abcde&quot;</span>的一个子序列，而<span class="hljs-string">&quot;aec&quot;</span>不是）。

s = <span class="hljs-string">&quot;abc&quot;</span>, t = <span class="hljs-string">&quot;ahbgdc&quot;</span>

返回 <span class="hljs-literal">true</span>.

s = <span class="hljs-string">&quot;axc&quot;</span>, t = <span class="hljs-string">&quot;ahbgdc&quot;</span>

返回 <span class="hljs-literal">false</span>.
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSubsequence</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s, <span class="hljs-built_in">String</span> t</span>)</span> &#123;
        <span class="hljs-comment">// 这里用到了String到indexof</span>
        int inx = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (char c : s.toCharArray()) &#123;
            inx = t.indexOf(c, inx + <span class="hljs-number">1</span>);
            <span class="hljs-keyword">if</span> (inx == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;</code></pre>

<h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a>445. 两数相加 II</h2><pre><code class="hljs clean">给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 <span class="hljs-number">0</span> 之外，这两个数字都不会以零开头。

输入：(<span class="hljs-number">7</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)
输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">8</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">7</span></code></pre>

<p>双栈</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public ListNode add<span class="hljs-constructor">TwoNumbers(ListNode <span class="hljs-params">l1</span>, ListNode <span class="hljs-params">l2</span>)</span> &#123;
        Stack&lt;Integer&gt; l1Stack = build<span class="hljs-constructor">Stack(<span class="hljs-params">l1</span>)</span>;
        Stack&lt;Integer&gt; l2Stack = build<span class="hljs-constructor">Stack(<span class="hljs-params">l2</span>)</span>;
        ListNode head = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(-1)</span>;
        <span class="hljs-built_in">int</span> carray = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (!l1Stack.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> || </span>!l2Stack.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> || </span>carray != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-built_in">int</span> x = l1Stack.is<span class="hljs-constructor">Empty()</span> ? <span class="hljs-number">0</span> : l1Stack.pop<span class="hljs-literal">()</span>;
            <span class="hljs-built_in">int</span> y = l2Stack.is<span class="hljs-constructor">Empty()</span> ? <span class="hljs-number">0</span> : l2Stack.pop<span class="hljs-literal">()</span>;
            <span class="hljs-built_in">int</span> sum = x + y + carray;
            ListNode node = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(<span class="hljs-params">sum</span> % 10)</span>;
            node.next = head.next;
            head.next = node;
            carray = sum<span class="hljs-operator"> / </span><span class="hljs-number">10</span>;
        &#125;
        return head.next;
    &#125;

    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; build<span class="hljs-constructor">Stack(ListNode <span class="hljs-params">l</span>)</span> &#123;
        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;
        <span class="hljs-keyword">while</span> (l != null) &#123;
            stack.push(l.<span class="hljs-keyword">val</span>);
            l = l.next;
        &#125;
        return stack;
    &#125;
&#125;</code></pre>

<h2 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836. 矩形重叠"></a>836. 矩形重叠</h2><pre><code class="hljs inform7">矩形以列表 <span class="hljs-comment">[x1, y1, x2, y2]</span> 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果。

矩形以列表 <span class="hljs-comment">[x1, y1, x2, y2]</span> 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果。

输入：rec1 = <span class="hljs-comment">[0,0,2,2]</span>, rec2 = <span class="hljs-comment">[1,1,3,3]</span>
输出：true

输入：rec1 = <span class="hljs-comment">[0,0,1,1]</span>, rec2 = <span class="hljs-comment">[1,0,2,1]</span>
输出：false
class Solution &#123;
    public boolean isRectangleOverlap(int<span class="hljs-comment">[]</span> rec1, int<span class="hljs-comment">[]</span> rec2) &#123;
        if (rec2<span class="hljs-comment">[1]</span> &gt;= rec1<span class="hljs-comment">[3]</span> || rec1<span class="hljs-comment">[1]</span> &gt;= rec2<span class="hljs-comment">[3]</span>) &#123;
            return false;
        &#125;
        if (rec1<span class="hljs-comment">[0]</span> &gt;= rec2<span class="hljs-comment">[2]</span> || rec1<span class="hljs-comment">[2]</span> &lt;= rec2<span class="hljs-comment">[0]</span>) &#123;
            return false;
        &#125;
        return true;
    &#125;
&#125;</code></pre>

<h2 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a>914. 卡牌分组</h2><pre><code class="hljs arduino">给定一副牌，每张牌上都写着一个整数。

此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 <span class="hljs-number">1</span> 组或更多组：

每组都有 X 张牌。
组内所有的牌上都写着相同的整数。
仅当你可选的 X &gt;= <span class="hljs-number">2</span> 时返回 <span class="hljs-literal">true</span>。

输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
输出：<span class="hljs-literal">true</span>
解释：可行的分组是 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]，[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]，[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]，[<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]

输入：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]
输出：<span class="hljs-literal">false</span>
解释：没有满足要求的分组。
class Solution &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> hasGroupsSizeX(<span class="hljs-keyword">int</span>[] deck) &#123;
        <span class="hljs-comment">// hash</span>
        HashMap&lt;Integer, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : deck) &#123;
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>.containsKey(num)) &#123;
                <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(num, <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(num) + <span class="hljs-number">1</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(num, <span class="hljs-number">1</span>);
            &#125;
        &#125;
        <span class="hljs-comment">// 最大公约数</span>
        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : <span class="hljs-built_in">map</span>.values()) &#123;
            t = gcd(t, a);
        &#125;
        <span class="hljs-keyword">return</span> t &gt;= <span class="hljs-number">2</span>;
    &#125;

    <span class="hljs-comment">// 最大公约数</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;
        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);
    &#125;
&#125;</code></pre>

<h2 id="1071-字符串的最大公因子"><a href="#1071-字符串的最大公因子" class="headerlink" title="1071. 字符串的最大公因子"></a>1071. 字符串的最大公因子</h2><pre><code class="hljs typescript">对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 <span class="hljs-number">1</span> 次或多次）时，我们才认定 “T 能除尽 S”。

返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。

输入：str1 = <span class="hljs-string">&quot;ABCABC&quot;</span>, str2 = <span class="hljs-string">&quot;ABC&quot;</span>
输出：<span class="hljs-string">&quot;ABC&quot;</span>

输入：str1 = <span class="hljs-string">&quot;ABABAB&quot;</span>, str2 = <span class="hljs-string">&quot;ABAB&quot;</span>
输出：<span class="hljs-string">&quot;AB&quot;</span>

输入：str1 = <span class="hljs-string">&quot;LEET&quot;</span>, str2 = <span class="hljs-string">&quot;CODE&quot;</span>
输出：<span class="hljs-string">&quot;&quot;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">gcdOfStrings</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> str1, <span class="hljs-built_in">String</span> str2</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (!(str1 + str2).equals(str2 + str1)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;
        &#125;
        <span class="hljs-keyword">return</span> str2.substring(<span class="hljs-number">0</span>, gcd(str1.length(), str2.length()));
    &#125;

    <span class="hljs-keyword">private</span> int <span class="hljs-function"><span class="hljs-title">gcd</span>(<span class="hljs-params">int a, int b</span>)</span> &#123;
        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);
    &#125;
&#125;</code></pre>

<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h2><pre><code class="hljs cpp">    <span class="hljs-comment">//源于离散数学及其应用的算法：（以3 4 5 2 1 为例）</span>
    <span class="hljs-comment">//从后往前寻找第一次出现的正序对：（找到 4,5）</span>
    <span class="hljs-comment">//之后因为从5 开始都是逆序，所以把他们反转就是正序：3 4 1 2 5</span>
    <span class="hljs-comment">//之后4 的位置应该是：在它之后的，比他大的最小值（5）</span>
    <span class="hljs-comment">//交换这两个值：得到 3 5 1 2 4</span>
    <span class="hljs-comment">// 对于初始即为逆序的序列，将在反转步骤直接完成</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">int</span> len = nums.length;
        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] &gt;= nums[i])
            i--; <span class="hljs-comment">// 从后向前找第一个正序，这里最后i指向的是逆序起始位置</span>
        reverse(nums, i, len - <span class="hljs-number">1</span>); <span class="hljs-comment">// 翻转后面的逆序区域，使其变为正序</span>
        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(i &lt; len &amp;&amp; nums[j] &gt;= nums[i])
            i++; <span class="hljs-comment">// 找到第一个比nums[j]大的元素，交换即可</span>
        <span class="hljs-comment">// 交换</span>
        swap(nums, i, j);
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;
        <span class="hljs-keyword">while</span> (i &lt; j) &#123;
            swap(nums, i++, j--);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;
        <span class="hljs-keyword">int</span> t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    &#125;
&#125;</code></pre>

<h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h2><blockquote>
<p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<pre><code class="hljs csharp">&gt;输入:
&gt;[
 [<span class="hljs-meta"><span class="hljs-meta-string">&quot;5&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],
 [<span class="hljs-meta"><span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;5&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],
 [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],
 [<span class="hljs-meta"><span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span></span>],
 [<span class="hljs-meta"><span class="hljs-meta-string">&quot;4&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span></span>],
 [<span class="hljs-meta"><span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;2&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span></span>],
 [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;2&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],
 [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;4&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;5&quot;</span></span>],
 [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span></span>]
&gt;]
&gt;输出: <span class="hljs-literal">true</span></code></pre>
</blockquote>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;
        <span class="hljs-comment">// 记录某行，某位数字是否已经被摆放</span>
        <span class="hljs-keyword">boolean</span>[][] row = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];
        <span class="hljs-comment">// 记录某列，某位数字是否已经被摆放</span>
        <span class="hljs-keyword">boolean</span>[][] col = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];
        <span class="hljs-comment">// 记录某3x3宫格内，某位数字是否已经被摆放</span>
        <span class="hljs-keyword">boolean</span>[][] block = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;
                <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;
                    <span class="hljs-keyword">int</span> num = board[i][j] - <span class="hljs-string">&#x27;1&#x27;</span>;
                    <span class="hljs-keyword">int</span> blockIdx = i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">if</span> (row[i][num] || col[j][num] || block[blockIdx][num]) &#123;
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        row[i][num] = <span class="hljs-literal">true</span>;
                        col[j][num] = <span class="hljs-literal">true</span>;
                        block[blockIdx][num] = <span class="hljs-literal">true</span>;
                    &#125;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;</code></pre>

<h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h2><pre><code class="hljs pgsql">给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
输入: candidates = [<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], target = <span class="hljs-number">8</span>,
所求解集为:
[
  [<span class="hljs-number">1</span>, <span class="hljs-number">7</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>],
  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>]
]
<span class="hljs-keyword">class</span> Solution &#123;
    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinationSum2(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target) &#123;
        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinations = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();
        Arrays.sort(candidates);
        backtracking(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(), combinations, <span class="hljs-built_in">new</span> <span class="hljs-type">boolean</span>[candidates.length], <span class="hljs-number">0</span>, target, candidates);
        <span class="hljs-keyword">return</span> combinations;
    &#125;

    private <span class="hljs-type">void</span> backtracking(List&lt;<span class="hljs-type">Integer</span>&gt; tempCombination, List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinations,
                            <span class="hljs-type">boolean</span>[] hasVisited, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> target, final <span class="hljs-type">int</span>[] candidates) &#123;

        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;
            combinations.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(tempCombination));
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">start</span>; i &lt; candidates.length; i++) &#123;
            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; !hasVisited[i - <span class="hljs-number">1</span>]) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-keyword">if</span> (candidates[i] &lt;= target) &#123;
                tempCombination.<span class="hljs-keyword">add</span>(candidates[i]);
                hasVisited[i] = <span class="hljs-keyword">true</span>;
                backtracking(tempCombination, combinations, hasVisited, i + <span class="hljs-number">1</span>, target - candidates[i], candidates);
                hasVisited[i] = <span class="hljs-keyword">false</span>;
                tempCombination.remove(tempCombination.size() - <span class="hljs-number">1</span>);
            &#125;
        &#125;
    &#125;

&#125;</code></pre>

<h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h2><pre><code class="hljs arduino">给定一个可包含重复数字的序列，返回所有不重复的全排列。
输入: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
输出:
[
  [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],
  [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]
]
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">permuteUnique</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        List&lt;List&lt;Integer&gt;&gt; permutes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        List&lt;Integer&gt; permuteList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        Arrays.sort(nums); <span class="hljs-comment">// 排序</span>
        <span class="hljs-keyword">boolean</span>[] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];
        backtracking(permuteList, permutes, hasVisited, nums);
        <span class="hljs-keyword">return</span> permutes;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (permuteList.<span class="hljs-built_in">size</span>() == nums.length) &#123;
            permutes.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(permuteList));
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; visited.length; i++) &#123;
            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i <span class="hljs-number">-1</span>] &amp;&amp; !visited[i - <span class="hljs-number">1</span>]) &#123;
                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 防止重复</span>
            &#125;
            <span class="hljs-keyword">if</span> (visited[i]) <span class="hljs-keyword">continue</span>;
            visited[i] = <span class="hljs-literal">true</span>;
            permuteList.add(nums[i]);
            backtracking(permuteList, permutes, visited, nums);
            permuteList.<span class="hljs-built_in">remove</span>(permuteList.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);
            visited[i] = <span class="hljs-literal">false</span>;
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><pre><code class="hljs prolog">给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符

输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span>
输出：<span class="hljs-number">3</span>
解释：
horse -&gt; rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)
rorse -&gt; rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)
rose -&gt; ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)
class <span class="hljs-symbol">Solution</span> &#123;
    public int minDistance(<span class="hljs-symbol">String</span> word1, <span class="hljs-symbol">String</span> word2) &#123;
        if (word1 == null || word2 == null) &#123;
            return <span class="hljs-number">0</span>;
        &#125;
        int m = word1.length(), n = word2.length();
        int[][] dp = new int[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];
        for (int i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;
            dp[i][<span class="hljs-number">0</span>] = i;
        &#125;
        for (int i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
            dp[<span class="hljs-number">0</span>][i] = i;
        &#125;
        for (int i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;
            for (int j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;
                if (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;
                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];
                &#125; else &#123;
                    dp[i][j] = <span class="hljs-symbol">Math</span>.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-symbol">Math</span>.min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span>;
                &#125;
            &#125;
        &#125;
        return dp[m][n];
    &#125;

&#125;</code></pre>

<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h2><pre><code class="hljs arduino">给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

board =
[
  [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>],
  [<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span>],
  [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>]
]

给定 <span class="hljs-keyword">word</span> = <span class="hljs-string">&quot;ABCCED&quot;</span>, 返回 <span class="hljs-literal">true</span>
给定 <span class="hljs-keyword">word</span> = <span class="hljs-string">&quot;SEE&quot;</span>, 返回 <span class="hljs-literal">true</span>
给定 <span class="hljs-keyword">word</span> = <span class="hljs-string">&quot;ABCB&quot;</span>, 返回 <span class="hljs-literal">false</span>
class Solution &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] direction = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span>)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">word</span> == null || <span class="hljs-keyword">word</span>.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (board == null || board.length == <span class="hljs-number">0</span> || board[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        m = board.length;
        n = board[<span class="hljs-number">0</span>].length;
        <span class="hljs-keyword">boolean</span>[][] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; m; r++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n; c++) &#123;
                <span class="hljs-keyword">if</span> (backtracking(<span class="hljs-number">0</span>, r, c, hasVisited, board, <span class="hljs-keyword">word</span>)) &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curLen, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">boolean</span>[][] visited, <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span>)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (curLen == <span class="hljs-keyword">word</span>.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> || r &gt;= m || c &lt; <span class="hljs-number">0</span> || c &gt;= n || board[r][c] != <span class="hljs-keyword">word</span>.charAt(curLen) || visited[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        visited[r][c] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] d : direction) &#123;
            <span class="hljs-keyword">if</span> (backtracking(curLen + <span class="hljs-number">1</span>, r + d[<span class="hljs-number">0</span>], c + d[<span class="hljs-number">1</span>], visited, board, <span class="hljs-keyword">word</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        visited[r][c] = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;</code></pre>

<h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a>91. 解码方法</h2><pre><code class="hljs clean">一条包含字母 A-Z 的消息通过以下方式进行了编码：
<span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">1</span>
<span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">2</span>
...
<span class="hljs-string">&#x27;Z&#x27;</span> -&gt; <span class="hljs-number">26</span>

输入: <span class="hljs-string">&quot;12&quot;</span>
输出: <span class="hljs-number">2</span>
解释: 它可以解码为 <span class="hljs-string">&quot;AB&quot;</span>（<span class="hljs-number">1</span> <span class="hljs-number">2</span>）或者 <span class="hljs-string">&quot;L&quot;</span>（<span class="hljs-number">12</span>）。

输入: <span class="hljs-string">&quot;226&quot;</span>
输出: <span class="hljs-number">3</span>
解释: 它可以解码为 <span class="hljs-string">&quot;BZ&quot;</span> (<span class="hljs-number">2</span> <span class="hljs-number">26</span>), <span class="hljs-string">&quot;VF&quot;</span> (<span class="hljs-number">22</span> <span class="hljs-number">6</span>), 或者 <span class="hljs-string">&quot;BBF&quot;</span> (<span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>) 。</code></pre>

<p>dp</p>
<pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;
    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> numDecodings(String s) &#123;
        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-type">int</span> n = s.length();
        <span class="hljs-type">int</span>[] dp = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>];
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        dp[<span class="hljs-number">1</span>] = s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;
            <span class="hljs-type">int</span> one = <span class="hljs-type">Integer</span>.valueOf(s.substring(i - <span class="hljs-number">1</span>, i));
            <span class="hljs-keyword">if</span> (one != <span class="hljs-number">0</span>) &#123;
                dp[i] += dp[i - <span class="hljs-number">1</span>];
            &#125;
            <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;
            <span class="hljs-type">int</span> two = <span class="hljs-type">Integer</span>.valueOf(s.substring(i - <span class="hljs-number">2</span>, i));
            <span class="hljs-keyword">if</span> (two &lt;= <span class="hljs-number">26</span>) &#123;
                dp[i] += dp[i - <span class="hljs-number">2</span>];
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[n];
    &#125;
&#125;</code></pre>

<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><pre><code class="hljs reasonml">给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过<span class="hljs-number">1</span>。
    <span class="hljs-number">3</span>
<span class="hljs-operator">   / </span>\
  <span class="hljs-number">9</span>  <span class="hljs-number">20</span>
<span class="hljs-operator">    /  </span>\
   <span class="hljs-number">15</span>   <span class="hljs-number">7</span>

   <span class="hljs-literal">true</span>
lass Solution &#123;
    <span class="hljs-keyword">private</span> boolean res = <span class="hljs-literal">true</span>;
    public boolean is<span class="hljs-constructor">Balanced(TreeNode <span class="hljs-params">root</span>)</span> &#123;
        <span class="hljs-constructor">Depth(<span class="hljs-params">root</span>)</span>;
        return res;
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> Depth (TreeNode root) &#123;
        <span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>null) return <span class="hljs-number">0</span>;
        <span class="hljs-built_in">int</span> l = <span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;
        <span class="hljs-built_in">int</span> r = <span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(l - r) &gt; <span class="hljs-number">1</span>) res = <span class="hljs-literal">false</span>;;
        return <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(l , r);
    &#125;
&#125;</code></pre>

<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h2><pre><code class="hljs typescript">给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。

输入: s = <span class="hljs-string">&quot;leetcode&quot;</span>, wordDict = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]
输出: <span class="hljs-literal">true</span>
解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;leet code&quot;</span>。

输入: s = <span class="hljs-string">&quot;applepenapple&quot;</span>, wordDict = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pen&quot;</span>]
输出: <span class="hljs-literal">true</span>
解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;applepenapple&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;apple pen apple&quot;</span>。
     注意你可以重复使用字典中的单词。

来输入: s = <span class="hljs-string">&quot;catsandog&quot;</span>, wordDict = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]
输出: <span class="hljs-literal">false</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">wordBreak</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s, List&lt;<span class="hljs-built_in">String</span>&gt; wordDict</span>)</span> &#123;
        int n = s.length();
        <span class="hljs-built_in">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">boolean</span>[n + <span class="hljs-number">1</span>];
        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> word: wordDict) &#123;
                <span class="hljs-comment">// 对物品的迭代应该放在最里层</span>
                int len = word.length();
                <span class="hljs-keyword">if</span> (len &lt;= i &amp;&amp; word.equals(s.substring(i - len , i))) &#123;
                    dp[i] = dp[i] || dp[i - len];
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[n];
    &#125;
&#125;</code></pre>

<h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h2><pre><code class="hljs arduino">给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 <span class="hljs-literal">true</span> 。如果数组中每个元素都不相同，则返回 <span class="hljs-literal">false</span> 。

输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]
输出: <span class="hljs-literal">true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        HashSet&lt;Integer&gt; <span class="hljs-built_in">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set</span>.add(num)) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;</code></pre>

<h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h2><pre><code class="hljs xquery">输入:<span class="hljs-built_in"> head</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], <span class="hljs-type">node</span> = <span class="hljs-number">5</span>
输出: [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>]
解释: 给定你链表中值为 <span class="hljs-number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">9</span>.
class Solution &#123;
    public void deleteNode(ListNode <span class="hljs-type">node</span>) &#123;
        <span class="hljs-type">node</span>.val = <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span>.val;
        <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;
    &#125;
&#125;</code></pre>

<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h2><pre><code class="hljs excel">给你一个长度为 <span class="hljs-built_in">n</span> 的整数数组 nums，其中 <span class="hljs-built_in">n</span> &gt; <span class="hljs-number">1</span>，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
输入<span class="hljs-symbol">:</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
输出<span class="hljs-symbol">:</span> [<span class="hljs-number">24</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>]
class Solution &#123;
    public <span class="hljs-built_in">int</span>[] productExceptSelf(<span class="hljs-built_in">int</span>[] nums) &#123;
        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = nums.length;
        <span class="hljs-built_in">int</span>[] products = new <span class="hljs-built_in">int</span>[<span class="hljs-built_in">n</span>];
        Arrays.fill(products, <span class="hljs-number">1</span>);
        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">1</span>;
        for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">n</span>; i++) &#123;
            <span class="hljs-built_in">left</span> *= nums[i - <span class="hljs-number">1</span>];
            products[i] *= <span class="hljs-built_in">left</span>;
        &#125;
        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-number">1</span>;
        for (<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">n</span> - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;
            <span class="hljs-built_in">right</span> *= nums[i + <span class="hljs-number">1</span>];
            products[i] *= <span class="hljs-built_in">right</span>;
        &#125;
        return products;
    &#125;
&#125;</code></pre>

<h2 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<pre><code class="hljs dart">输入: nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], nums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]
输出: [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]

输入: nums1 = [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>], nums2 = [<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>]
输出: [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>]
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    public <span class="hljs-built_in">int</span>[] intersect(<span class="hljs-built_in">int</span>[] nums1, <span class="hljs-built_in">int</span>[] nums2) &#123;
        ArrayList&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums1) &#123;
            list1.add(<span class="hljs-built_in">num</span>);
        &#125;
        ArrayList&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums2) &#123;
            <span class="hljs-keyword">if</span> (list1.contains(<span class="hljs-built_in">num</span>)) &#123;
                list2.add(<span class="hljs-built_in">num</span>);
                list1.remove(<span class="hljs-built_in">num</span>);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> list2.stream().mapToInt(Integer::valueOf).toArray();
    &#125;
&#125;</code></pre>

<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a>461. 汉明距离</h2><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p>
<pre><code class="hljs angelscript">输入: x = <span class="hljs-number">1</span>, y = <span class="hljs-number">4</span>

输出: <span class="hljs-number">2</span>

解释:
<span class="hljs-number">1</span>   (<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>)
<span class="hljs-number">4</span>   (<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。
<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hammingDistance(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) &#123;
        <span class="hljs-built_in">int</span> z = x ^ y;
        <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (z != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> ((z &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) cnt++;
            z = z &gt;&gt; <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">return</span> cnt;
    &#125;
&#125;</code></pre>

<h2 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a>572. 另一个树的子树</h2><pre><code class="hljs reasonml">给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
     <span class="hljs-number">3</span>
<span class="hljs-operator">    / </span>\
   <span class="hljs-number">4</span>   <span class="hljs-number">5</span>
<span class="hljs-operator">  / </span>\
 <span class="hljs-number">1</span>   <span class="hljs-number">2</span>

    <span class="hljs-number">4</span> 
<span class="hljs-operator">  / </span>\
 <span class="hljs-number">1</span>   <span class="hljs-number">2</span>
 <span class="hljs-keyword">class</span> Solution &#123;
    public boolean is<span class="hljs-constructor">Subtree(TreeNode <span class="hljs-params">s</span>, TreeNode <span class="hljs-params">t</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (s<span class="hljs-operator"> == </span>null) return <span class="hljs-literal">false</span>;
        return is<span class="hljs-constructor">SubtreeWithRoot(<span class="hljs-params">s</span>, <span class="hljs-params">t</span>)</span><span class="hljs-operator"> || </span>is<span class="hljs-constructor">Subtree(<span class="hljs-params">s</span>.<span class="hljs-params">left</span>, <span class="hljs-params">t</span>)</span><span class="hljs-operator"> || </span>is<span class="hljs-constructor">Subtree(<span class="hljs-params">s</span>.<span class="hljs-params">right</span>, <span class="hljs-params">t</span>)</span>;
    &#125;

    <span class="hljs-keyword">private</span> boolean is<span class="hljs-constructor">SubtreeWithRoot(TreeNode <span class="hljs-params">s</span>, TreeNode <span class="hljs-params">t</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (t<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>s<span class="hljs-operator"> == </span>null) return <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (t<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>s<span class="hljs-operator"> == </span>null) return <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (t.<span class="hljs-keyword">val</span> != s.<span class="hljs-keyword">val</span>) return <span class="hljs-literal">false</span>;
        return is<span class="hljs-constructor">SubtreeWithRoot(<span class="hljs-params">s</span>.<span class="hljs-params">left</span>, <span class="hljs-params">t</span>.<span class="hljs-params">left</span>)</span><span class="hljs-operator"> &amp;&amp; </span>is<span class="hljs-constructor">SubtreeWithRoot(<span class="hljs-params">s</span>.<span class="hljs-params">right</span>, <span class="hljs-params">t</span>.<span class="hljs-params">right</span>)</span>;
    &#125;
&#125;</code></pre>

<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><blockquote>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：<span class="hljs-string">&quot;abc&quot;</span></span>
<span class="hljs-meta">&gt;</span><span class="bash">输出：3</span>
<span class="hljs-meta">&gt;</span><span class="bash">解释：三个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span></span></code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：<span class="hljs-string">&quot;aaa&quot;</span></span>
<span class="hljs-meta">&gt;</span><span class="bash">输出：6</span>
<span class="hljs-meta">&gt;</span><span class="bash">解释：6个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span></span></code></pre>
</blockquote>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;
    public <span class="hljs-built_in">int</span> count<span class="hljs-constructor">Substrings(String <span class="hljs-params">s</span>)</span> &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length<span class="hljs-literal">()</span>; i++) &#123;
            extend<span class="hljs-constructor">Substrings(<span class="hljs-params">s</span>, <span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>; <span class="hljs-comment">// 奇数长度</span>
            extend<span class="hljs-constructor">Substrings(<span class="hljs-params">s</span>, <span class="hljs-params">i</span>, <span class="hljs-params">i</span> + 1)</span>; <span class="hljs-comment">// 偶数长度</span>
        &#125;
        return cnt;
    &#125;
    <span class="hljs-keyword">private</span> void extend<span class="hljs-constructor">Substrings(String <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">start</span>, <span class="hljs-params">int</span> <span class="hljs-params">end</span>)</span> &#123;
        <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-keyword">end</span> &lt; s.length<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">start</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">end</span>)</span>) &#123;
            start--;
            <span class="hljs-keyword">end</span>++;
            cnt++;
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a>680. 验证回文字符串 Ⅱ</h2><p> 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p>
<pre><code class="hljs reasonml">输入: <span class="hljs-string">&quot;aba&quot;</span>
输出: True

输入: <span class="hljs-string">&quot;abca&quot;</span>
输出: True
解释: 你可以删除c字符。
<span class="hljs-keyword">class</span> Solution &#123;
    public boolean valid<span class="hljs-constructor">Palindrome(String <span class="hljs-params">s</span>)</span> &#123;
        <span class="hljs-comment">// 普通判断回文串用前后双指针即可，但是，难点在于如果去删除一个元素后的字符串是不是回文串</span>
        <span class="hljs-comment">// 如果前后指针的元素不相等，此时子串的范围（i+1，j）或（j-1）的俩子串只要任意一个是，则结果是</span>
        <span class="hljs-comment">// 否则，则不是</span>
        <span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span>, j = s.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(i &lt; j) &#123;
            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span> != s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>) &#123;
                return is<span class="hljs-constructor">Vaild(<span class="hljs-params">s</span>, <span class="hljs-params">i</span>+1, <span class="hljs-params">j</span>)</span><span class="hljs-operator"> || </span>is<span class="hljs-constructor">Vaild(<span class="hljs-params">s</span>, <span class="hljs-params">i</span>, <span class="hljs-params">j</span>-1)</span>;
            &#125;
            i++;
            j--;
        &#125;
        return <span class="hljs-literal">true</span>;
    &#125;

    public boolean is<span class="hljs-constructor">Vaild(String <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">i</span>, <span class="hljs-params">int</span> <span class="hljs-params">j</span>)</span> &#123;
        <span class="hljs-keyword">while</span>(i &lt; j) &#123;
            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span> != s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>) &#123;
                return <span class="hljs-literal">false</span>;
            &#125;
            i++;
            j--;
        &#125;
        return <span class="hljs-literal">true</span>;
    &#125;
&#125;</code></pre>

<h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h2><blockquote>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p>
<p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<pre><code class="hljs haxe">&gt;输入
&gt;[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]
&gt;[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]
&gt;输出
&gt;[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]

&gt;解释
&gt;LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);
&gt;lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span>
&gt;lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span>
&gt;lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span>
&gt;lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span>
&gt;lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span>
&gt;lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span>
&gt;lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span>
&gt;lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span>
&gt;lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span></code></pre>
</blockquote>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;
    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;
        <span class="hljs-keyword">this</span>.cap = capacity;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.containsKey(key)) &#123;
            <span class="hljs-keyword">int</span> value = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(key);
            <span class="hljs-comment">// 查一次，就将查到到仍在队尾</span>
            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">remove</span>(key);
            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(key,value);
            <span class="hljs-keyword">return</span> value;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.containsKey(key)) &#123;
            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">remove</span>(key);
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.<span class="hljs-built_in">size</span>() == cap) &#123;
            <span class="hljs-comment">// 满了</span>
            Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = <span class="hljs-built_in">map</span>.entrySet().iterator();
            iterator.next();
            iterator.<span class="hljs-built_in">remove</span>();
        &#125;
        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(key, value);
    &#125;
&#125;</code></pre>

<h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h2><blockquote>
<p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<pre><code class="hljs inform7">&gt;输入: <span class="hljs-comment">[1,2,2]</span>
&gt;输出:
&gt;<span class="hljs-comment">[</span>
<span class="hljs-comment"> <span class="hljs-comment">[2]</span>,</span>
<span class="hljs-comment"> <span class="hljs-comment">[1]</span>,</span>
<span class="hljs-comment"> <span class="hljs-comment">[1,2,2]</span>,</span>
<span class="hljs-comment"> <span class="hljs-comment">[2,2]</span>,</span>
<span class="hljs-comment"> <span class="hljs-comment">[1,2]</span>,</span>
<span class="hljs-comment"> <span class="hljs-comment">[]</span></span>
<span class="hljs-comment">&gt;]</span></code></pre>
</blockquote>
<pre><code class="hljs arduino">给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]
输出:
[
  [<span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>],
  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],
  [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],
  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],
  []
]
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        List&lt;Integer&gt; tempSubset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">boolean</span>[] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">size</span> &lt;= nums.length; <span class="hljs-built_in">size</span>++) &#123;
            backtracking(<span class="hljs-number">0</span>, tempSubset, subsets, hasVisited, <span class="hljs-built_in">size</span>, nums); <span class="hljs-comment">// 不同的子集大小</span>
        &#125;
        <span class="hljs-keyword">return</span> subsets;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets, <span class="hljs-keyword">boolean</span>[] hasVisited,</span></span>
<span class="hljs-function"><span class="hljs-params">                            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;

        <span class="hljs-keyword">if</span> (tempSubset.<span class="hljs-built_in">size</span>() == <span class="hljs-built_in">size</span>) &#123;
            subsets.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tempSubset));
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length; i++) &#123;
            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !hasVisited[i - <span class="hljs-number">1</span>]) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            tempSubset.add(nums[i]);
            hasVisited[i] = <span class="hljs-literal">true</span>;
            backtracking(i + <span class="hljs-number">1</span>, tempSubset, subsets, hasVisited, <span class="hljs-built_in">size</span>, nums);
            hasVisited[i] = <span class="hljs-literal">false</span>;
            tempSubset.<span class="hljs-built_in">remove</span>(tempSubset.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);
        &#125;
    &#125;

&#125;</code></pre>

<h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<pre><code class="hljs sas"><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span>
<span class="hljs-meta">X</span> O O <span class="hljs-meta">X</span>
<span class="hljs-meta">X</span> <span class="hljs-meta">X</span> O <span class="hljs-meta">X</span>
<span class="hljs-meta">X</span> O <span class="hljs-meta">X</span> <span class="hljs-meta">X</span>

<span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span>
<span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span>
<span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span>
<span class="hljs-meta">X</span> O <span class="hljs-meta">X</span> <span class="hljs-meta">X</span>
class Solution &#123;
    private int[][] direction = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;
    private int m, n;
    public void solve(char[][] board) &#123;
        <span class="hljs-meta">if</span> (board == <span class="hljs-meta">null</span> || board.<span class="hljs-meta">length</span> == 0) <span class="hljs-meta">return</span>;
        m = board.<span class="hljs-meta">length</span>;
        n = board[0].<span class="hljs-meta">length</span>;
        for (int i = 0; i &lt; m; i++) &#123;
            dfs(board, i, 0);
            dfs(board, i, n - 1);
        &#125;
        for (int i = 0; i &lt; n; i++) &#123;
            dfs(board, 0, i);
            dfs(board, m - 1, i);
        &#125;

        for (int i = 0; i &lt; m; i++) &#123;
            for (int j = 0; j &lt; n; j++) &#123;
                <span class="hljs-meta">if</span> (board[i][j] == <span class="hljs-string">&#x27;T&#x27;</span>) &#123;
                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;
                &#125; <span class="hljs-meta">else</span> <span class="hljs-meta">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;
                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;
                &#125;
            &#125;
        &#125;
    &#125;

    private void dfs(char[][] board, int r, int c) &#123;
        <span class="hljs-meta">if</span>(r&lt;0 || r &gt;= m || c &lt; 0 || c &gt;= n || board[r][c] != <span class="hljs-string">&#x27;O&#x27;</span>) &#123;
            <span class="hljs-meta">return</span>;
        &#125;
        board[r][c] = <span class="hljs-string">&#x27;T&#x27;</span>;
        for (int[] d : direction) &#123;
            dfs(board, r + d[0], c + d[1]);
        &#125;
    &#125;
&#125;</code></pre>

<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h2><pre><code class="hljs angelscript">假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] 可能变为 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

输入: [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
输出: <span class="hljs-number">1</span>

输入: [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
输出: <span class="hljs-number">0</span>
<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> findMin(<span class="hljs-built_in">int</span>[] nums) &#123;
        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, h = nums.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (l &lt; h) &#123;
            <span class="hljs-built_in">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (nums[m] &lt;= nums[h]) &#123;
                h = m;
            &#125; <span class="hljs-keyword">else</span> &#123;
                l = m + <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> nums[l];
    &#125;
&#125;</code></pre>

<h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<pre><code class="hljs cpp">输入：<span class="hljs-number">00000000000000000000000000001011</span>
输出：<span class="hljs-number">3</span>
解释：输入的二进制串 <span class="hljs-number">00000000000000000000000000001011</span> 中，共有三位为 <span class="hljs-string">&#x27;1&#x27;</span>。

输入：<span class="hljs-number">00000000000000000000000010000000</span>
输出：<span class="hljs-number">1</span>
解释：输入的二进制串 <span class="hljs-number">00000000000000000000000010000000</span> 中，共有一位为 <span class="hljs-string">&#x27;1&#x27;</span>。
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-comment">// you need to treat n as an unsigned value</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;
            n &amp;= n - <span class="hljs-number">1</span>;
            ans++;
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;</code></pre>

<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a>213. 打家劫舍 II</h2><pre><code class="hljs java">你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

输入: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]
输出: <span class="hljs-number">3</span>
解释: 你不能先偷窃 <span class="hljs-number">1</span> 号房屋（金额 = <span class="hljs-number">2</span>），然后偷窃 <span class="hljs-number">3</span> 号房屋（金额 = <span class="hljs-number">2</span>）, 因为他们是相邻的。

输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]
输出: <span class="hljs-number">4</span>
解释: 你可以先偷窃 <span class="hljs-number">1</span> 号房屋（金额 = <span class="hljs-number">1</span>），然后偷窃 <span class="hljs-number">3</span> 号房屋（金额 = <span class="hljs-number">3</span>）。
     偷窃到的最高金额 = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">4</span> 。
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n = nums.length;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">return</span> Math.max(rob(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">2</span>), rob(nums, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>));
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last)</span> </span>&#123;
        <span class="hljs-keyword">int</span> pre2 = <span class="hljs-number">0</span>, pre1 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = first; i &lt;= last; i++) &#123;
            <span class="hljs-keyword">int</span> cur = Math.max(pre1, pre2 + nums[i]);
            pre2 = pre1;
            pre1 = cur;
        &#125;
        <span class="hljs-keyword">return</span> pre1;
    &#125;
&#125;</code></pre>

<h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a>219. 存在重复元素 II</h2><pre><code class="hljs csharp">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span>
输出: <span class="hljs-literal">true</span>

输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span>
输出: <span class="hljs-literal">true</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">containsNearbyDuplicate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k</span>)</span> &#123;
        HashSet&lt;Integer&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">set</span>.contains(nums[i])) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125; 
            <span class="hljs-keyword">set</span>.<span class="hljs-keyword">add</span>(nums[i]);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">set</span>.size() &gt; k) &#123;
                <span class="hljs-keyword">set</span>.<span class="hljs-keyword">remove</span>(nums[i - k]);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;</code></pre>

<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h2><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p>
<p>说明： 你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p>
<pre><code class="hljs axapta">输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span>
   <span class="hljs-number">3</span>
  / \
 <span class="hljs-number">1</span>   <span class="hljs-number">4</span>
  \
   <span class="hljs-number">2</span>
输出: <span class="hljs-number">1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> kthSmallest(TreeNode root, <span class="hljs-built_in">int</span> k) &#123;
        <span class="hljs-built_in">int</span> leftCnt = <span class="hljs-keyword">count</span>(root.left);
        <span class="hljs-keyword">if</span> (leftCnt == k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root.val;
        <span class="hljs-keyword">if</span> (leftCnt &gt; k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> kthSmallest(root.left, k);
        <span class="hljs-keyword">return</span> kthSmallest(root.right, k - leftCnt - <span class="hljs-number">1</span>);
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> (TreeNode node) &#123;
        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-keyword">count</span>(node.left) + <span class="hljs-keyword">count</span>(node.right);
    &#125;
&#125;</code></pre>

<h2 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h2><blockquote>
<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方.</p>
<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: 1</span>
<span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">true</span></span>
<span class="hljs-meta">&gt;</span><span class="bash">解释: 20 = 1</span></code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: 16</span>
<span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">true</span></span>
<span class="hljs-meta">&gt;</span><span class="bash">解释: 24 = 16</span></code></pre>

<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: 218</span>
<span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">false</span></span></code></pre>
</blockquote>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public boolean is<span class="hljs-constructor">PowerOfTwo(<span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span> &#123;
        return n &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>bit<span class="hljs-constructor">Count(<span class="hljs-params">n</span>)</span><span class="hljs-operator"> == </span><span class="hljs-number">1</span>;
    &#125;
&#125;</code></pre>

<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h2><blockquote>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false</p>
<p>说明：</p>
<p>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：</span>
<span class="hljs-meta">&gt;</span><span class="bash">[<span class="hljs-string">&quot;MyQueue&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;peek&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]</span>
<span class="hljs-meta">&gt;</span><span class="bash">[[], [1], [2], [], [], []]</span>
<span class="hljs-meta">&gt;</span><span class="bash">输出：</span>
<span class="hljs-meta">&gt;</span><span class="bash">[null, null, null, 1, 1, <span class="hljs-literal">false</span>]</span>

<span class="hljs-meta">&gt;</span><span class="bash">解释：</span>
<span class="hljs-meta">&gt;</span><span class="bash">MyQueue myQueue = new MyQueue();</span>
<span class="hljs-meta">&gt;</span><span class="bash">myQueue.push(1); // queue is: [1]</span>
<span class="hljs-meta">&gt;</span><span class="bash">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span>
<span class="hljs-meta">&gt;</span><span class="bash">myQueue.peek(); // <span class="hljs-built_in">return</span> 1</span>
<span class="hljs-meta">&gt;</span><span class="bash">myQueue.pop(); // <span class="hljs-built_in">return</span> 1, queue is [2]</span>
<span class="hljs-meta">&gt;</span><span class="bash">myQueue.empty(); // <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span></span></code></pre>
</blockquote>
<pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;

    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; <span class="hljs-keyword">in</span>;
    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; <span class="hljs-keyword">out</span>;

    <span class="hljs-comment">/** Initialize your data structure here. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        <span class="hljs-keyword">out</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
    &#125;
    
    <span class="hljs-comment">/** Push element x to the back of queue. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;
        <span class="hljs-keyword">in</span>.push(x);
    &#125;
    
    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;
        in2Out();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span>.pop();
    &#125;
    
    <span class="hljs-comment">/** Get the front element. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;
        in2Out();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span>.peek();
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in2Out</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">out</span>.isEmpty()) &#123;
            <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">in</span>.isEmpty()) &#123;
                <span class="hljs-keyword">out</span>.push(<span class="hljs-keyword">in</span>.pop());
            &#125;
        &#125;
    &#125;
    
    <span class="hljs-comment">/** Returns whether the queue is empty. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">in</span>.isEmpty() &amp;&amp; <span class="hljs-keyword">out</span>.isEmpty();
    &#125;
&#125;</code></pre>

<h2 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a>268. 缺失数字</h2><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p>
<pre><code class="hljs angelscript">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]
输出: <span class="hljs-number">2</span>

输入: [<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]
输出: <span class="hljs-number">8</span>
<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> missingNumber(<span class="hljs-built_in">int</span>[] nums) &#123;
        <span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
            ret = ret ^ i ^ nums[i];
        &#125;
        <span class="hljs-keyword">return</span> ret ^ nums.length;
    &#125;
&#125;</code></pre>

<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<pre><code class="hljs stan">输入: n = <span class="hljs-number">12</span>
输出: <span class="hljs-number">3</span> 
解释: <span class="hljs-number">12</span> = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4.</span>

输入: n = <span class="hljs-number">13</span>
输出: <span class="hljs-number">2</span>
解释: <span class="hljs-number">13</span> = <span class="hljs-number">4</span> + <span class="hljs-number">9.</span>
class Solution &#123;
    public <span class="hljs-keyword">int</span> numSquares(<span class="hljs-keyword">int</span> n) &#123;
        List&lt;Integer&gt; squareList = generateSquareList(n);
        <span class="hljs-keyword">int</span>[] dp = new <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;
            <span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = Integer.MAX_VALUE;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-built_in">square</span> : squareList) &#123;
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">square</span> &gt; i) <span class="hljs-keyword">break</span>;
                <span class="hljs-built_in">min</span> = Math.<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>, dp[i - <span class="hljs-built_in">square</span>] + <span class="hljs-number">1</span>);
            &#125;
            dp[i] = <span class="hljs-built_in">min</span>;
        &#125;
        <span class="hljs-keyword">return</span> dp[n];
    &#125;
    private List&lt;Integer&gt; generateSquareList(<span class="hljs-keyword">int</span> n) &#123;
        List&lt;Integer&gt; squareList = new ArrayList&lt;&gt;();
        <span class="hljs-keyword">int</span> diff = <span class="hljs-number">3</span>;
        <span class="hljs-keyword">int</span> <span class="hljs-built_in">square</span> = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">square</span> &lt;= n) &#123;
            squareList.add(<span class="hljs-built_in">square</span>);
            <span class="hljs-built_in">square</span> += diff;
            diff += <span class="hljs-number">2</span>;
        &#125;
        <span class="hljs-keyword">return</span> squareList;
    &#125;
&#125;</code></pre>

<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h2><pre><code class="hljs monkey">给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(<span class="hljs-number">1</span>)，时间复杂度应为 O(nodes)，nodes 为节点总数。
输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">NULL</span>
输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-literal">NULL</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-keyword">public</span> ListNode oddEvenList(ListNode head) &#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;
        ListNode odd = head, even = head.<span class="hljs-keyword">next</span>, evenHead = even;
        <span class="hljs-keyword">while</span> (even != <span class="hljs-literal">null</span> &amp;&amp; even.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;
            odd.<span class="hljs-keyword">next</span> = odd.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;
            odd = odd.<span class="hljs-keyword">next</span>;
            even.<span class="hljs-keyword">next</span> = even.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;
            even = even.<span class="hljs-keyword">next</span>;
        &#125;
        odd.<span class="hljs-keyword">next</span> = evenHead;
        <span class="hljs-keyword">return</span> head;
    &#125;
&#125;</code></pre>

<h2 id="378-有序矩阵中第K小的元素"><a href="#378-有序矩阵中第K小的元素" class="headerlink" title="378. 有序矩阵中第K小的元素"></a>378. 有序矩阵中第K小的元素</h2><pre><code class="hljs angelscript">给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

matrix = [
<span class="hljs-string">   [ 1,  5,  9]</span>,
<span class="hljs-string">   [10, 11, 13]</span>,
<span class="hljs-string">   [12, 13, 15]</span>
],
k = <span class="hljs-number">8</span>,

返回 <span class="hljs-number">13</span>。
<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> kthSmallest(<span class="hljs-built_in">int</span>[][] matrix, <span class="hljs-built_in">int</span> k) &#123;
        <span class="hljs-built_in">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;
        <span class="hljs-built_in">int</span> lo = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], hi = matrix[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">while</span> (lo &lt;= hi) &#123;
            <span class="hljs-built_in">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;
            <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++) &#123;
                    cnt++;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span> (cnt &lt; k) lo = mid + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> hi = mid - <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">return</span> lo;
    &#125;
&#125;</code></pre>

<h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h2><blockquote>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">s = <span class="hljs-string">&quot;leetcode&quot;</span></span>
<span class="hljs-meta">&gt;</span><span class="bash">返回 0</span>

<span class="hljs-meta">&gt;</span><span class="bash">s = <span class="hljs-string">&quot;loveleetcode&quot;</span></span>
<span class="hljs-meta">&gt;</span><span class="bash">返回 2</span></code></pre>
</blockquote>
<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;
        HashMap&lt;Character, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray())&#123;
            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(c, <span class="hljs-built_in">map</span>.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(s.charAt(i)) == <span class="hljs-number">1</span>) &#123;
                <span class="hljs-keyword">return</span> i;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
&#125;</code></pre>

<h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h2><blockquote>
<p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>
</blockquote>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public String add<span class="hljs-constructor">Strings(String <span class="hljs-params">num1</span>, String <span class="hljs-params">num2</span>)</span> &#123;
        StringBuilder str = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;
        <span class="hljs-built_in">int</span> carry = <span class="hljs-number">0</span>, i = num1.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>, j = num2.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (carry<span class="hljs-operator"> == </span><span class="hljs-number">1</span><span class="hljs-operator"> || </span>i &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> || </span>j &gt;= <span class="hljs-number">0</span>) &#123;
            <span class="hljs-built_in">int</span> x = i &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : num1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>--)</span> - <span class="hljs-character">&#x27;0&#x27;</span>;
            <span class="hljs-built_in">int</span> y = j &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : num2.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>--)</span> - <span class="hljs-character">&#x27;0&#x27;</span>;
            str.append((x + y + carry) % <span class="hljs-number">10</span>);
            carry = (x + y + carry)<span class="hljs-operator"> / </span><span class="hljs-number">10</span>; 
        &#125;
        return str.reverse<span class="hljs-literal">()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;
    &#125;
&#125;</code></pre>

<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h2><blockquote>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<pre><code class="hljs tap">&gt;输入: 
Tree<span class="hljs-number"> 1 </span>                    Tree<span class="hljs-number"> 2 </span>                 
        <span class="hljs-number"> 1 </span>                       <span class="hljs-number"> 2 </span>                            
        / \                       / \                            
      <span class="hljs-number"> 3 </span> <span class="hljs-number"> 2 </span>                   <span class="hljs-number"> 1 </span> <span class="hljs-number"> 3 </span>                       
      /                           \   \                      
    <span class="hljs-number"> 5 </span>                           <span class="hljs-number"> 4 </span> <span class="hljs-number"> 7 </span>                 
&gt;输出: 
&gt;合并后的树:
     3
    / \
  <span class="hljs-number"> 4 </span>  5
  / \   \ 
<span class="hljs-number"> 5 </span> <span class="hljs-number"> 4 </span>  7</code></pre>
</blockquote>
<pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;
    public TreeNode merge<span class="hljs-constructor">Trees(TreeNode <span class="hljs-params">t1</span>, TreeNode <span class="hljs-params">t2</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (t1<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>t2<span class="hljs-operator"> == </span>null) return null;
        <span class="hljs-keyword">if</span> (t1<span class="hljs-operator"> == </span>null) return t2;
        <span class="hljs-keyword">if</span> (t2<span class="hljs-operator"> == </span>null) return t1;
        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">t1</span>.<span class="hljs-params">val</span> + <span class="hljs-params">t2</span>.<span class="hljs-params">val</span>)</span>;
        root.left = merge<span class="hljs-constructor">Trees(<span class="hljs-params">t1</span>.<span class="hljs-params">left</span>, <span class="hljs-params">t2</span>.<span class="hljs-params">left</span>)</span>;
        root.right = merge<span class="hljs-constructor">Trees(<span class="hljs-params">t1</span>.<span class="hljs-params">right</span>, <span class="hljs-params">t2</span>.<span class="hljs-params">right</span>)</span>;
        return root; 
    &#125;
&#125;</code></pre>

<h2 id="86-分隔链表-367"><a href="#86-分隔链表-367" class="headerlink" title="86. 分隔链表(367)"></a>86. 分隔链表(367)</h2><blockquote>
<p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你应当 保留 两个分区中每个节点的初始相对位置。</p>
<pre><code class="hljs accesslog">&gt;输入：head = <span class="hljs-string">[1,4,3,2,5,2]</span>, x = <span class="hljs-number">3</span>
&gt;输出：<span class="hljs-string">[1,2,2,4,3,5]</span></code></pre>

<pre><code class="hljs inform7">&gt;输入：head = <span class="hljs-comment">[2,1]</span>, x = 2
&gt;输出：<span class="hljs-comment">[1,2]</span></code></pre>
</blockquote>
<pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    <span class="hljs-keyword">public</span> ListNode partition(ListNode head, <span class="hljs-built_in">int</span> x) &#123;
        ListNode dummy1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);
        ListNode dummy2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);
        ListNode node1 = dummy1, node2 = dummy2;
        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>)&#123;
            <span class="hljs-keyword">if</span> (head.val &lt; x)&#123;
                node1.<span class="hljs-keyword">next</span> = head;
                head = head.<span class="hljs-keyword">next</span>;
                node1 = node1.<span class="hljs-keyword">next</span>;
                node1.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                node2.<span class="hljs-keyword">next</span> = head;
                head = head.<span class="hljs-keyword">next</span>;
                node2 = node2.<span class="hljs-keyword">next</span>;
                node2.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;
            &#125;
        &#125;
        node1.<span class="hljs-keyword">next</span> = dummy2.<span class="hljs-keyword">next</span>;
        <span class="hljs-keyword">return</span> dummy1.<span class="hljs-keyword">next</span>;
    &#125;
&#125;</code></pre>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java%E7%9F%A5%E8%AF%86/">Java知识</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，大部分为学习心得，欢迎与博主联系讨论</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/03/22/%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">排序相关算法题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/20/DFS%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/">
                        <span class="hidden-mobile">DFS相关算法题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    
<b>此身此时此地</b>
<i class="iconfont icon-love"></i>
<b>所见所闻所想</b>

  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
