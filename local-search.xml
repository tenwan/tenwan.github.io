<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>其一</title>
    <link href="/2024/08/14/%E4%BA%8C%E5%8D%81%E5%A4%9A%E5%B9%B4%E9%83%BD%E5%9C%A8%E5%80%92%E5%B8%A6/"/>
    <url>/2024/08/14/%E4%BA%8C%E5%8D%81%E5%A4%9A%E5%B9%B4%E9%83%BD%E5%9C%A8%E5%80%92%E5%B8%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="2024-8"><a href="#2024-8" class="headerlink" title="2024.8"></a>2024.8</h1><blockquote><p>但是现在赛博光年</p><p>书信已长眠</p><p>实在</p><p>让人欢笑强颜</p></blockquote><p>又是一年七夕过，爹妈在周六前一天打电话问我第二天上不上班，试图推理出他们想看到的局面，但结果是周六真的有投产加班，我嘞个豆。</p><p>今天就随笔写一写当下的我对爱情的看法，但众所周知，写爱情就是琢磨人心，这是难度拉满的。</p><h2 id="言之何物"><a href="#言之何物" class="headerlink" title="言之何物"></a>言之何物</h2><p>​        不可否认的是，人们始终对爱情怀有天然的渴望，爱情本身未曾改变。但人们的爱情观在不同的社会建构中不断发生着变化。</p><p>​        爱情一方面是具有战略性的，关乎一个人的生活方向，价值追寻，对生命的理解等等，另一方面，它又是很具体的，是两个人共同打造一个生活，其中包含了对生活的各种安排。</p><p>​       对美好爱情的想象往往先于现实的爱情而存在，这种想象随时代不断变迁，</p><p>​        文艺作品所塑造的狭义“真爱”，当下是时候该礼貌地被请下神坛了吧。</p><p>​        你见过深情的人吗</p><p>​        就像&lt;罗密欧与朱丽叶&gt;中写的“不要指着月亮起誓，它是变化无常的，每个月都有盈亏圆缺，你要是指着它起誓，也许你的爱情也会像它一样无常”</p><p>​        ta的爱在无数个孤立无援的时刻里，变得有了计较和盘算，再也没有曾经的存粹。</p><h2 id="网络风潮"><a href="#网络风潮" class="headerlink" title="网络风潮"></a>网络风潮</h2><p>​        最近看到好几篇文章，分析经济下行时期，为什么在朋友圈秀恩爱的行为越来越少了，比如说“约会不一定转正，恋爱了可以分手，结婚了能离婚，情感生活险象环生，如果一个人贸然用一条甜蜜的朋友圈为自己盖上另外一个人名字的戳印，其风险堪比A股”</p><p>​        “我是一个寻找爱的人，真正的爱，可笑、麻烦、耗费心神、离开彼此就活不下去的那种爱”</p><p>​        </p><h2 id="听吧-爱情"><a href="#听吧-爱情" class="headerlink" title="听吧 爱情"></a>听吧 爱情</h2><p>​        或许是异域的红葡萄酒有让人敞开心扉的功效，又或许是雨夜能让人变得窝囊，会让人有了倾诉的愿望。。。。我知道我说的太多了，但此时此刻此地，我需要一个旁人来见证我怯懦的真心。</p><p>​      爱情瓦解时，人们都会尽力追问，自己经历和拥有的爱究竟是否真实，是出自欲望或自恋，还是真正的两情相悦。</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>如果不是相互的喜欢，你的穷追不舍只会是别人的负担。毕竟但凡你觉得辛苦的，都是强求。</p><blockquote><p>最后，我说我不会写诗，但这不就是独一无二的诗嘛</p><p>嘿嘿，祝时光缓缓流</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这很正常的吧</title>
    <link href="/2024/08/13/%E8%BF%99%E5%BE%88%E6%AD%A3%E5%B8%B8%E7%9A%84%E5%90%A7/"/>
    <url>/2024/08/13/%E8%BF%99%E5%BE%88%E6%AD%A3%E5%B8%B8%E7%9A%84%E5%90%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="我在街上找绝句"><a href="#我在街上找绝句" class="headerlink" title="我在街上找绝句"></a>我在街上找绝句</h1><blockquote><p>最近想开个长文，就随缘记录一些让人尬住的句子，嘿嘿，标题也是走路上一怕脑袋想到的，多浪漫啊，只不过，应该很容易被人猜到某一阶段喜欢的文风了，我要杀死浪漫杀死诗，哈哈哈哈哈哈哈哈</p></blockquote><h2 id="《读库》"><a href="#《读库》" class="headerlink" title="《读库》"></a>《读库》</h2><ul><li><p>人生是一连串的刹那，幸福体验也只和当下相关。更多时都在为沉溺与奶头乐焦虑，好不容易得来的幸福，又被自家主观清空，常常陷入否定与非的幸福漩涡。</p></li><li><p>大多数路径在执行的过程中毫无快乐可言。</p></li><li><p>所谓的高级与低级本身，就是人为定义的。</p></li><li><p>在过去，我们的人生典型模板过于稳定，以至于绝大多数人都遵循典型模板来判断构建自己的幸福生活，对于大多数青年来说，这个模板包括但不限于：</p><ul><li>拼命求学至少到本科</li><li>搭上金融或互联网等高增长行业的便车</li><li>在全国GDP前十的城市购置一套住宅（北上广深重苏成杭南武）</li><li>在三十到三十五岁之间结婚并生子</li><li>每年有足够的时间进行一到两次境内外旅行</li><li>努力过上具有一定购买力的“中产生活”</li></ul><p>但是啊，大框架下，很多人生任务是没有deadline的，甚至都不是必选项。</p></li><li><p>局部战争的多点爆发、通用人工智能的高歌猛进、国家之间的相互制衡。</p></li><li><p>打卡就是做一天和尚撞一天钟。</p></li><li><p>模板化生活的快乐，会破坏体验过程的机会，破坏生活的快乐本身。比如刻板的炫耀拍照，会让快乐简化为购买和分享的两个行为，你本可以享受旅行、享受咖啡、享受潜水，享受江上清分，水中明月，但是若只是为了发朋友圈，而白白浪费了很多时间，那就只获得了一种快乐–发朋友圈的快乐。虽然也是快乐，虽然也是快乐，但可能会感到可惜。（说实话，这段，我觉得，还是看人的选择，有人想记录这一刻，后来再度翻开照片，也许会持续快乐，掉入时间的风景里，就是说，还是看自己喽）</p></li><li><p>人生的美好体验来自于当下的细节本身，它们是由无数个早餐、午餐、晚餐（干饭人狂喜）、睡眠、夕阳、晚风、细雨、欢聚、离别、小酌与谈心等具体的细节构成，而不是来自与其他细节（他人、过去或未来）的比较。</p></li><li><p>持续创作本身就是一个巨大的困难。</p></li><li><p>中产阶级的几大创业梦想是书店、咖啡店、花房和蛋糕店，但是很明显，每个选项都是中产返贫的快速通道。</p></li><li><p>如果你本身就热爱表达，就不会因为写的东西没人看而停止写作。</p></li><li></li></ul><h2 id="《生鲜》"><a href="#《生鲜》" class="headerlink" title="《生鲜》"></a>《生鲜》</h2><h2 id="《》"><a href="#《》" class="headerlink" title="《》"></a>《》</h2>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对每一种别样的人生际遇都有同理心</title>
    <link href="/2023/12/24/%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/12/24/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="对每一种别样的人生际遇都有同理心"><a href="#对每一种别样的人生际遇都有同理心" class="headerlink" title="对每一种别样的人生际遇都有同理心"></a>对每一种别样的人生际遇都有同理心</h1><p>记录一下最近的一些灵光一闪或是一些在网上看到的只言片语：</p><ul><li>山阻石拦，大江必定东流去；雪辱风欺，桃花依旧向日红。</li><li>你以为你知道整个故事，其实，你知道的，不过是结局。</li><li>不愿再起波澜。</li><li>人和人的自我认值不同，底线各有松紧，自我保护的空间也就不一样，这些认知在很大程度上是被我们的经验所塑造的。</li><li>做一场梦人会醒，下一场雨也会停。</li><li>放晴时，也当盛赞一句，天色正好。</li><li>在一个不断加速的世界中，要如何在个体层面找到一个可执行的、幸福的、不被内卷的人生框架，也可算作一个终极课题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当我在玩游戏时，我在想什么</title>
    <link href="/2023/08/13/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/"/>
    <url>/2023/08/13/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏漫谈"><a href="#游戏漫谈" class="headerlink" title="游戏漫谈"></a>游戏漫谈</h1><blockquote><p>最近由虚无联想到人的一生是不是很多事情做与不做都没有很大的区别，比如绘画、写作、看书、游戏、玩乐器、做科研、敲代码，这些都可能都不过是漫长人生中打发无聊时光的一点乐子事，既然如此，为什么他们还会有优劣高雅低俗之分呢?为何提起游戏，大多都是叹息、玩物丧志、肥宅、颓废之类的联想，下面是自己对此浅薄思考的观点。</p></blockquote><p>​        我从小就很喜欢玩游戏。</p><p>​        从六七岁时的小霸王游戏机开始，就开始接触魂斗罗、超级玛丽、冒险岛等等，后来到了小学二三年级，家里购买了第一台电脑，便开启了我的网游时代，细数那些年玩过的游戏，包括传奇、qq堂、流星蝴蝶剑、梦幻西游、赛尔号、功夫派等等贯穿我学生时期的作品。</p><p>​        游戏给人的几个谎言：</p><ul><li>游戏让人有成就感和快乐</li><li>游戏让人放松，忘记一天的疲惫</li><li>游戏让人忘记烦恼</li></ul><p>​        生活艰辛，各人的烦恼都不尽相同，但都有正确的解决之道，如果选择用游戏来麻痹自己，与买醉无异。</p><p>​        </p><h2 id="终章"><a href="#终章" class="headerlink" title="终章"></a>终章</h2><p>​        游戏只是计算机领域中一块小小的领地，其之外还有更广阔的天地可以去探索。</p><p>​        我始终认为我们可以回头看，但是不能回头走了，感叹“过去蹉跎岁月之多”，才显得今日弥足珍贵。</p><p>​        ”我要的并不在这里，你给的答案没意义！“</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好久不见，又是新年</title>
    <link href="/2022/12/31/%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81%EF%BC%8C%E5%8F%88%E6%98%AF%E6%96%B0%E5%B9%B4/"/>
    <url>/2022/12/31/%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81%EF%BC%8C%E5%8F%88%E6%98%AF%E6%96%B0%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="好久不见，又是新年"><a href="#好久不见，又是新年" class="headerlink" title="好久不见，又是新年"></a>好久不见，又是新年</h2><p>随着疫情防控政策的放开，马上又要迎来2023年了，今年博客写的少了，但感觉年末应该要发一篇。其实，进入12月就开始着手写年终总结，期待为2022年画上句号。回顾一整年的经历，今年算是人生路上比较重要的一年了，但因为各种拖延，博客更新得并不多，可以说是寥寥了。可以把2022年的年中作为一个分水岭，前半年的学生加上后半年的打工人阶段，但我觉得还是可以用八个字来概括2022的主题，即“千岩竞秀，万壑争流”，那么还是按照往年的总结来梳理一下2022吧。</p><h2 id="关于读书"><a href="#关于读书" class="headerlink" title="关于读书"></a>关于读书</h2><p>今年还是按照往年一样预定了读库的M计划，但是零散的买书已经少了很多了，买的漫画书倒是变多了，还是慢慢看库存吧，记录一下看过还算有印象的吧。</p><ul><li><p>《一句顶一万句》–年初关注到刘震云后开始看的书，但是并没有看完。故事中的人物都给人一种宿命的交错感，故事中的人来来往往，误会却难以解开，不断的找人只为证明一件无足轻重的小事。让人印象深刻的还是很多售卖宣传中标出的一句话，“人是活以后不是活以前”，时过境迁，何必再问故事里的人最后结局圆不圆满。</p></li><li><p>《二十五种营生》–讲述的是作者的家史，父亲这一辈子为了担起家庭的重担，从种菜开始，辗转到以清洁工结束，大概从事了二十五种专业，生活的没有保障和充满变数并没有改变父亲勤劳善良的本性。作者最后这样概括父亲的一生：“一个农民，没多少文化，没有背景，靠自己赤手空拳在社会上打拼，对上孝顺父母，对亲戚朋友能帮就帮，没坑过人，没借过钱，对下三个孩子两个孩子上了大学，一个上了中专，都有稳定工作，最后甚至在老家一座平房，县城一套单元房，七十六岁了还能自立，还要他怎样呢？”，通过这些带有年代感的文字描述让我才后知后觉地明白父亲说过的人要有担当的简单大道理。</p></li><li><p>《在细雨中呼喊》–这是年中时候在学校毕业跳蚤市场上淘到的书，三五块一本淘到了好些书。余华今年算是又大火了起来，上次看余老师的作品还是《许三观卖血记》，与许三观不同，细雨中孙光林的成长有一种孤独感贯穿始终，从被寄养到被送回，和家人总有一种疏离感，淡如水的亲情本就够凉薄了，为了合群，主动去巴结人缘最好的同学，却又被同学欺辱，行为背后的原因只是为了向大家证明”你真好骗“的玩笑事实。没有什么比在细雨中的呼喊却得不到回应更让人感到孤寂的事情了。总结起来可以说，我看过一个故事，故事中有一个自卑又孤独无助的少年，在细雨中呼喊亲情，呼喊友情，呼喊一切可以给自己慰藉的温暖，但只有淅淅沥沥、淅淅沥沥。</p></li><li><p>《重读20世纪中国小说》–理想国出版的对近现代中国小说史梳理的工具书，读100年的小说，看100年的中国。属实是属于大部头作品了，当工具书使用吧。</p></li><li><p>《五个光子》–由天体物理学博士撰写的关于宇宙的科普书，涉及专业术语众多，没太看懂，可能理解宇宙的浪漫所需要的门槛太高吧。</p></li><li><p>《关于地球的运动》–算是今年看过的惊喜之作了，虽然是漫画书，但是我觉得故事讲得很深刻。当面对权威的错误知识宣扬时，你会选择轻松奉承生活顺风顺水，还是会选择哪怕付出生命代价也要捍卫真理。故事设定在教会存在且拥趸”地心说“学说的时代，可是学说终究是学说，归根到底是学者们对于现状的自我解释，局限性注定了其可能根本和终极答案相差甚远，而当出现另一波渴望洞察真实的学者来对学说进行更正时，他们可能会受到迫害，虽然他们在面对死亡的恐惧时也会感到战栗，还是将自己所研究的东西化为文字传承下来，做到”朝闻道，夕死可矣“。对比很多人看完后对于天文学的卫道行为的感动，我最大的感触还是文字可真是厉害的东西，其可以跨越时间和地点，让我们可以为百年前的故事感动到热泪盈眶，也可以为千年前的流言传播而大笑不止，有了可以将信息长久保存的文字，思想、知识和经验的传播才成为可能！</p></li><li><p>《》。。。还有一些看了没写的，还有好多买了没看的，来年再说吧，嘻嘻。</p><p><img src="/img/2022_1.png" alt="买书如山倒，看书如抽丝"> </p><p><img src="/img/2022_2.png" alt="漫画书一瞥"> </p><p><img src="/img/2022_3.png" alt="漫画书两瞥"> </p></li></ul><h2 id="关于写字"><a href="#关于写字" class="headerlink" title="关于写字"></a>关于写字</h2><p>翻开记事本，今年还是有许多灵光一闪的只言片语记录其中。</p><ul><li>诗是公开的隐藏。</li><li>名不显时心不朽，再挑灯火看文章。</li><li>美玉虽好，不及顽石。</li><li>行有不得，反求诸己。</li><li>南阳诸葛庐，西蜀子云亭。</li><li>寻穷天下无名水，历遍人间不到山。</li><li>知不可乎骤得，托遗响于悲风。</li><li>人就是这样，有想做却不能做的事，有能做但不愿意做的事。</li><li>最荒唐动机搞最大新闻原则</li><li>本心变得矛盾，但人生却开始向阳。</li></ul><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>入职后，经过一系列的入职培训和一段时间的进组工作，上周算是完成了试用期的转正答辩，这半年来因为疫情原因，居家和到公司时间掺半吧，中间还到网点学习了一个月业务，起初还有些排斥，但现在觉得开发和业务也确实不能分家，很多业务细节真的只有学习过才能理解，现在疫情防控逐步放开了，希望明年各项工作都能按部就班得进入正轨吧。之前还想做一个每天下班后拍一拍黄鹤楼的视频，但断断续续的各种原因搁置了这个计划，就拍了一下那天整个办公室只有我一个人到现场上班的黄鹤楼，便可以说，自入职以来，我便一个人孤独地照顾着历天的黄鹤楼喽，哈哈哈哈。</p><p><img src="/img/2022_04.png" alt="这是哪天的楼呢？"> </p><h2 id="关于一些更有趣的总结"><a href="#关于一些更有趣的总结" class="headerlink" title="关于一些更有趣的总结"></a>关于一些更有趣的总结</h2><p>年底了，还有一些奇奇怪怪的软件也会帮我们总结，我也选取了一些今年好玩的。</p><p>首先是音乐上，网易云总结的很好，但是今年还是没有升到十级，到十级竟然还差1w首歌，还不算重复的，估计到了都不知道今夕是何年了。</p><p>自己每年的年度歌手都不一样，今年稍不注意就变成了大风，可能是之前做毕设时候，听《请仙》听多了吧，所谓人靠着山它就是仙咧。</p><p><img src="/img/2022_5.PNG" alt="我从不过度解读"> </p><p>然后是关于游戏，今年王国之泪又跳票了，去年预定的商家把钱都退回来了，希望老任明年能正常上线吧。年初跟风体验了今年的年度游戏–艾尔登法环，但当时觉得魂类游戏还是难就没入手，到暑假时尝试捡起入坑了一下，真的上手还是有难度，但是画面确实是震撼和美的，之后有时间再慢慢推吧。不过看到steam年度总结时，还是感觉被背刺了一下。</p><p>”我，艾尔登之王，交界地的王者，黄金律法传承人，没有朋友，王总是孤独的~“。</p><p><img src="/img/2022_6.JPG" alt="我没有朋友，我玩游戏，呜呜呜呜"> </p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote><p>经典复刻每年的总结</p></blockquote><p>时间来到了26岁，看事情未必比两年前更加清楚，迷茫和无助的感觉依旧存在但有所减弱，已经过了青春的尾巴，步入打工人的阶段，还是对未来充满好奇，今年是”千岩竞秀，万壑争流“，那么明年呢？哈哈，畅想一下，新的一年，会遇到什么样的人，会发生什么样的事呢？</p><blockquote><p>人不但会长大，而且会变老。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三月近况</title>
    <link href="/2022/04/08/%E4%B8%89%E6%9C%88%E8%BF%91%E5%86%B5/"/>
    <url>/2022/04/08/%E4%B8%89%E6%9C%88%E8%BF%91%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="三月近况"><a href="#三月近况" class="headerlink" title="三月近况"></a>三月近况</h1><blockquote><p>返校后折腾近一个月，终于将毕业论文完成了。看到别人致谢里面的话，什么“时至今日，我才知，读研竟是逆天而行”，自己也有诸多感怀，在写作期间，也有很多自我鼓励的话不断蹦出。下面就常规的开始罗列。</p></blockquote><ul><li>以前别人总问我，上班累还是上学累，我一直不知道怎么回答，直到我遇到一帮工人卸货，他们擦着汗，有说有笑，不停地搬运来回。我突然知道：不快乐才是最累的。</li><li>你的人生理想是什么？是达则兼济天下，穷则独善其身？这是封建思想残余。正确答案应该是追求真善美。(笑)</li><li>漫步倦游</li><li>在蓝天阔野中奔跑，在碧波白浪中遨游。</li><li>如果要对来生进行好运设计，会是怎样呢？生在穷乡僻壤，有孤陋寡闻之虞，不好；生在贵府名门，又有骄狂愚妄之险，也不好。需要介于这两者中间的位置上，既知晓人类文明的丰富璀璨，又懂得生命路途的坎坷艰难。既了解达官显贵奢华而庄严的生活，又体会平民百姓清贫而深情的岁月。既有博览群书并入学府深造的机缘，又有浪迹天涯独自在社会上闯荡的经历。既能在关键时刻得良师指点如有神助，又时时事事能靠自己努力奋斗而绝非平步青云。既饱尝过人情友爱的美好，又深知世态炎凉的正常，就像罗曼罗兰所说，看清了这个世界，而后爱它。</li><li>因难度而少有人问津的主题，这世界比比皆是，一代又一代的人生生灭灭，留给世界和后人的永远是谜团吗？</li><li>未来藏在迷雾之中，叫人心生胆怯，但当你踏足其中，就会云开雾散。</li><li>高中那会还有写周记的习惯，翻看旧纸，能看到许多早已被遗忘的蠢事。我很喜欢回忆的感觉，倒不是说现在过得不如从前，而是单纯念旧。</li><li>那时天真无知，觉得以青春和健康换取功名利禄也算公平。金融是跨时间和跨空间的价值交换或资源配置。货币解决了价值跨时间的存储以及跨空间的移置问题。</li><li>人很容易陷入无聊，尤其是还没有找到自己在这个世界上的使命的时候。</li><li>梦里探讨完所有论点后睁眼，发现不过凌晨一点。</li><li>最好金龟换酒，泛若不系之舟。</li><li>现在所有人发朋友圈，其实内心都是在经过计算后发布，你大概会设想一下，发布这个会不会有人看了之后骂我，还是我发了之后会有哪些人点赞，再筛选自己哪个发哪个不发，如何选择措辞以及选择哪张照片，好多事情都流于算计。</li><li>之前一直以为因心理压力大到崩溃都是微博热搜上的话题，到自己身边同学时才发现人人压力都那么大，平时很正常的人会瞬间歇斯底里，某些时刻很多东西会想的很模糊，大道理都不清晰，情绪是一瞬间的。还是要对自己多加暗示，生活的目标从来都不是学业，爱情，工作，而追逐快乐才是生命真谛。</li></ul><blockquote><p>送审后的第一周就开始读了傅真的《藏地白皮书》、《最好金龟换酒》、《泛若不系之舟》三本书。其中泛若还被理解为繁弱，自己才发现繁弱其名为中国古代神话一把弓的名字。</p></blockquote><p>未完待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给一年前自己的一封信-2022</title>
    <link href="/2021/12/31/%E7%BB%99%E4%B8%80%E5%B9%B4%E5%89%8D%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1-2022/"/>
    <url>/2021/12/31/%E7%BB%99%E4%B8%80%E5%B9%B4%E5%89%8D%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1-2022/</url>
    
    <content type="html"><![CDATA[<p>乐同学，你好，展信佳。</p><p>见字如面。</p><p>当你看到这封信时，时间已经来到2022年，距离你下一次写年度总结还有一年的时间。在写这封信时，我也翻看了你2021年的flag，这一年来还是有些天真，将少扯淡多学习都抛诸脑后。也就是说，这长长的一整年，你非但没有少摸鱼少扯淡，更是没有多学习，不过放轻松，至少你的学生时代已经快接近尾声了，“好男儿，一生要志在四方”的雄心壮志又燃烧起来啦！</p><h3 id="关于读书"><a href="#关于读书" class="headerlink" title="关于读书"></a>关于读书</h3><p>你知道你年初在博客开了一个2021年阅读计划，计划似乎当时做的很完备，但到后面执行起来，找工作背面经自顾无暇时，各种借口就张口就来了，执行质量也开始大打折扣。现在看来，计划中的体量至少还应缩减三分之一，如果你今年想完成目标的话。</p><p>另外，买书也不可如山倒了，2020年双十一趁着打折采购一批，加上自己在百草园书店摸黑淘出的一堆，至少还有一半还没翻开呢，也要记住，下次买书回来，一定不要先把塑料封皮拆了，等什么时候想看再拆也不迟，不然送人或出掉都太不方便了，会落灰。</p><p>不过你2021年双十一竟然忍住了没有买书，是不是还感觉有些遗憾。</p><p>然后你在双十二加倍购买，还一股脑寄回家中了，直到年终一本没见。</p><p>这一年你也学会自己在论坛淘一些免费的电子书资源，也尝试把它们开源分享，不过还是感觉看电子书和纸质书有区别，说起来曾经关注的读库，他们从今年也开始有自己的应用了，感觉也在迎合大众电子化的潮流，从前说的做到在地铁上看见大家拿出读库小开本阅读的场景，你也从没见到过，明年或许能看见手机刷读库的场景了吧。</p><h3 id="关于写字"><a href="#关于写字" class="headerlink" title="关于写字"></a>关于写字</h3><p>这一年，为了找工作，你发了很多篇技术博客，并自己总结了自己接近5w字的面经，焦虑的暑假，你也想不到面经竟然自己能手打出那么多字，你也感觉自己的盲打速度和准确度也快了许多，哈哈，这一点也能加入自己这一年学会的技能吧。</p><p>这一年，你把微信置顶换成了：我决定写一本书，写什么内容还没想好。年中，竟然有朋友提起，你也没想到竟然还有人会看别人的微信置顶，这倒是意外，不过朋友玩笑说不如写小说，你想起自己匮乏的想象力，还需要更多生活的体验。</p><p>这一年，你偶尔也会写备忘录，那是生活的碎片和某一瞬的灵感迸发，不过大多数情况都是词不尽意，你也看到了他人爱情更多美好的一面，对未来保持期待，期待双手摸到红线，就要抓住姻缘的那一天到来。</p><p>备忘录中自我感觉良好的金句可太多了，嘿嘿！</p><ul><li>我们所谈论的，是无聊人生的乐趣，是一段自己平凡生活中拿得出手的故事。</li><li>只要你心里的念是真的，高山大海都会给你让路。</li><li>你要知道，通过展示自己读书多，懂得多，见识多而得到的首肯和倾慕，既不值钱也不长久。</li><li>我生活在一种妙不可言的等待中，等待着可能富贵滔天的那一天。</li><li>中华谚语有言：千日造船，一日过江。</li></ul><h3 id="关于技能"><a href="#关于技能" class="headerlink" title="关于技能"></a>关于技能</h3><p>这一年你为了找工作，又重新拿起了自己区块链的毕设，算是作为应付各种面试展示自己的一个谈资，感觉没有了做毕设时候的那种窘迫感，似乎有更多的细节当时应该考虑到，不过系统级别的毕设对你再没有从前那种焦头烂额的情况了。</p><p>你也有机会尝试了更多其他方面的技能，从拍vlog到剪视频，不过飞无人机在这一年还是你心里的一个小小遗憾。更值得高兴的是，借着学校游泳馆新开的东方，你克服了从前对水的恐惧，已经有些喜欢去体育馆泡着了，这一点是值得保持。</p><p>心态方面，终于克服debug时容易急躁的毛病，现在面对深度学习几十行飘红字体，也能面不改色心不跳了。</p><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>你知道，无论选择哪条路，多年后回头再看，都会觉得后悔。因为你可以回头看，但是已经没有办法往回走了。没有人能算到另一条路的具体光景，总有让你纠结的选择，你暂时选择了ABC，笑说进行一个平的躺。</p><h3 id="更大的世界，更有趣的人"><a href="#更大的世界，更有趣的人" class="headerlink" title="更大的世界，更有趣的人"></a>更大的世界，更有趣的人</h3><p>这一年，因为找工作，蹭会议等原因，你的微信又多了形形色色的人，也看到了自己从没有接触过的圈子，我站在一年后的节点上依旧没法给你太好的建议，只能说感受世界的参差，做好自己就行。其实一涉及到人与人之间的事，问题难免会变得稍微复杂，自己还是有一些感受的。你知道了：</p><ul><li>推己及人，自己做起来已经感觉有难度的事情就不要对他人抱太大的希望了</li><li>承诺这种事情还是要小心，任何事情都不要随便答应，答应了就尽力去做。</li><li>生活需要独当一面，大多数情况你不是一个人在战斗，但也有不少情况你就是一个人在战斗。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>时间来到了25岁，看事情未必比前两年更加清楚，迷茫和无助的感觉依旧存在，只是反应更加麻木，越是接近青春的尾巴，就对越多的事情感到无动于衷，但也仍就对未来充满好奇。哈哈，畅想一下，新的一年，会遇到什么样的人，会发生什么样的事呢。</p><blockquote><p>人生长恨如流水，更复鲸吸似饮浆。</p><p>二十四年皆幻影，而今应作如是观。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年计划了解和学习的技术</title>
    <link href="/2021/11/14/2022%E5%B9%B4%E8%AE%A1%E5%88%92%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    <url>/2021/11/14/2022%E5%B9%B4%E8%AE%A1%E5%88%92%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li>学习配置、构建、推送镜像</li><li>学习K8s相关</li><li>熟悉linux常用命令以及Vim的常用快捷键</li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>TailwindCSS框架：学习tailwind搭建一个静态网页</li><li>Nest.js:Node的后端框架，支持Typescript、面向切面编程、高并发、异步非阻塞IO、Node.js版的spring，可构建微服务</li><li>esbuild：前端打包工具，学习基本配置，写入门笔记</li><li>Svelte前端框架：学习结合TailwindCSS搭建一个静态网页</li></ul><h3 id="有时间玩的"><a href="#有时间玩的" class="headerlink" title="有时间玩的"></a>有时间玩的</h3><ul><li>库乐队（GarageBand）：音乐DIY，学习编曲，音频剪辑</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给一年前自己的一封信-2022</title>
    <link href="/2021/11/11/%E8%AF%8D%E4%B8%8D%E5%B0%BD%E6%84%8F/"/>
    <url>/2021/11/11/%E8%AF%8D%E4%B8%8D%E5%B0%BD%E6%84%8F/</url>
    
    <content type="html"><![CDATA[<p>乐同学，你好，展信佳。</p><p>见字如面。</p><p>当你看到这封信时，时间已经来到2022年，距离你下一次写年度总结还有一年的时间。在写这封信时，我也翻看了你2021年的flag，这一年来还是有些天真，将少扯淡多学习都抛诸脑后。也就是说，这长长的一整年，你非但没有少摸鱼少扯淡，更是没有多学习，不过放轻松，至少你的学生时代已经快接近尾声了，“好男儿，一生要志在四方”的雄心壮志又燃烧起来啦！</p><h3 id="关于读书"><a href="#关于读书" class="headerlink" title="关于读书"></a>关于读书</h3><p>你知道你年初在博客开了一个2021年阅读计划，计划似乎当时做的很完备，但到后面执行起来，找工作背面经自顾无暇时，各种借口就张口就来了，执行质量也开始大打折扣。现在看来，计划中的体量至少还应缩减三分之一，如果你今年想完成目标的话。</p><p>另外，买书也不可如山倒了，2020年双十一趁着打折采购一批，加上自己在百草园书店摸黑淘出的一堆，至少还有一半还没翻开呢，也要记住，下次买书回来，一定不要先把塑料封皮拆了，等什么时候想看再拆也不迟，不然送人或出掉都太不方便了，会落灰。</p><p>不过你2021年双十一竟然忍住了没有买书，是不是还感觉有些遗憾。</p><p>然后你在双十二加倍购买，还一股脑寄回家中了，知道年终一本没见。</p><p>这一年你也学会自己在论坛淘一些免费的电子书资源，也尝试把它们开源分享，不过还是感觉看电子书和纸质书有区别，说起来曾经关注的读库，他们从今年也开始有自己的应用了，感觉也在迎合大众电子化的潮流，从前说的做到在地铁上看见大家拿出读库小开本阅读的场景，你也从没见到过，明年或许能看见手机刷读库的场景了吧。</p><h3 id="关于写字"><a href="#关于写字" class="headerlink" title="关于写字"></a>关于写字</h3><p>这一年，为了找工作，你发了很多篇技术博客，并自己总结了自己接近5w字的面经，焦虑的暑假，你也想不到面经竟然自己能手打出那么多字，你也感觉自己的盲打速度和准确度也快了许多，哈哈，这一点也能加入自己这一年学会的技能吧。</p><p>这一年，你把微信置顶换成了：我决定写一本书，写什么内容还没想好。年中，竟然有朋友提起，你也没想到竟然还有人会看别人的微信置顶，这倒是意外，不过朋友玩笑说不如写小说，你想起自己匮乏的想象力，还需要更多生活的体验。</p><p>这一年，你偶尔也会写备忘录，那是生活的碎片和某一瞬的灵感迸发，不过大多数情况都是词不尽意，你也看到了他人爱情更多美好的一面，对未来保持期待，期待双手摸到红线，就要抓住姻缘的那一天到来。</p><p>备忘录中自我感觉良好的金句可太多了，嘿嘿！</p><ul><li>我们所谈论的，是无聊人生的乐趣，是一段自己平凡生活中拿得出手的故事。</li><li>只要你心里的念是真的，高山大海都会给你让路。</li><li>你要知道，通过展示自己读书多，懂得多，见识多而得到的首肯和倾慕，既不值钱也不长久。</li><li>我生活在一种妙不可言的等待中，等待着可能富贵滔天的那一天。</li><li>中华谚语有言：千日造船，一日过江。</li></ul><h3 id="关于技能"><a href="#关于技能" class="headerlink" title="关于技能"></a>关于技能</h3><p>这一年你为了找工作，又重新拿起了自己区块链的毕设，算是作为应付各种面试展示自己的一个谈资，感觉没有了做毕设时候的那种窘迫感，似乎有更多的细节当时应该考虑到，不过系统级别的毕设对你再没有从前那种焦头烂额的情况了。</p><p>你也有机会尝试了更多其他方面的技能，从拍vlog到剪视频，不过飞无人机在这一年还是你心里的一个小小遗憾。更值得高兴的是，借着学校游泳馆新开的东方，你克服了从前对水的恐惧，已经有些喜欢去体育馆泡着了，这一点是值得保持。</p><p>心态方面，终于克服debug时容易急躁的毛病，现在面对深度学习几十行飘红字体，也能面不改色心不跳了。</p><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>你知道，无论选择哪条路，多年后回头再看，都会觉得后悔。因为你可以回头看，但是已经没有办法往回走了。没有人能算到另一条路的具体光景，总有让你纠结的选择，你暂时选择了ABC，笑说进行一个平的躺。</p><h3 id="更大的世界，更有趣的人"><a href="#更大的世界，更有趣的人" class="headerlink" title="更大的世界，更有趣的人"></a>更大的世界，更有趣的人</h3><p>这一年，因为找工作，蹭会议等原因，你的微信又多了形形色色的人，也看到了自己从没有接触过的圈子，我站在一年后的节点上依旧没法给你太好的建议，只能说感受世界的参差，做好自己就行。其实一涉及到人与人之间的事，问题难免会变得稍微复杂，自己还是有一些感受的。你知道了：</p><ul><li>推己及人，自己做起来已经感觉有难度的事情就不要对他人抱太大的希望了</li><li>承诺这种事情还是要小心，任何事情都不要随便答应，答应了就尽力去做。</li><li>生活需要独当一面，大多数情况你不是一个人在战斗，但也有不少情况你就是一个人在战斗。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>时间来到了25岁，看事情未必比前两年更加清楚，迷茫和无助的感觉依旧存在，只是反应更加麻木，越是接近青春的尾巴，就对越多的事情感到无动于衷，但也仍就对未来充满好奇。哈哈，畅想一下，新的一年，会遇到什么样的人，会发生什么样的事呢。</p><blockquote><p>人生长恨如流水，更复鲸吸似饮浆。</p><p>二十四年皆幻影，而今应作如是观。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>九月近况</title>
    <link href="/2021/09/14/%E4%B9%9D%E6%9C%88%E8%BF%91%E5%86%B5/"/>
    <url>/2021/09/14/%E4%B9%9D%E6%9C%88%E8%BF%91%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="九月近况"><a href="#九月近况" class="headerlink" title="九月近况"></a>九月近况</h1><blockquote><p>折腾近两个月，终于拿到了第一个offer，相比三四月份的焦虑情况，目前缓解不少，最近脑子里也一直笃定：一饮一啄，莫非前定；兰因絮果，必有来因。剩下的心态就是全方位将心态放入小论文的完成了。</p></blockquote><p>下面是近几个月我备忘录上的摘要：</p><ul><li>他尤其喜欢这样深夜的武汉，灯火依旧连绵不绝，但是大部分人都已归于梦乡。</li><li>站在书脊上，飞跃这围墙。</li><li>生活中有困苦，也有困苦中的快乐；人们有诸多不便，也一直在追求更好的生活，我要做的，就是尽量去做一个快乐，生动的人，尽情拥抱这个城市，尽量拥抱这忙碌的人来人往。</li><li>辗转于世界各地的街道路口</li><li>千日造船，一日过江。</li><li>对科技的看法，乐天派赞颂科技对人类的提升，悲观派着眼于科技对个体的异化。</li><li>我仿佛已经很老了，又好像很年轻，革命时期好像过去了，又仿佛还没开始，爱情仿佛结束了，又好像还没到来，我仿佛中了头彩，又好像还没到开彩的日子。这一切好像是结束了，又仿佛是刚刚开始。</li><li>人活在世界上，快乐与痛苦本就分不清楚，所以我只求它货真价实。</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的锁</title>
    <link href="/2021/07/09/Java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <url>/2021/07/09/Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h1><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><h3 id="Volatile实现原理"><a href="#Volatile实现原理" class="headerlink" title="Volatile实现原理"></a>Volatile实现原理</h3><p>在有volatile变量修饰的共享变量进行写操作时汇编会多出下行代码：</p><pre><code class="hljs apache"><span class="hljs-attribute">0x01a3de24</span>: lock add<span class="hljs-number">1</span> $<span class="hljs-number">0</span>×<span class="hljs-number">0</span>,(%esp)</code></pre><p>lock前缀的指令在多核处理器中会引发两件事情：</p><ul><li><strong>将当前处理器缓存行的数据写回到系统内存。</strong></li><li><strong>写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</strong></li></ul><h3 id="Volatile内存语义"><a href="#Volatile内存语义" class="headerlink" title="Volatile内存语义"></a>Volatile内存语义</h3><p>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h3><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><ul><li>JVM基于进入和退出Monitor对象来实现同步和代码块同步。代码块同步是使用monitorenter和monitorexit来实现的，而方法同步是使用另外一种方法来实现的，细节在JVM规范中没有说明。但方法同步依旧可以用这两个指令实现。</li><li>当JVM执行引擎执行某一个方法时，其会从方法区中获取该方法的access_flags，检查其是否有ACC_SYNCRHONIZED标识符，若是有该标识符，则说明当前方法是同步方法，需要先获取当前对象的monitor，再来执行方法。</li><li>monitorenter指令插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处。JVM保证每个monitorenter都有对应的monitorexit与之配对。任何一个对象都有一个monitor与之关联，当一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。若获取失败，那么线程将会进入同步队列(SynchronizedQueue),在正在占有monitor的线程离开监视器后，将会通知在同步队列中的线程获取锁。</li><li><strong>优点</strong>：线程竞争不使用自旋，不会消耗CPU。</li><li><strong>缺点</strong>：线程阻塞，通过唤醒的方式来提醒其他线程，响应速度缓慢。</li></ul><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><ul><li>大多情况下，锁不仅不存在多线程竞争，而且总是由同一个线程获得。那么为了获取锁和是释放锁而频繁地进行CAS操作将会显得浪费资源。</li><li>偏向锁在对象头中可以储存线程的ID，以后在进入后退出同步块的时候就只需要比对对象头中的Mark Word中是否储存着当前线程的偏向锁，如果测试成功，就表示线程已经获得了锁。则检测是否为偏向锁，若不是则使用CAS竞争锁；如果是偏向锁，则尝试使用CAS将对象头的偏向锁指向当前线程。</li><li>偏向锁的撤销<ul><li>偏向锁在遇到竞争时才会撤销</li><li>撤销时，它会先暂停持有锁的线程，然后检测线程是否处于活动状态。</li><li>若是不处于活动状态，则将对象头设为无锁状态。前来竞争的线程获取锁，使用CAS将偏向锁ID替换为自己的。（此时依旧是偏向锁）</li><li>如果线程还活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。（此时偏向锁考虑升级为轻量级锁）</li></ul></li><li>需要注意的是，偏向锁适用于同步块在一个时间段内只被一个线程使用的情况，用于减少获得锁和释放锁的CAS操作，属于<strong>乐观锁</strong>。若是存在竞争，由于偏向锁的撤销会发生STW操作，将会使效率大大降低。</li><li><strong>优点</strong>：加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距。</li><li><strong>缺点</strong>：如果存在锁竞争，将会带来额外的锁撤销的消耗。</li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><ul><li><strong>加锁</strong>：线程在执行同步块之前，JVM会在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁。如果失败，表示其他线程竞争锁，当前线程尝试使用自旋来获取锁。</li><li><strong>解锁</strong>：使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。一旦膨胀为重量级锁，将不再恢复到轻量级锁状态。锁膨胀后，持有锁的线程在释放锁并唤醒竞争的线程，进行新一轮的夺锁。</li><li><strong>优点</strong>：竞争的线程不会阻塞，提高程序的响应速度。</li><li><strong>缺点</strong>：始终得不到锁竞争的线程，使用自旋将会消耗CPU</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="ReentrantLock的加锁和解锁原理"><a href="#ReentrantLock的加锁和解锁原理" class="headerlink" title="ReentrantLock的加锁和解锁原理"></a>ReentrantLock的加锁和解锁原理</h1><p>ReentrantLock的实现依赖于Java同步器框架AQS。AQS使用一个整型的volatile变量(命名为state)来维护同步状态。ReentrantLock分为公平锁和非公平锁。</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>使用公平锁时，加锁方法<code>lock()</code>的调用轨迹：</p><ol><li>ReentrantLock：lock()</li><li>FairSync：lock()</li><li>AbstractQueuedSynchronizer：acquire(int arg)</li><li>ReentrantLock:tryAcquire(int acquires)</li></ol><p>从第4步开始加锁，源码如下：</p><pre><code class="hljs reasonml">protected final boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">int</span> <span class="hljs-params">acquires</span>)</span> &#123;            <span class="hljs-comment">//获取当前线程</span>            final Thread current = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>;            <span class="hljs-comment">//通过AQS获取同步状态</span>            <span class="hljs-built_in">int</span> c = get<span class="hljs-constructor">State()</span>;            <span class="hljs-comment">//同步状态为0，说明临界区处于无锁状态，</span>            <span class="hljs-keyword">if</span> (c<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">//判断该线程是否在队首，然后修改同步状态，即加锁</span>                <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">First(<span class="hljs-params">current</span>)</span>&amp;&amp;compare<span class="hljs-constructor">AndSetState(0, <span class="hljs-params">acquires</span>)</span>) &#123;                    <span class="hljs-comment">//将当前线程设置为锁的owner</span>                    set<span class="hljs-constructor">ExclusiveOwnerThread(<span class="hljs-params">current</span>)</span>;                    return <span class="hljs-literal">true</span>;                &#125;            &#125;            <span class="hljs-comment">//如果临界区处于锁定状态，且上次获取锁的线程为当前线程</span>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current<span class="hljs-operator"> == </span>get<span class="hljs-constructor">ExclusiveOwnerThread()</span>) &#123;                 <span class="hljs-comment">//则递增同步状态</span>                <span class="hljs-built_in">int</span> nextc = c + acquires;                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>                    throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>)</span>;                set<span class="hljs-constructor">State(<span class="hljs-params">nextc</span>)</span>;                return <span class="hljs-literal">true</span>;            &#125;            return <span class="hljs-literal">false</span>;        &#125;</code></pre><p>其解锁方法<code>unlock()</code>调用轨迹如下:</p><ol><li>ReentrantLock：unlock()</li><li>AbstractQueuedSynchronizer：release(int arg)</li><li>Sync:tryRelease(int releases)</li></ol><p>第3步才开始真正释放锁,源码如下：</p><pre><code class="hljs reasonml">protected final boolean <span class="hljs-keyword">try</span><span class="hljs-constructor">Release(<span class="hljs-params">int</span> <span class="hljs-params">releases</span>)</span>&#123;    <span class="hljs-built_in">int</span> c = get<span class="hljs-constructor">State()</span> - releases;    <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Tread</span>.</span></span>current<span class="hljs-constructor">Thread()</span> != get<span class="hljs-constructor">ExclusiveOwnerThread()</span>)        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalMonitorStateException()</span>    boolean free = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span>(c<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果state减去releases为0，则释放锁</span>        free = <span class="hljs-literal">true</span>;        set<span class="hljs-constructor">ExcluiveOwnerThread(<span class="hljs-params">null</span>)</span>;<span class="hljs-comment">//将获取锁的线程设为null，即无锁</span>    &#125;    set<span class="hljs-constructor">State(<span class="hljs-params">c</span>)</span>;<span class="hljs-comment">//设置state，若c为0，则释放锁</span>    return free;&#125;</code></pre><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>使用非公平锁时，加锁方法lock()调用轨迹如下：</p><ol><li>ReentrantLock：lock()</li><li>NonfairSync：lock()</li><li>AbstractQueuedSynchronizer：compareAndSetState(int expect,int update)</li></ol><p>第3步进行加锁。该方法使用原子操作的方式更新state变量。源码如下：</p><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> long serialVersionUID = <span class="hljs-number">7316153563782823691</span>L;    <span class="hljs-keyword">final</span> void lock() &#123;                <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<span class="hljs-comment">//对state进行CAS</span>            <span class="hljs-comment">//若成功则加锁   </span>            setExclusiveOwnerThread(<span class="hljs-type">Thread</span>.currentThread();        <span class="hljs-keyword">else</span>            acquire(<span class="hljs-number">1</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程池学习总结（转载）</title>
    <link href="/2021/07/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
    <url>/2021/07/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Java线程池学习总结（转载）"><a href="#Java线程池学习总结（转载）" class="headerlink" title="Java线程池学习总结（转载）"></a>Java线程池学习总结（转载）</h1><blockquote><p>总结自<a href="https://github.com/whx123/JavaHome/blob/b6c47701db1d56630b83b39eb5d5e396504b3aea/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90.md">https://github.com/whx123/JavaHome/blob/b6c47701db1d56630b83b39eb5d5e396504b3aea/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%A3%E6%9E%90.md</a></p></blockquote><p>对线程池知识进行一次梳理</p><h2 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h2><p>线程池可以通过ThreadPoolExecutor来创建，其构造函数为：</p><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize,<span class="hljs-keyword">long</span> keepAliveTime,TimeUnit unit,   BlockingQueue&lt;Runnable&gt; workQueue,   ThreadFactory threadFactory,   RejectedExecutionHandler <span class="hljs-keyword">handler</span>)</code></pre><p>其中核心参数作用：</p><ul><li><p><strong>corePoolSize：</strong> 线程池核心线程数最大值</p></li><li><p><strong>maximumPoolSize：</strong> 线程池最大线程数大小</p></li><li><p><strong>keepAliveTime：</strong> 线程池中非核心线程空闲的存活时间大小</p></li><li><p><strong>unit：</strong> 线程空闲存活时间单位</p></li><li><p><strong>workQueue：</strong> 存放任务的阻塞队列</p></li><li><p><strong>threadFactory：</strong> 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。</p></li><li><p><strong>handler：</strong> 线城池的饱和策略事件，主要有四种类型。</p><h3 id="四种拒绝策略如下："><a href="#四种拒绝策略如下：" class="headerlink" title="四种拒绝策略如下："></a>四种拒绝策略如下：</h3></li><li><p>AbortPolicy(抛出一个异常，默认的)</p></li><li><p>DiscardPolicy(直接丢弃任务)</p></li><li><p>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</p></li><li><p>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</p></li></ul><h2 id="线程池执行流程"><a href="#线程池执行流程" class="headerlink" title="线程池执行流程"></a>线程池执行流程</h2><p>线程池执行，对应execute()方法如下图所示：</p><p><img src="/img/xc1.jpg"></p><p>对应描述为：</p><ul><li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li><li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li><li>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li><li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理</li></ul><h2 id="线程池异常处理"><a href="#线程池异常处理" class="headerlink" title="线程池异常处理"></a>线程池异常处理</h2><h2 id="线程池工作队列"><a href="#线程池工作队列" class="headerlink" title="线程池工作队列"></a>线程池工作队列</h2><p>线程池主要包含五种工作队列：</p><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue（可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</p><h2 id="几种常用的线程池"><a href="#几种常用的线程池" class="headerlink" title="几种常用的线程池"></a>几种常用的线程池</h2><ul><li>newFixedThreadPool (固定数目线程的线程池)</li><li>newCachedThreadPool(可缓存线程的线程池)</li><li>newSingleThreadExecutor(单线程的线程池)</li><li>newScheduledThreadPool(定时及周期执行的线程池)</li></ul><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>(int nThreads, ThreadFactory threadFactory) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(nThreads, nThreads,                                      <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,                                      <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),                                      threadFactory);    &#125;</code></pre><h4 id="线程池特点："><a href="#线程池特点：" class="headerlink" title="线程池特点："></a>线程池特点：</h4><ul><li>核心线程数和最大线程数大小一样</li><li>没有所谓的非空闲时间，即keepAliveTime为0</li><li>阻塞队列为无界队列LinkedBlockingQueue</li></ul><h4 id="工作机制："><a href="#工作机制：" class="headerlink" title="工作机制："></a>工作机制：</h4><p><img src="/img/xc2.png"></p><ul><li>提交任务</li><li>如果线程数少于核心线程，创建核心线程执行任务</li><li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li><li>如果线程执行完任务，去阻塞队列取任务，继续执行</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">CachedThreadPool</span>(ThreadFactory threadFactory) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                      <span class="hljs-number">60</span>L, TimeUnit.SECONDS,                                      <span class="hljs-keyword">new</span> <span class="hljs-type">SynchronousQueue</span>&lt;Runnable&gt;(),                                      threadFactory);    &#125;</code></pre><h4 id="线程池特点：-1"><a href="#线程池特点：-1" class="headerlink" title="线程池特点："></a>线程池特点：</h4><ul><li>核心线程数为0</li><li>最大线程数为Integer.MAX_VALUE</li><li>阻塞队列是SynchronousQueue</li><li>非核心线程空闲存活时间为60秒</li></ul><p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制:"></a>工作机制:</h4><p><img src="/img/xc3.png"></p><ul><li>提交任务</li><li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li><li>判断是否有空闲线程，如果有，就去取出任务执行。</li><li>如果没有空闲线程，就新建一个线程执行。</li><li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>用于并发执行大量短期的小任务。</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-keyword">new</span><span class="hljs-type">SingleThreadExecutor</span>(ThreadFactory threadFactory) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">FinalizableDelegatedExecutorService</span><span class="hljs-type"></span>            (<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0</span>L, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedBlockingQueue</span>&lt;Runnable&gt;(),                                    threadFactory));    &#125;</code></pre><h4 id="线程池特点"><a href="#线程池特点" class="headerlink" title="线程池特点"></a>线程池特点</h4><ul><li>核心线程数为1</li><li>最大线程数也为1</li><li>阻塞队列是LinkedBlockingQueue</li><li>keepAliveTime为0</li></ul><h4 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h4><p><img src="/img/xc4.png"></p><ul><li>提交任务</li><li>线程池是否有一条线程在，如果没有，新建线程执行任务</li><li>如果有，讲任务加到阻塞队列</li><li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日地干活。</li></ul><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>适用于串行执行任务的场景，一个任务一个任务地执行。</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScheduledThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize)</span> </span>&#123;       <span class="hljs-keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="hljs-number">0</span>, NANOSECONDS,             <span class="hljs-keyword">new</span> DelayedWorkQueue());   &#125;</code></pre><h4 id="线程池特点-1"><a href="#线程池特点-1" class="headerlink" title="线程池特点"></a>线程池特点</h4><ul><li>最大线程数为Integer.MAX_VALUE</li><li>阻塞队列是DelayedWorkQueue</li><li>keepAliveTime为0</li><li>scheduleAtFixedRate() ：按某种速率周期执行</li><li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul><h4 id="工作机制-2"><a href="#工作机制-2" class="headerlink" title="工作机制"></a>工作机制</h4><ul><li>添加一个任务</li><li>线程池中的线程从 DelayQueue 中取任务</li><li>线程从 DelayQueue 中获取 time 大于等于当前时间的task</li><li>执行完后修改这个 task 的 time 为下次被执行的时间</li><li>这个 task 放回DelayQueue队列中</li></ul><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>周期性执行任务的场景，需要限制线程数量的场景</p><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><p><img src="/img/xc5.png"></p><p><strong>RUNNING</strong></p><ul><li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li><li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</li><li>调用线程池的shutdownNow()方法，可以切换到STOP状态;</li></ul><p><strong>SHUTDOWN</strong></p><ul><li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</li></ul><p><strong>STOP</strong></p><ul><li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>线程池中执行的任务为空,进入TIDYING状态;</li></ul><p><strong>TIDYING</strong></p><ul><li>该状态表明所有的任务已经运行终止，记录的任务数量为0。</li><li>terminated()执行完毕，进入TERMINATED状态</li></ul><p><strong>TERMINATED</strong></p><ul><li>该状态表示线程池彻底终止</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习总结（三）</title>
    <link href="/2021/07/08/Mysql%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/07/08/Mysql%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql学习总结（三）"><a href="#Mysql学习总结（三）" class="headerlink" title="Mysql学习总结（三）"></a>Mysql学习总结（三）</h1><h2 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h2><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><ul><li>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li><li>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li><li>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</li><li>全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。</li><li>覆盖索引：查询列要被所建的索引覆盖，不必读取数据行</li><li>组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</li></ul><h3 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h3><ul><li>查询条件包含or，可能导致索引失效</li><li>如果字段类型是字符串，where时一定用引号括起来，否则索引失效</li><li>like通配符可能导致索引失效。</li><li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li><li>在索引列上使用mysql的内置函数，索引失效。</li><li>对索引列运算（如，+、-、*、/），索引失效。</li><li>索引字段上使用（！= 或者 &lt; &gt;，not in）时，可能会导致索引失效。</li><li>索引字段上使用is null， is not null，可能导致索引失效。</li><li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li><li>mysql估计使用全表扫描要比使用索引快,则不使用索引。</li></ul><h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><ul><li>一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。</li><li>聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</li><li>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li><li>聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；</li></ul><p>两种索引的使用情况表（表总结自<a href="https://github.com/whx123/JavaHome%EF%BC%89">https://github.com/whx123/JavaHome）</a></p><table><thead><tr><th>动作描述</th><th>使用聚集索引</th><th>使用非聚集索引</th></tr></thead><tbody><tr><td>列经常被分组排序</td><td>是</td><td>是</td></tr><tr><td>返回某范围内数据</td><td>是</td><td>否</td></tr><tr><td>一个或极少不同值</td><td>否</td><td>否</td></tr><tr><td>小数目的不同值</td><td>是</td><td>否</td></tr><tr><td>大数目的不同值</td><td>否</td><td>是</td></tr><tr><td>频繁更新的列</td><td>否</td><td>是</td></tr><tr><td>外键列</td><td>是</td><td>是</td></tr><tr><td>主键列</td><td>是</td><td>是</td></tr><tr><td>频繁修改索引列</td><td>否</td><td>是</td></tr></tbody></table><h3 id="创建索引原则"><a href="#创建索引原则" class="headerlink" title="创建索引原则"></a>创建索引原则</h3><ul><li>最左前缀匹配原则</li><li>频繁作为查询条件的字段才去创建索引</li><li>频繁更新的字段不适合创建索引</li><li>索引列不能参与计算，不能有函数操作</li><li>优先考虑扩展索引，而不是新建索引，避免不必要的索引</li><li>在order by或者group by子句中，创建索引需要注意顺序</li><li>区分度低的数据列不适合做索引列(如性别）</li><li>定义有外键的数据列一定要建立索引。</li><li>对于定义为text、image数据类型的列不要建立索引。</li><li>删除不再使用或者很少使用的索引</li></ul><h3 id="常见创建索引三种方式"><a href="#常见创建索引三种方式" class="headerlink" title="常见创建索引三种方式"></a>常见创建索引三种方式</h3><ul><li>在执行CREATE TABLE时创建索引</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`employee`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`date`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`sex`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_name`</span> (<span class="hljs-string">`name`</span>) <span class="hljs-keyword">USING</span> BTREE) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</code></pre><ul><li>使用ALTER TABLE命令添加索引</li></ul><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-built_in">table_name</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> index_name (<span class="hljs-keyword">column</span>);</code></pre><ul><li>使用CREATE INDEX命令创建</li></ul><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> index_name <span class="hljs-keyword">ON</span> <span class="hljs-built_in">table_name</span> (<span class="hljs-keyword">column</span>);</code></pre><h2 id="优化SQL"><a href="#优化SQL" class="headerlink" title="优化SQL"></a>优化SQL</h2><p>大致可从以下几个方面考虑.</p><h3 id="加索引"><a href="#加索引" class="headerlink" title="加索引"></a>加索引</h3><h3 id="适量分批量进行"><a href="#适量分批量进行" class="headerlink" title="适量分批量进行"></a>适量分批量进行</h3><h3 id="优化sql结构"><a href="#优化sql结构" class="headerlink" title="优化sql结构"></a>优化sql结构</h3><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p><strong>分库分表方案:</strong></p><ul><li>水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</li><li>水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</li><li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li><li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</li></ul><p><strong>常用的分库分表中间件：</strong></p><ul><li>sharding-jdbc（当当）</li><li>Mycat</li><li>TDDL（淘宝）</li><li>Oceanus(58同城数据库中间件)</li><li>vitess（谷歌开发的数据库中间件）</li><li>Atlas(Qihoo 360)</li></ul><p><strong>分库分表可能遇到的问题</strong>：</p><ul><li>事务问题：需要用分布式事务啦</li><li>跨节点Join的问题：解决这一问题可以分两次查询实现</li><li>跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。</li><li>数据迁移，容量规划，扩容等问题</li><li>ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID</li><li>跨分片的排序分页问题（后台加大pagesize处理？）</li></ul><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h3 id="SQL语句的执行顺序"><a href="#SQL语句的执行顺序" class="headerlink" title="SQL语句的执行顺序"></a>SQL语句的执行顺序</h3><p><img src="/img/sqlshunxu.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SQL优化的一般步骤分为三步：</p><ul><li>show status 命令了解各种 sql 的执行频率</li><li>通过慢查询日志定位那些执行效率较低的 sql 语句</li><li>explain 分析低效 sql 的执行计划</li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB与MyISAM"><a href="#InnoDB与MyISAM" class="headerlink" title="InnoDB与MyISAM"></a>InnoDB与MyISAM</h3><ul><li>InnoDB支持事务，MyISAM不支持事务</li><li>InnoDB支持外键，MyISAM不支持外键</li><li>InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持</li><li>select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。</li><li>Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）</li><li>InnoDB支持表、行级锁，而MyISAM支持表级锁。</li><li>InnoDB表必须有主键，而MyISAM可以没有主键</li><li>Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。</li><li>Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。</li><li>InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引</li></ul><h2 id="数据库中的锁"><a href="#数据库中的锁" class="headerlink" title="数据库中的锁"></a>数据库中的锁</h2><p><img src="/img/suoleixing.png"></p><h2 id="Mysql的读写分离"><a href="#Mysql的读写分离" class="headerlink" title="Mysql的读写分离"></a>Mysql的读写分离</h2><p>基于主从复制架构，主库写，从库读，主库自动将数据同步到从库</p><h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p>主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。</p><h3 id="主从同步延时"><a href="#主从同步延时" class="headerlink" title="主从同步延时"></a>主从同步延时</h3><blockquote><p>从库同步主库数据的过程是串行化的，主库上并行的操作，在从库上会串行执行，即会造成高并发场景下，从库的数据一定会比主库慢一些.</p></blockquote><p>有两个机制主要解决此问题：</p><ul><li>半同步复制<ul><li>主要解决主库数据丢失问题。</li><li>主库写入 binlog 日志之后，就会将<strong>强制</strong>此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到<strong>至少一个从库</strong>的 ack 之后才会认为写操作完成。</li></ul></li><li>并行复制<ul><li>主要解决主从同步延时问题。</li><li>从库开启多个线程，并行读取 relay log 中不同库的日志，然后<strong>并行重放不同库的日志</strong>，完成库级别的并行。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>只言片语</title>
    <link href="/2021/07/07/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/"/>
    <url>/2021/07/07/%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="只言片语"><a href="#只言片语" class="headerlink" title="只言片语"></a>只言片语</h2><ul><li>连篇累牍，不出月露之形；积案盈箱，唯是风云之状。</li><li>平生快意无经纬，何惧东海换姜汤。    –《螃蟹》</li><li>清香未减，风流不在人知。</li><li>满船明月从此去，本是江湖寂寥人。</li><li>在旧年月里，中国传统的意识，多是好男儿志在四方。</li><li>往海里丢一枚硬币，便是在这星球的历史中添加了两条平行的，连续的命运：我的命运以及硬币的命运。此后，我在陆地上每一瞬间的喜怒哀乐，都将对应着硬币在海底每一瞬间的无知无觉。</li><li>书店要做的不是把书摆出来让读者去挑，而是帮助读者把书挑好。一家好的书店，会让读者觉得自己想要的书就在手边，而非转半天找不到一本自己想要的书。书店追求的少而精，而非泛泛得广，实体书店的空间可能远远比不上无限空间的网络书店，不是吗？</li><li>仅仅由于偶一失足，却往往必须没完没了地付出代价，命运同人打交道时永远不肯清账。</li><li>四围山色，十里湖光。</li><li>不必太纠结于当下，也不必太忧虑未来，当你经历过一些事情时，眼前的风景已经和从前不一样了。</li><li>这世上多的是害怕主动迈出第一步的孤独之人。</li><li>他已经学会不把人生押在一段看不清道不明，朦朦胧胧的情感上，因为他知道，时间可贵。</li><li>心中不得宁静，日夜千思万想，努力发笔小财。</li><li>文坛中大多数人只可远观不可接近，光环脆弱，容易黯淡。</li><li>站在书脊上，飞跃这围墙。</li><li>塞北风沙酒，江南烟雨桥。</li><li>让人非我弱，得志莫离群；再三须重事，第一莫欺心。</li><li>好多事情，要趁年轻。</li><li>人活着总要有一个主题，是你魂梦系之。</li><li>轻舟已过万重山。</li><li>要么功课做在事前，要么小抄带在身边。</li><li>有的钟表天生走不准时间，但那并不等于报废，只要你忍受着它的走不准，它还是可以为你报时。没必要去修它，修了，它可能真的不走了。</li><li>身在俗世中，心向浪漫死。</li><li>幻想的假象总是美丽。对爱情的应景，我原以为相遇一定要诗书成画，歌文谱曲。要闹市马蹄下救人，荒山破庙里避雨，要坐错车下错站，要预谋一场假装有缘的相遇，要满足这样真实的设想。可是都不是，一个平凡的早上，嗡得一下，就出现了，那根红线。我要是摸到红线，我就想抓住姻缘。</li><li>希望因有趣被喜欢，因有用而被需要，却因为某些无趣无用的细枝末节，被某个人爱。</li><li>做一些自由自在的事，说一说无关紧要的话。</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程相关学习总结</title>
    <link href="/2021/07/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/07/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Java多线程学习总结"><a href="#Java多线程学习总结" class="headerlink" title="Java多线程学习总结"></a>Java多线程学习总结</h2><h2 id="线程和进程概念"><a href="#线程和进程概念" class="headerlink" title="线程和进程概念"></a>线程和进程概念</h2><blockquote><p>多线程三大特性：原子性，可见性，有序性</p></blockquote><ul><li>进程是独立的应用程序，进程中一般会有多个线程，进程是线程的集合。</li><li>线程就是一条执行路径。</li><li>多线程目的为了提高程序效率。</li></ul><blockquote><p>并发：两个队伍交替使用一台CPU</p><p>并行：两个队伍同时使用两台CPU</p></blockquote><h2 id="多线程创建方式"><a href="#多线程创建方式" class="headerlink" title="多线程创建方式"></a>多线程创建方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tread</span></span>&#123;  <span class="hljs-meta">@Override</span>  public run()&#123;      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;          <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;TreadDemo1&quot;</span>);      &#125;  &#125;&#125;<span class="hljs-type">TreadDemo1</span> t = <span class="hljs-keyword">new</span> <span class="hljs-type">TreadDemo1</span>();t.start();</code></pre><h3 id="实现runnable接口，重写run方法"><a href="#实现runnable接口，重写run方法" class="headerlink" title="实现runnable接口，重写run方法"></a>实现runnable接口，重写run方法</h3><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo2</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Runnable</span></span></span>&#123;  <span class="hljs-keyword">public</span> void run()&#123;      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;          System.out.println(<span class="hljs-string">&quot;ThreadDemo2&quot;</span>);      &#125;  &#125;&#125;Thread t = <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadDemo2</span>());t.start();</code></pre><h3 id="使用匿名内部类"><a href="#使用匿名内部类" class="headerlink" title="使用匿名内部类"></a>使用匿名内部类</h3><pre><code class="hljs typescript">Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">Runnable</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-keyword">while</span>(ture)&#123;          System.out.println(<span class="hljs-string">&quot;ThreadDemo3&quot;</span>);      &#125;  &#125;&#125;)t.start();</code></pre><h2 id="多线程的状态类型"><a href="#多线程的状态类型" class="headerlink" title="多线程的状态类型"></a>多线程的状态类型</h2><p>多线程大致包含五个主要状态：</p><ul><li><code>新建状态</code>：创建好线程，没有调用start方法之前。</li><li><code>就绪状态</code>：等待cpu分配执行权。</li><li><code>运行状态</code>：执行run方法代码。</li><li><code>死亡状态</code>：run方法执行完毕后，一个未捕获异常终止了run方法使线程猝死。</li><li><code>阻塞状态</code>：wait、sleep方法,锁资源被其他线程抢断等。</li></ul><h2 id="join-方法使用示例"><a href="#join-方法使用示例" class="headerlink" title="join()方法使用示例"></a>join()方法使用示例</h2><p>join()让其他线程变为等待。把指定的线程加入当前线程，可以让两个交替执行的线程合并为顺序执行的线程。比如线程B调用了线程A的join()方法，直到线程A执行完毕后，才会执行线程B。</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> *示例：子线程执行完毕后，主线程才能执行</span><span class="hljs-comment"> */</span>Thread t1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">new</span> Runnable()</span> &#123;          @Override          public void run<span class="hljs-literal">()</span> &#123;              <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                  <span class="hljs-keyword">try</span> &#123;                      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">10</span>);                  &#125; catch (Exception e) &#123;                  &#125;                  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;i:&quot;</span> + i);              &#125;          &#125;      &#125;);      t1.start<span class="hljs-literal">()</span>;      <span class="hljs-comment">// 当在主线程当中执行到t1.join()方法时，就认为主线程应该把执行权让给t1</span>      t1.join<span class="hljs-literal">()</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;          <span class="hljs-keyword">try</span> &#123;              <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">10</span>);          &#125; catch (Exception e) &#123;          &#125;          <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;main&quot;</span> + <span class="hljs-string">&quot;i:&quot;</span> + i);      &#125;</code></pre><h2 id="线程优先级设置"><a href="#线程优先级设置" class="headerlink" title="线程优先级设置"></a>线程优先级设置</h2><p>在JAVA线程中，通过一个int priority来控制优先级，范围为1-10，其中10最高，默认值为5。</p><pre><code class="hljs haxe">Thread t = <span class="hljs-keyword">new</span> <span class="hljs-type">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">ThreadDemo</span>());<span class="hljs-comment">//创建线程t</span>t.setPriority(<span class="hljs-number">10</span>);<span class="hljs-comment">//将线程优先级设为10</span>t.start();<span class="hljs-comment">//执行线程</span></code></pre><h2 id="线程安全相关"><a href="#线程安全相关" class="headerlink" title="线程安全相关"></a>线程安全相关</h2><h3 id="线程安全问题产生原因"><a href="#线程安全问题产生原因" class="headerlink" title="线程安全问题产生原因"></a>线程安全问题产生原因</h3><p>当多个线程共享同一个全局变量，在写的操作时，可能会受到其他线程的干扰。</p><h3 id="线程安全问题解决办法"><a href="#线程安全问题解决办法" class="headerlink" title="线程安全问题解决办法"></a>线程安全问题解决办法</h3><ol><li><strong>内置锁(Synchronized)</strong>:保证线程原子性，当线程进入方法时，自动获取锁，一旦锁被其他线程获取到后，其他的线程就会等待，只有一个线程进行使用。程序执行完毕后就会把锁释放。但是它会降低程序的运行效率(锁资源的竞争)。</li><li><strong>显示锁(Lock锁)</strong></li></ol><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><ul><li>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</li><li>它是整个JUC的基础</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Map相关学习总结</title>
    <link href="/2021/07/07/Java%20Map/"/>
    <url>/2021/07/07/Java%20Map/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中Map的相关用法"><a href="#Java中Map的相关用法" class="headerlink" title="Java中Map的相关用法"></a>Java中Map的相关用法</h1><h2 id="把一个Map转化为List"><a href="#把一个Map转化为List" class="headerlink" title="把一个Map转化为List"></a>把一个Map转化为List</h2><p>map转List有以下三种转化方式：</p><ul><li>把map的键key转化为list</li><li>把map的值value转化为list</li><li>把map的键值key-value转化为list</li></ul><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Map&lt;Integer, <span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;jay&quot;</span>);        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;whx&quot;</span>);        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;huaxiao&quot;</span>);        <span class="hljs-comment">//把一个map的键转化为list</span>        List&lt;Integer&gt; keyList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-built_in">map</span>.keySet());        System.out.<span class="hljs-built_in">println</span>(keyList);        <span class="hljs-comment">//把map的值转化为list</span>        List&lt;<span class="hljs-keyword">String</span>&gt; valueList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-built_in">map</span>.values());        System.out.<span class="hljs-built_in">println</span>(valueList);        把<span class="hljs-built_in">map</span>的键值转化为<span class="hljs-built_in">list</span>        List entryList = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-built_in">map</span>.entrySet());        System.out.<span class="hljs-built_in">println</span>(entryList);    &#125;&#125;</code></pre><h2 id="遍历一个Map"><a href="#遍历一个Map" class="headerlink" title="遍历一个Map"></a>遍历一个Map</h2><h3 id="entrySet-for实现遍历"><a href="#entrySet-for实现遍历" class="headerlink" title="entrySet+for实现遍历"></a>entrySet+for实现遍历</h3><pre><code class="hljs arduino">ublic <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntryMapTest</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Map&lt;Integer, <span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;jay&quot;</span>);        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;whx&quot;</span>);        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;huaxiao&quot;</span>);        <span class="hljs-keyword">for</span>(Map.Entry entry: <span class="hljs-built_in">map</span>.entrySet()) &#123;            <span class="hljs-comment">// get key</span>            Integer key = (Integer) entry.<span class="hljs-built_in">getKey</span>();            <span class="hljs-comment">// get value</span>            <span class="hljs-keyword">String</span> value = (<span class="hljs-keyword">String</span>) entry.getValue();            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;key:&quot;</span>+key+<span class="hljs-string">&quot;,value:&quot;</span>+value);        &#125;    &#125;&#125;</code></pre><h3 id="Iterator-while实现遍历"><a href="#Iterator-while实现遍历" class="headerlink" title="Iterator+while实现遍历"></a>Iterator+while实现遍历</h3><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IteratorMapTest</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Map&lt;Integer, <span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;jay&quot;</span>);        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;whx&quot;</span>);        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;huaxiao&quot;</span>);        Iterator itr = <span class="hljs-built_in">map</span>.entrySet().iterator();        <span class="hljs-keyword">while</span>(itr.hasNext()) &#123;            Map.Entry entry = (Map.Entry) itr.next();            <span class="hljs-comment">// get key</span>            Integer key = (Integer) entry.<span class="hljs-built_in">getKey</span>();            <span class="hljs-comment">// get value</span>            <span class="hljs-keyword">String</span> value = (<span class="hljs-keyword">String</span>) entry.getValue();            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;key:&quot;</span>+key+<span class="hljs-string">&quot;,value:&quot;</span>+value);        &#125;    &#125;&#125;</code></pre><h2 id="根据Map的keys进行排序"><a href="#根据Map的keys进行排序" class="headerlink" title="根据Map的keys进行排序"></a>根据Map的keys进行排序</h2><h3 id="把Map-Entry放进list，再用Comparator对list进行排序"><a href="#把Map-Entry放进list，再用Comparator对list进行排序" class="headerlink" title="把Map.Entry放进list，再用Comparator对list进行排序"></a>把Map.Entry放进list，再用Comparator对list进行排序</h3><pre><code class="hljs livescript"><span class="hljs-comment"># 伪代码</span>List <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-keyword">map</span>.entrySet());Collections.sort<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">list</span>, (Entry e1, Entry e2)-&gt; &#123;</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">return</span> e1.getKey().compareTo(e2.getKey());</span></span><span class="hljs-function"><span class="hljs-params">&#125;)</span>;</span></code></pre><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortKeysMapTest</span> &#123;</span>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;        <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;2010&quot;</span>, <span class="hljs-string">&quot;jay&quot;</span>);        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;1999&quot;</span>, <span class="hljs-string">&quot;whx&quot;</span>);        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;3010&quot;</span>, <span class="hljs-string">&quot;huaxiao&quot;</span>);        List&lt;<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">String</span>&gt;&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">map</span>.entrySet());        Collections.sort<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">list</span>, (<span class="hljs-built_in">Map</span>.Entry e1, <span class="hljs-built_in">Map</span>.Entry e2)-&gt; &#123;</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">return</span> e1.getKey().toString().compareTo(e2.getKey().toString());</span></span><span class="hljs-function"><span class="hljs-params">        &#125;)</span>;</span><span class="hljs-function"></span><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(<span class="hljs-built_in">Map</span>.Entry entry : <span class="hljs-keyword">list</span>)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;key:&quot;</span> + entry.getKey() + <span class="hljs-string">&quot;,value:&quot;</span> + entry.getValue())</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function"></span><span class="hljs-function">    &#125;</span><span class="hljs-function">&#125;</span></code></pre><h3 id="使用SortedMap-TreeMap-Comparator实现"><a href="#使用SortedMap-TreeMap-Comparator实现" class="headerlink" title="使用SortedMap+TreeMap+Comparator实现"></a>使用SortedMap+TreeMap+Comparator实现</h3><pre><code class="hljs reasonml">#伪代码SortedMap sortedMap = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeMap(<span class="hljs-params">new</span> Comparator()</span> &#123;  @Override  public <span class="hljs-built_in">int</span> compare(K k1, K k2) &#123;    return k1.compare<span class="hljs-constructor">To(<span class="hljs-params">k2</span>)</span>;  &#125;&#125;);sortedMap.put<span class="hljs-constructor">All(<span class="hljs-params">map</span>)</span>;</code></pre><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortKeys2MapTest</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Map&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;2010&quot;</span>, <span class="hljs-string">&quot;jay&quot;</span>);        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;1999&quot;</span>, <span class="hljs-string">&quot;whx&quot;</span>);        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;3010&quot;</span>, <span class="hljs-string">&quot;huaxiao&quot;</span>);        SortedMap sortedMap = <span class="hljs-keyword">new</span> TreeMap(<span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">String</span>&gt;() &#123;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> compare(<span class="hljs-keyword">String</span> k1, <span class="hljs-keyword">String</span> k2) &#123;                <span class="hljs-keyword">return</span> k1.compareTo(k2);            &#125;        &#125;);        sortedMap.putAll(<span class="hljs-built_in">map</span>);        Iterator itr = sortedMap.entrySet().iterator();        <span class="hljs-keyword">while</span>(itr.hasNext()) &#123;            Map.Entry entry = (Map.Entry) itr.next();            <span class="hljs-comment">// get key</span>            <span class="hljs-keyword">String</span> key = (<span class="hljs-keyword">String</span>) entry.<span class="hljs-built_in">getKey</span>();            <span class="hljs-comment">// get value</span>            <span class="hljs-keyword">String</span> value = (<span class="hljs-keyword">String</span>) entry.getValue();            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;key:&quot;</span>+key+<span class="hljs-string">&quot;,value:&quot;</span>+value);        &#125;    &#125;&#125;</code></pre><h2 id="对Map的values进行排序"><a href="#对Map的values进行排序" class="headerlink" title="对Map的values进行排序"></a>对Map的values进行排序</h2><pre><code class="hljs livescript"><span class="hljs-comment">#伪代码</span>List <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-keyword">map</span>.entrySet());Collections.sort<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">list</span>, (Entry e1, Entry e2) -&gt;&#123;</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">return</span> e1.getValue().compareTo(e2.getValue());</span></span><span class="hljs-function"><span class="hljs-params">  &#125;)</span>;</span></code></pre><pre><code class="hljs livescript">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortValuesMapTest</span> &#123;</span>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;        <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;2010&quot;</span>, <span class="hljs-string">&quot;jay&quot;</span>);        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;1999&quot;</span>, <span class="hljs-string">&quot;whx&quot;</span>);        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;3010&quot;</span>, <span class="hljs-string">&quot;huaxiao&quot;</span>);        List &lt;<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">String</span>&gt;&gt;<span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">map</span>.entrySet());        Collections.sort<span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">list</span>, (<span class="hljs-built_in">Map</span>.Entry e1, <span class="hljs-built_in">Map</span>.Entry e2)-&gt; &#123;</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">return</span> e1.getValue().toString().compareTo(e2.getValue().toString());</span></span><span class="hljs-function"><span class="hljs-params">            &#125;</span></span><span class="hljs-function"><span class="hljs-params">        )</span>;</span><span class="hljs-function"></span><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(<span class="hljs-built_in">Map</span>.Entry entry : <span class="hljs-keyword">list</span>)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(<span class="hljs-string">&quot;key:&quot;</span> + entry.getKey() + <span class="hljs-string">&quot;,value:&quot;</span> + entry.getValue())</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function">    &#125;</span><span class="hljs-function">&#125;</span></code></pre><pre><code class="hljs css">结果：<span class="hljs-selector-tag">key</span><span class="hljs-selector-pseudo">:3010</span>,<span class="hljs-selector-tag">value</span><span class="hljs-selector-pseudo">:huaxiao</span><span class="hljs-selector-tag">key</span><span class="hljs-selector-pseudo">:2010</span>,<span class="hljs-selector-tag">value</span><span class="hljs-selector-pseudo">:jay</span><span class="hljs-selector-tag">key</span><span class="hljs-selector-pseudo">:1999</span>,<span class="hljs-selector-tag">value</span><span class="hljs-selector-pseudo">:whx</span></code></pre><h2 id="Map各种类型区别"><a href="#Map各种类型区别" class="headerlink" title="Map各种类型区别"></a>Map各种类型区别</h2><table><thead><tr><th></th><th>HashMap</th><th>TreeMap</th><th>Hashtable</th><th>ConcurrentHashMap</th></tr></thead><tbody><tr><td>有序性</td><td>否</td><td>是</td><td>否</td><td>否</td></tr><tr><td>null k-v</td><td>是-是</td><td>否-是</td><td>否-否</td><td>否-否</td></tr><tr><td>线性安全</td><td>否</td><td>否</td><td>是</td><td>是</td></tr><tr><td>时间复杂度</td><td>O（1）</td><td>O（log n）</td><td>O(1)</td><td>O（log n）</td></tr><tr><td>底层结构</td><td>数组+链表+红黑树</td><td>红黑树</td><td>数组+链表</td><td>数组+链表+红黑树</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021阅读</title>
    <link href="/2021/07/06/2021%E9%98%85%E8%AF%BB/"/>
    <url>/2021/07/06/2021%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="2021阅读"><a href="#2021阅读" class="headerlink" title="2021阅读"></a>2021阅读</h1><h2 id="一月"><a href="#一月" class="headerlink" title="一月"></a>一月</h2><p>《夜晚的潜水艇》</p><p>陈春成/上海三联书店</p><p>1.23 都是错配，比如我决定做一件事，但为它配置的资源有问题，或多或少或方向完全错了，每个人所从事的工作，很多时候也是一种错配，他以为他可以胜任，其实不能，或者只是部分胜任，某种程度的胜任。错配可是人生一辈子的事情。有些事，只有我知道。</p><p>《人间草木》</p><p>汪曾祺/人民文学出版社</p><p>1.25 多识鸟兽草木之名</p><p>《第七天》</p><p>余华/新星出版社</p><p>怕的不是单个声音的收效甚微，怕的是，所有人都习以为常的麻木不仁。</p><p>有人书评“就如同上个世纪在饿殍之间坐着的你翻开《活着》，于是笑。这不就是流水账，有什么好写的”，此书书评如是。</p><h2 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h2><p>《圣女的救济》</p><p>东野圭吾/南海出版公司</p><p>就像已知是一个深爱丈夫却惨遭背叛的妻子复仇故事，看完还是唏嘘深情唤不回回应，迷恋就该早早断绝。</p><p>“它厌恶真柴义孝的冷漠，厌恶若山红美的不拒绝，也厌恶自己的故作不知，粉饰太平”</p><p>“可我千挑万选，千等万等，等来的也只是一个教训，他们都有错。而我或许，也是不知悔改”</p><p>道貌岸然干不可告人的勾当，最为恐怖。。</p><h2 id="三月"><a href="#三月" class="headerlink" title="三月"></a>三月</h2><blockquote><p>返校开始技术路线（笑</p></blockquote><p>《Java程序员面试算法宝典》</p><p>猿媛之家/机械工业出版社</p><h2 id="四月"><a href="#四月" class="headerlink" title="四月"></a>四月</h2><p>《MySQL性能优化和高可用架构实践》</p><p>宋立恒/清华大学出版社</p><h2 id="五月"><a href="#五月" class="headerlink" title="五月"></a>五月</h2><p>论文月，记录下杂文《读库》</p><ul><li>《上海浮生》<ul><li>讲述作者从2003年至2012年近十年在上海漂泊的日子。生活气息很生动，作者和媳妇一开始为了生计打算投靠老乡，一起去浙江打工，在火车上，言语之间，感觉到老乡生怕自己被沾光，于是赌气改道上海，才有了后来的十年漂泊。</li><li>十年漂泊，这对夫妇因湖南房价便宜且宜居，便在湖南买了房，但因那边无依无靠，后来还是回了老家贵州。</li></ul></li></ul><h2 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h2><p>论文月，记录杂文《读库》</p><ul><li>《从“深蓝”到“深思”》<ul><li>讲述了阿尔法狗的发展历程</li><li>正如聪明人早晚会超越只懂得玩耍的年纪，人工只能也并非只能玩游戏。</li><li>一项竞技运动在社会上能获得多少关注，大致取决于两个因素：一是它在特定的历史文化环境中对社会情绪的影响；二是这项运动本身所包含的技巧和观赏性。</li></ul></li><li>《今人重建黄鹤楼》<ul><li>关于1981年黄鹤楼的重建工作记录</li><li>设计师为中南设计院向欣然</li><li>万古河山，胜迹常留，叹百年时运维坚，三楚名楼曾付火；</li><li>千秋邦国，韶华永驻，看一代英雄谋略，九霄仙鹤又乘风。</li></ul></li><li>《我在北京派快件》&amp;《我在上海开出租》<ul><li>两篇都是贴近大城市小人物浮沉的短文，人物虽小，但生活都有奔头</li></ul></li></ul><h2 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h2><p>《labuladong的算法小抄》</p><p>付东来/中国工信出版集团</p><h2 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h2><ul><li><p>《草枕》</p><p>夏目漱石/陈德文（译)</p><ul><li>发挥才智，则锋芒毕露；</li><li></li></ul></li><li><p>《赛博与朋克》</p><ul><li>未来已来，只是分布在不同的现在而已。</li></ul></li></ul><h2 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h2><p>未读</p><h2 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h2><p>未读</p><h2 id="十一月"><a href="#十一月" class="headerlink" title="十一月"></a>十一月</h2><ul><li><p>《深入浅出图神经网络：GNN原理解析》</p></li><li><p>《垄断的困境》</p></li><li><p>《疑似神仙眷侣》</p><p>记录了秋芙与蒋坦神仙眷侣的诗意人生。从中知晓关锳字秋芙，为《秋灯琐忆》中的女主人公，看到时代局限下爱情的难能可贵。</p></li></ul><h2 id="十二月"><a href="#十二月" class="headerlink" title="十二月"></a>十二月</h2><p>未读</p><h2 id="年度总结"><a href="#年度总结" class="headerlink" title="年度总结"></a>年度总结</h2><ul><li><strong>所谓成长，是我们认识世界和世界相处的方式发生变化的过程</strong></li><li><strong>从最简单的事情开始，从真实发生的事情开始</strong></li><li>并不是你有了一个宏大的计划才开始行动，而是随着行动的累积开始逐渐呈现出一个计划。你想成为什么样的人，就开始分享什么样的内容； 你想过上什么样的生活，就开始分享什么样的生活。</li><li>做有长期收益的事情，输出是高效的信任货币，比如写作。</li><li>做一个生产者，一个积极影响别人的人：不要只读文章，去写文章；不要只看短视频，去做短视频；不要只去培训班听课，去培训班讲课。</li><li>我们接触到的人或者说朋友圈好友90%（甚至更多）应该都是旁观者，大家彼此存在的意义主要是凑凑热闹。不要因为别人的夸奖和吐槽而受到太多影响，因为很可能他就是路过的时候给你加把劲或者朝你翻个白眼，你对于大多数人都不重要。有两三个可以交心的朋友很重要。</li><li>尝试研究自己的产品，不受平台约束的东西。</li><li>最后姜汤时间：收获可能不会立刻发生，但它确实会发生</li><li>网络为你呈现的世界并不是真实的世界，而是别人的世界，精英眼中的世界。</li><li>人生冒险家</li><li>这个网络飞速发展的时代，不止经济，大家都很浮躁。他人的成功背后一定有无数我们看不到的努力，也有人习惯弱化自己曾经遇到的挫折。每个选择，都是人生的岔路口。</li><li>词境一说，不言自明，若自身境界不及于此，却强硬使用此境之文造境，所有字里行间的伪装，遣词造句的粉饰，都是装逼。</li></ul><p>不藏拙的人生</p><p>年少的我有一个心结，那便是惧怕活得放肆的人，因自己的日子太过苍白。无故事可讲的我，怕自己羡慕这些过得声色十足的生活家。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collections.sort()用法</title>
    <link href="/2021/07/06/Collections.sort()%E7%94%A8%E6%B3%95/"/>
    <url>/2021/07/06/Collections.sort()%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Collections-sort-用法"><a href="#Collections-sort-用法" class="headerlink" title="Collections.sort()用法"></a>Collections.sort()用法</h1><blockquote><p>在做算法题时，碰到了这样的一道：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</p><pre><code class="hljs groovy">&gt;Example <span class="hljs-number">1</span>: <span class="hljs-attr">Input:</span> s = <span class="hljs-string">&quot;abpcplea&quot;</span>, d = [<span class="hljs-string">&quot;ale&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;monkey&quot;</span>,<span class="hljs-string">&quot;plea&quot;</span>]&gt;<span class="hljs-attr">Output:</span> <span class="hljs-string">&quot;apple&quot;</span></code></pre></blockquote><blockquote><p>解题过程中需要对列表进行自定义比较器定义，之前只用过自然排序，在此进行总结</p><pre><code class="hljs Java">&gt;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongestWordInDictonary</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;   <span class="hljs-comment">//数组转列表</span>   List&lt;String&gt; dict = Arrays.asList(<span class="hljs-string">&quot;ale&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;monkey&quot;</span>, <span class="hljs-string">&quot;plea&quot;</span>);   System.out.println(<span class="hljs-keyword">new</span> LongestWordInDictonary().findLongestWord(<span class="hljs-string">&quot;abpcplea&quot;</span>, dict)); &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">findLongestWord</span><span class="hljs-params">(String s, List&lt;String&gt; d)</span> </span>&#123;   Collections.sort(       d, Comparator.comparing(String::length).reversed().thenComparing(String::compareTo));   <span class="hljs-keyword">for</span> (String str : d) &#123;     <span class="hljs-keyword">if</span> (str.length() &lt;= s.length()) &#123;       <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l1 = s.length(), l2 = str.length(); i &lt; l1 &amp;&amp; j &lt; l2; ) &#123;         <span class="hljs-keyword">if</span> (s.charAt(i) == str.charAt(j)) &#123;           i++;           j++;         &#125; <span class="hljs-keyword">else</span> &#123;           i++;         &#125;       &#125;       <span class="hljs-keyword">if</span> (j &gt;= str.length()) <span class="hljs-keyword">return</span> str;     &#125;   &#125;   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>; &#125;&gt;&#125;</code></pre></blockquote><p>Collections类里有sort()的两个方法。第一种只需传入被排序的集合，便会为它自然排序。第二种需要我们自定义排序的方式，细则可以创建一个比较器来进行排序，Comparator也是属于函数式接口，我们也能使用lambda表达式。对上述代码使用的方法进行总结。</p><h2 id="使用Comparator-comparing进行排序"><a href="#使用Comparator-comparing进行排序" class="headerlink" title="使用Comparator.comparing进行排序"></a>使用Comparator.comparing进行排序</h2><p>首先查看Comparator类的内部实现comparing，查询如下：</p><pre><code class="hljs livescript">public <span class="hljs-keyword">static</span> &lt;T, U&gt; Comparator&lt;T&gt; comparing(            <span class="hljs-built_in">Function</span>&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> U&gt; keyExtractor,            Comparator&lt;? <span class="hljs-built_in">super</span> U&gt; keyComparator)    &#123;        Objects.requireNonNull(keyExtractor);        Objects.requireNonNull(keyComparator);        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)            <span class="hljs-function"><span class="hljs-params">(c1, c2)</span> -&gt;</span> keyComparator.compare(keyExtractor.apply(c1),                                              keyExtractor.apply(c2));    &#125;</code></pre><p>可以看到比较器参数keyComparator ，用来创建自定义比较器</p><p>即对应上述片段。</p><pre><code class="hljs css"><span class="hljs-selector-tag">Comparator</span><span class="hljs-selector-class">.comparing</span>(<span class="hljs-selector-tag">String</span><span class="hljs-selector-pseudo">::length)</span></code></pre><h2 id="使用Comparator-reversed进行排序"><a href="#使用Comparator-reversed进行排序" class="headerlink" title="使用Comparator.reversed进行排序"></a>使用Comparator.reversed进行排序</h2><p>返回相反的排序规则</p><h2 id="使用Comparator-thenComparing进行排序"><a href="#使用Comparator-thenComparing进行排序" class="headerlink" title="使用Comparator.thenComparing进行排序"></a>使用Comparator.thenComparing进行排序</h2><p>比排序的比较顺序进行定义，在本题应用上，先按字符串长度，后按字典序进行排序</p>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间序列预测（一）</title>
    <link href="/2021/04/12/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/04/12/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="时间序列预测"><a href="#时间序列预测" class="headerlink" title="时间序列预测"></a>时间序列预测</h1><p>针对当前做时间序列预测的方法进行一些总结。</p><h2 id="周期因子法"><a href="#周期因子法" class="headerlink" title="周期因子法"></a>周期因子法</h2><h3 id="周期因子法概要"><a href="#周期因子法概要" class="headerlink" title="周期因子法概要"></a>周期因子法概要</h3><p>如果数据具有明显的周期性，需要由过去推未来，即可通过周期性进行数据预测。</p><p>下表是一个商场的一周的客流量的情况。</p><table><thead><tr><th>时间</th><th>周一</th><th>周二</th><th>周三</th><th>周四</th><th>周五</th><th>周六</th><th>周日</th><th>平均值</th></tr></thead><tbody><tr><td>第一周</td><td>20</td><td>10</td><td>70</td><td>50</td><td>250</td><td>200</td><td>100</td><td>100</td></tr><tr><td>第二周</td><td>26</td><td>18</td><td>66</td><td>50</td><td>180</td><td>140</td><td>80</td><td>80</td></tr><tr><td>第三周</td><td>15</td><td>8</td><td>67</td><td>60</td><td>270</td><td>160</td><td>120</td><td>100</td></tr></tbody></table><p>可以看到以每周为周期的数据波动，预测即尽可能准确提取这种周期波动。</p><p>首先计算周均值，然后将每列数据除以周均值，得到比例。然后按列找出比例因子的中位数。<br>| 时间   | 周一  | 周二  | 周三  | 周四  | 周五 | 周六 | 周日 |<br>| —— | —– | —– | —– | —– | —- | —- | —- |<br>| 第一周 | 0.2   | 0.1   | 0.7   | 0.5   | 2.5  | 2    | 1    |<br>| 第二周 | 0.325 | 0.225 | 0.825 | 0.625 | 2.25 | 1.75 | 1    |<br>| 第三周 | 0.15  | 0.08  | 0.67  | 0.6   | 2.7  | 1.6  | 1.2  |<br>| 中位数 | 0.2   | 0.1   | 0.7   | 0.6   | 2.5  | 1.75 | 1    |</p><p>预测即可通过将周期因子乘以一个base来做下一周的预测。这个base可以是上一周的平均数，也可以是更多的优化。</p><h3 id="周期因子法优化"><a href="#周期因子法优化" class="headerlink" title="周期因子法优化"></a>周期因子法优化</h3><h4 id="优化周期因子"><a href="#优化周期因子" class="headerlink" title="优化周期因子"></a>优化周期因子</h4><p>按列提取中位数是排除极端值的有效手法，但有时可能丢失大量信息，可以针对均值和中位数进行比例融合，也可根据时间跨度距离预测时间段的远近，给数据加上不同权重来进行优化。</p><h4 id="优化base取法"><a href="#优化base取法" class="headerlink" title="优化base取法"></a>优化base取法</h4><p>直接取预测时间点上一周的平均值可能不是取base的好方法，也可取最后五天或几天的均值来反映最近的情况，但这个取法需要排除周期性影响，可用客流量初一周期因子后再取均值，这样作为base。<br>| 时间         | 周一 | 周二 | 周三 | 周四 | 周五 | 周六 | 周日 |<br>| ———— | —- | —- | —- | —- | —- | —- | —- |<br>| 第三周       | 15   | 8    | 67   | 60   | 270  | 160  | 120  |<br>| 中位数       | 0.2  | 0.1  | 0.7  | 0.6  | 2.5  | 1.75 | 1    |<br>| 去周期化客流 | 75   | 80   | 95.7 | 100  | 108  | 91.4 | 120  |</p><h2 id="时序建模法"><a href="#时序建模法" class="headerlink" title="时序建模法"></a>时序建模法</h2><p>使用ARIMA等线性模型，为金融中常用来分析投资品收益率的序列方法。本方法要点是挖掘时间序列中的自相关性，通常通过计算协方差或相关系数实现。</p><h2 id="监督学习模型"><a href="#监督学习模型" class="headerlink" title="监督学习模型"></a>监督学习模型</h2><p>使用xgboot，LSTM模型，seq2seq等将其转化为有监督学习数据集。</p><p>其中使用python将时间序列转换为监督学习问题在此链接<a href="https://link.zhihu.com/?target=https://cloud.tencent.com/developer/article/1042809%E3%80%82">https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1042809。</a></p><p>使用纯粹seq2seq模型对相关问题的解决方案在此链接<a href="https://link.zhihu.com/?target=https://github.com/LenzDu/Kaggle-Competition-Favorita/blob/master/seq2seq.py%E3%80%82">https://link.zhihu.com/?target=https%3A//github.com/LenzDu/Kaggle-Competition-Favorita/blob/master/seq2seq.py。</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>seq2seq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>N人走钢索问题踩坑</title>
    <link href="/2021/04/06/N%E4%BA%BA%E8%B5%B0%E9%92%A2%E7%B4%A2%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/"/>
    <url>/2021/04/06/N%E4%BA%BA%E8%B5%B0%E9%92%A2%E7%B4%A2%E9%97%AE%E9%A2%98%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>为腾讯笔试题目，N人过桥问题的改进，N人走钢索，最多两人过钢索，只有一支平衡杆，问最少需要多少时间全部过桥。</p><pre><code class="hljs subunit">输入：233 6 9410 1 5 2含义：有两组人，一组三人，一组四人，组内每人通过时间为下一列数组表示返回值：18   （6<span class="hljs-string">+3</span><span class="hljs-string">+9</span>）17   （2<span class="hljs-string">+1</span><span class="hljs-string">+10</span><span class="hljs-string">+2</span><span class="hljs-string">+2</span>）</code></pre><pre><code class="hljs css">贪心策略最快的(即所用时间<span class="hljs-selector-tag">t</span><span class="hljs-selector-attr">[0]</span>)和次快的过桥,然后最快的回来,再次慢的和最慢的过桥,然后次快的回来。即所需时间为<span class="hljs-selector-pseudo">:t</span><span class="hljs-selector-attr">[0]</span>+2*<span class="hljs-selector-tag">t</span><span class="hljs-selector-attr">[1]</span>+<span class="hljs-selector-tag">t</span><span class="hljs-selector-attr">[n-1]</span>最快的和最慢的过桥，然后最快的回来,再最快的和次慢的过桥,然后最快的回来。即所需时间为<span class="hljs-selector-pseudo">:2</span>*<span class="hljs-selector-tag">t</span><span class="hljs-selector-attr">[0]</span>+<span class="hljs-selector-tag">t</span><span class="hljs-selector-attr">[n-2]</span>+<span class="hljs-selector-tag">t</span><span class="hljs-selector-attr">[n-1]</span>比较两种情况进行贪心。</code></pre><pre><code class="hljs dart"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment"><span class="markdown">/<span class="hljs-strong">**</span></span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @author liujinbo</span></span><span class="hljs-comment"><span class="markdown"><span class="hljs-bullet"> *</span> @create 2021-04-04 20:44</span></span><span class="hljs-comment"><span class="markdown"> <span class="hljs-emphasis">*/</span></span></span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test2</span> </span>&#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;        Scanner sc =<span class="hljs-keyword">new</span> Scanner(System.<span class="hljs-keyword">in</span>);        <span class="hljs-built_in">int</span> x =sc.nextInt();        <span class="hljs-built_in">int</span>[] n1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[x];        <span class="hljs-keyword">while</span>(sc.hasNext())&#123;            <span class="hljs-built_in">int</span> n = sc.nextInt();            <span class="hljs-built_in">int</span>[] <span class="hljs-built_in">num</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n+<span class="hljs-number">1</span>];            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; i++) &#123;                <span class="hljs-built_in">num</span>[i] = sc.nextInt();            &#125;            Arrays.sort(<span class="hljs-built_in">num</span>);            <span class="hljs-built_in">int</span> res =<span class="hljs-number">0</span>;            <span class="hljs-built_in">int</span> flag = n;            <span class="hljs-keyword">while</span>(flag&gt;<span class="hljs-number">3</span>)&#123;                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span>[<span class="hljs-number">1</span>]+<span class="hljs-built_in">num</span>[flag<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">2</span>*<span class="hljs-built_in">num</span>[<span class="hljs-number">2</span>])&#123;                    res+=<span class="hljs-number">2</span>*<span class="hljs-built_in">num</span>[<span class="hljs-number">2</span>]+<span class="hljs-built_in">num</span>[flag]+<span class="hljs-built_in">num</span>[<span class="hljs-number">1</span>];                &#125;<span class="hljs-keyword">else</span>&#123;                    res+=<span class="hljs-number">2</span>*<span class="hljs-built_in">num</span>[<span class="hljs-number">1</span>]+<span class="hljs-built_in">num</span>[flag]+<span class="hljs-built_in">num</span>[flag<span class="hljs-number">-1</span>];                &#125;                flag-=<span class="hljs-number">2</span>;            &#125;            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">3</span>)&#123;                res +=(<span class="hljs-built_in">num</span>[<span class="hljs-number">1</span>]+<span class="hljs-built_in">num</span>[<span class="hljs-number">2</span>]+<span class="hljs-built_in">num</span>[<span class="hljs-number">3</span>]);            &#125;<span class="hljs-keyword">else</span>&#123;                res+=(<span class="hljs-built_in">num</span>[<span class="hljs-number">2</span>]);            &#125;            System.out.println(res);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和数字相关算法题</title>
    <link href="/2021/03/26/%E5%92%8C%E6%95%B0%E5%AD%97%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/03/26/%E5%92%8C%E6%95%B0%E5%AD%97%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><blockquote><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><pre><code class="hljs accesslog">&gt;输入: <span class="hljs-string">[0,1,0,3,12]</span>&gt;输出: <span class="hljs-string">[1,3,12,0,0]</span></code></pre></blockquote><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    public <span class="hljs-keyword">void</span> moveZeroes(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> idx = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">num</span> != <span class="hljs-number">0</span>) nums[idx++] = <span class="hljs-built_in">num</span>;        &#125;        <span class="hljs-keyword">while</span> (idx &lt; nums.length) &#123;            nums[idx++] =<span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><h3 id="3-接雨水-字节爱出"><a href="#3-接雨水-字节爱出" class="headerlink" title="3. 接雨水(字节爱出)"></a>3. 接雨水(字节爱出)</h3><blockquote><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><pre><code class="hljs dns">&gt;输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]&gt;输出：<span class="hljs-number">6</span>&gt;解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。</code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：height = [4,2,0,3,2,5]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：9</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] <span class="hljs-built_in">height</span>)</span> </span>&#123;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-built_in">height</span>.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(l &lt; r) &#123;            <span class="hljs-built_in">min</span> = <span class="hljs-built_in">height</span>[<span class="hljs-built_in">height</span>[l] &lt; <span class="hljs-built_in">height</span>[r] ? l++ : r--];            <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span>);            res += <span class="hljs-built_in">max</span> - <span class="hljs-built_in">min</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h3 id="4-下一个排列"><a href="#4-下一个排列" class="headerlink" title="4. 下一个排列"></a>4. 下一个排列</h3><blockquote><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[1,2,3]</span>&gt;输出：<span class="hljs-comment">[1,3,2]</span></code></pre><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[3,2,1]</span>&gt;输出：<span class="hljs-comment">[1,2,3]</span></code></pre><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[1,1,5]</span>&gt;输出：<span class="hljs-comment">[1,5,1]</span></code></pre><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[1]</span>&gt;输出：<span class="hljs-comment">[1]</span></code></pre></blockquote><pre><code class="hljs cpp">    <span class="hljs-comment">//源于离散数学及其应用的算法：（以3 4 5 2 1 为例）</span>    <span class="hljs-comment">//从后往前寻找第一次出现的正序对：（找到 4,5）</span>    <span class="hljs-comment">//之后因为从5 开始都是逆序，所以把他们反转就是正序：3 4 1 2 5</span>    <span class="hljs-comment">//之后4 的位置应该是：在它之后的，比他大的最小值（5）</span>    <span class="hljs-comment">//交换这两个值：得到 3 5 1 2 4</span>    <span class="hljs-comment">// 对于初始即为逆序的序列，将在反转步骤直接完成</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] &gt;= nums[i])            i--; <span class="hljs-comment">// 从后向前找第一个正序，这里最后i指向的是逆序起始位置</span>        reverse(nums, i, len - <span class="hljs-number">1</span>); <span class="hljs-comment">// 翻转后面的逆序区域，使其变为正序</span>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; len &amp;&amp; nums[j] &gt;= nums[i])            i++; <span class="hljs-comment">// 找到第一个比nums[j]大的元素，交换即可</span>        <span class="hljs-comment">// 交换</span>        swap(nums, i, j);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">while</span> (i &lt; j) &#123;            swap(nums, i++, j--);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;        <span class="hljs-keyword">int</span> t = nums[i];        nums[i] = nums[j];        nums[j] = t;    &#125;&#125;</code></pre><h3 id="5-孩子们的游戏"><a href="#5-孩子们的游戏" class="headerlink" title="5. 孩子们的游戏"></a>5. <a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=3&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">孩子们的游戏</a></h3><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><p>如果没有小朋友，请返回-1</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash">5,3</span><span class="hljs-meta">&gt;</span><span class="bash">返回值</span><span class="hljs-meta">&gt;</span><span class="bash">3</span></code></pre></blockquote><p>约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。</p><pre><code class="hljs reasonml">public <span class="hljs-built_in">int</span> <span class="hljs-constructor">LastRemaining_Solution(<span class="hljs-params">int</span> <span class="hljs-params">n</span>, <span class="hljs-params">int</span> <span class="hljs-params">m</span>)</span> &#123;    <span class="hljs-keyword">if</span> (n<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)     <span class="hljs-comment">/* 特殊输入的处理 */</span>        return -<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (n<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)     <span class="hljs-comment">/* 递归返回条件 */</span>        return <span class="hljs-number">0</span>;    return (<span class="hljs-constructor">LastRemaining_Solution(<span class="hljs-params">n</span> - 1, <span class="hljs-params">m</span>)</span> + m) % n;&#125;</code></pre><h3 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a>165. 比较版本号</h3><blockquote><p>给你两个版本号 version1 和 version2 ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：version1 = <span class="hljs-string">&quot;1.01&quot;</span>, version2 = <span class="hljs-string">&quot;1.001&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：0</span><span class="hljs-meta">&gt;</span><span class="bash">解释：忽略前导零，<span class="hljs-string">&quot;01&quot;</span> 和 <span class="hljs-string">&quot;001&quot;</span> 都表示相同的整数 <span class="hljs-string">&quot;1&quot;</span></span></code></pre><pre><code class="hljs gcode">&gt;输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;1.0&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.0.0&quot;</span>&gt;输出：<span class="hljs-number">0</span>&gt;解释：versio<span class="hljs-symbol">n1</span> 没有指定下标为 <span class="hljs-number">2</span> 的修订号，即视为 <span class="hljs-string">&quot;0&quot;</span></code></pre><pre><code class="hljs gcode">&gt;输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;0.1&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.1&quot;</span>&gt;输出：<span class="hljs-number">-1</span>&gt;解释：versio<span class="hljs-symbol">n1</span> 中下标为 <span class="hljs-number">0</span> 的修订号是 <span class="hljs-string">&quot;0&quot;</span>，versio<span class="hljs-symbol">n2</span> 中下标为 <span class="hljs-number">0</span> 的修订号是 <span class="hljs-string">&quot;1&quot;</span> 。<span class="hljs-number">0</span> &lt; <span class="hljs-number">1</span>，所以 versio<span class="hljs-symbol">n1</span> &lt; versio<span class="hljs-symbol">n2</span></code></pre><pre><code class="hljs gcode">&gt;输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;1.0.1&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1&quot;</span>&gt;输出：<span class="hljs-number">1</span></code></pre><pre><code class="hljs gcode">&gt;输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;7.5.2.4&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;7.5.3&quot;</span>&gt;输出：<span class="hljs-number">-1</span></code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> compare<span class="hljs-constructor">Version(String <span class="hljs-params">version1</span>, String <span class="hljs-params">version2</span>)</span> &#123;        String<span class="hljs-literal">[]</span> a1 = version1.split(<span class="hljs-string">&quot;\\.&quot;</span>);        String<span class="hljs-literal">[]</span> a2 = version2.split(<span class="hljs-string">&quot;\\.&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> n = <span class="hljs-number">0</span>; n &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(a1.length, a2.length); n++) &#123;            <span class="hljs-built_in">int</span> i = n &lt; a1.length ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">a1</span>[<span class="hljs-params">n</span>])</span> : <span class="hljs-number">0</span> ;            <span class="hljs-built_in">int</span> j = n &lt; a2.length ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">a2</span>[<span class="hljs-params">n</span>])</span> : <span class="hljs-number">0</span> ;            <span class="hljs-keyword">if</span> (i &lt; j)                return -<span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; j)                return <span class="hljs-number">1</span>;            return <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><blockquote><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：target = 7, nums = [2,3,1,2,4,3]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：2</span><span class="hljs-meta">&gt;</span><span class="bash">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">target</span> = <span class="hljs-number">4</span>, <span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]&gt;输出：<span class="hljs-number">1</span></code></pre><pre><code class="hljs dns">&gt;输入：target = <span class="hljs-number">11</span>, nums = [<span class="hljs-number">1,1,1,1</span>,<span class="hljs-number">1,1,1,1</span>]&gt;输出：<span class="hljs-number">0</span></code></pre></blockquote><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> minSubArrayLen(<span class="hljs-built_in">int</span> s, <span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-comment">// 滑动窗口</span>        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.length; j++)&#123;            <span class="hljs-keyword">sum</span> += nums[j];            <span class="hljs-comment">// 注意这个骚条件</span>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">sum</span> &gt;= s)&#123;                len = len == <span class="hljs-number">0</span> ? j - i + <span class="hljs-number">1</span> : Math.min(len, j - i + <span class="hljs-number">1</span>);                <span class="hljs-comment">// 滑动</span>                <span class="hljs-keyword">sum</span> -= nums[i++];            &#125;        &#125;        <span class="hljs-keyword">return</span> len;    &#125;&#125;</code></pre><h3 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a>628. 三个数的最大乘积</h3><blockquote><p>给你一个整型数组 <code>nums</code> ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [1,2,3]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：6</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [1,2,3,4]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：24</span></code></pre><pre><code class="hljs subunit">&gt;输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-2</span>,<span class="hljs-string">-3</span>]&gt;输出：<span class="hljs-string">-6</span></code></pre></blockquote><pre><code class="hljs llvm">class Solution &#123;    public int maximumProduct(int[] nums) &#123;        int <span class="hljs-keyword">max</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE<span class="hljs-punctuation">,</span> <span class="hljs-keyword">max</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE<span class="hljs-punctuation">,</span> <span class="hljs-keyword">max</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE<span class="hljs-punctuation">,</span><span class="hljs-keyword">min</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE<span class="hljs-punctuation">,</span> <span class="hljs-keyword">min</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE<span class="hljs-comment">;</span>        for (int n : nums) &#123;            if (n &gt; <span class="hljs-keyword">max</span><span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">max</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span><span class="hljs-number">2</span><span class="hljs-comment">;</span>                <span class="hljs-keyword">max</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span><span class="hljs-number">1</span><span class="hljs-comment">;</span>                <span class="hljs-keyword">max</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> n<span class="hljs-comment">;</span>            &#125; else if (n &gt; <span class="hljs-keyword">max</span><span class="hljs-number">2</span>) &#123;                <span class="hljs-keyword">max</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">max</span><span class="hljs-number">2</span><span class="hljs-comment">;</span>                <span class="hljs-keyword">max</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> n<span class="hljs-comment">;</span>            &#125; else if (n &gt; <span class="hljs-keyword">max</span><span class="hljs-number">3</span>) &#123;                <span class="hljs-keyword">max</span><span class="hljs-number">3</span> <span class="hljs-operator">=</span> n<span class="hljs-comment">;</span>            &#125;            if (n &lt; <span class="hljs-keyword">min</span><span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">min</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">min</span><span class="hljs-number">1</span><span class="hljs-comment">;</span>                <span class="hljs-keyword">min</span><span class="hljs-number">1</span> <span class="hljs-operator">=</span> n<span class="hljs-comment">;</span>            &#125; else if (n &lt; <span class="hljs-keyword">min</span><span class="hljs-number">2</span>) &#123;                <span class="hljs-keyword">min</span><span class="hljs-number">2</span> <span class="hljs-operator">=</span> n<span class="hljs-comment">;</span>            &#125;        &#125;        return Math.<span class="hljs-keyword">max</span>(<span class="hljs-keyword">max</span><span class="hljs-number">1</span>*<span class="hljs-keyword">max</span><span class="hljs-number">2</span>*<span class="hljs-keyword">max</span><span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">max</span><span class="hljs-number">1</span>*<span class="hljs-keyword">min</span><span class="hljs-number">1</span>*<span class="hljs-keyword">min</span><span class="hljs-number">2</span>)<span class="hljs-comment">;</span>    &#125;&#125;</code></pre><h3 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a>179. 最大数</h3><blockquote><p>给定一组非负整数 nums，重新排列它们每个数字的顺序（每个数字不可拆分）使之组成一个最大的整数。</p><p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [10,2]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：<span class="hljs-string">&quot;210&quot;</span></span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [3,30,34,5,9]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：<span class="hljs-string">&quot;9534330&quot;</span></span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [1]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：<span class="hljs-string">&quot;1&quot;</span></span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [10]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：<span class="hljs-string">&quot;10&quot;</span></span></code></pre></blockquote><pre><code class="hljs livescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    public <span class="hljs-built_in">String</span> largestNumber(int[] nums) &#123;        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        int n = nums.length;        <span class="hljs-built_in">String</span>[] ss = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[n];        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; n; i++)            ss[i] = nums[i] + <span class="hljs-string">&quot;&quot;</span>;        Arrays.sort<span class="hljs-function"><span class="hljs-params">(ss, (a, b) -&gt; (b + a).compareTo(a + b))</span>;</span><span class="hljs-function">        <span class="hljs-title">StringBuilder</span> <span class="hljs-title">sb</span> = <span class="hljs-title">new</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(<span class="hljs-built_in">String</span> s : ss)</span></span><span class="hljs-function">            <span class="hljs-title">sb</span>.<span class="hljs-title">append</span><span class="hljs-params">(s)</span>;</span><span class="hljs-function">        <span class="hljs-title">String</span> <span class="hljs-title">res</span> = <span class="hljs-title">sb</span>.<span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span> == &#x27;0&#x27; ? &quot;0&quot; : <span class="hljs-title">sb</span>.<span class="hljs-title">toString</span><span class="hljs-params">()</span>;</span><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">res</span>;</span><span class="hljs-function">    &#125;</span><span class="hljs-function">&#125;</span></code></pre><h3 id="306-累加数"><a href="#306-累加数" class="headerlink" title="306. 累加数"></a>306. 累加数</h3><blockquote><p>累加数是一个字符串，组成它的数字可以形成累加序列。</p><p>一个有效的累加序列必须至少包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。</p><p>给定一个只包含数字 ‘0’-‘9’ 的字符串，编写一个算法来判断给定输入是否是累加数。</p><p>说明: 累加序列里的数不会以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。</p><pre><code class="hljs tap">&gt;输入: &quot;112358&quot;&gt;输出: true &gt;解释: 累加序列为: 1, 1, 2, 3, 5,<span class="hljs-number"> 8 </span>。1 +<span class="hljs-number"> 1 </span>= 2,<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>= 3,<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>= 5,<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>= 8</code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: <span class="hljs-string">&quot;199100199&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">true</span></span> <span class="hljs-meta">&gt;</span><span class="bash">解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAdditiveNumber</span><span class="hljs-params">(<span class="hljs-keyword">String</span> num)</span> </span>&#123;        <span class="hljs-keyword">return</span> dfs(num, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, num.length(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">// num:原始字符串 idx：当前处理的下标 sum：上一层的两数和</span>    <span class="hljs-comment">// len：字符串长度 pre：前一个数 k：当前已经处理数的个数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">String</span> num, <span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">long</span> sum, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">long</span> pre, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-comment">// 达到末尾，判断是否存在至少3个数</span>        <span class="hljs-keyword">if</span> (idx == len)            <span class="hljs-keyword">return</span> k &gt; <span class="hljs-number">2</span>;        <span class="hljs-comment">// [idx, i] 代表当前尝试的数</span>        <span class="hljs-comment">// 为了避免溢出long 使用结论：不存在符合条件的数，其长度超过原始字符串一半</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = idx + <span class="hljs-number">1</span>; i &lt;= len &amp;&amp; i - idx &lt;= len / <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-comment">// 剪枝：以0开头且不是单纯的0的数不符合题意</span>            <span class="hljs-keyword">if</span> (i != idx + <span class="hljs-number">1</span> &amp;&amp; num.charAt(idx) == <span class="hljs-string">&#x27;0&#x27;</span>)                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">long</span> cur = Long.parseLong(num.substring(idx, i));            <span class="hljs-comment">// 剪枝：校验两数和 不等于当前数</span>            <span class="hljs-keyword">if</span> (k &gt;= <span class="hljs-number">2</span> &amp;&amp; cur != sum)                <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 继续dfs</span>            <span class="hljs-keyword">if</span> (dfs(num, i, pre + cur, len, cur, k + <span class="hljs-number">1</span>))                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><h3 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h3><blockquote><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p><p>注意:</p><p>num 的长度小于 10002 且 ≥ k。<br>num 不会包含任何前导零。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: num = <span class="hljs-string">&quot;1432219&quot;</span>, k = 3</span><span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-string">&quot;1219&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: num = <span class="hljs-string">&quot;10200&quot;</span>, k = 1</span><span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-string">&quot;200&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: num = <span class="hljs-string">&quot;10&quot;</span>, k = 2</span><span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-string">&quot;0&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">解释: 从原数字移除所有的数字，剩余为空就是0。</span></code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public String remove<span class="hljs-constructor">Kdigits(String <span class="hljs-params">num</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;        <span class="hljs-keyword">if</span> (num.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span>k)            return <span class="hljs-string">&quot;0&quot;</span>;        StringBuilder s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">num</span>)</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;            <span class="hljs-built_in">int</span> idx = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt; s.length<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span> &gt;= s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span> - 1)</span>; j++)                idx = j;            s.delete(idx, idx + <span class="hljs-number">1</span>);            <span class="hljs-keyword">while</span> (s.length<span class="hljs-literal">()</span> &gt; <span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(0)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;0&#x27;</span>)                s.delete(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        &#125;        return s.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;    &#125;&#125;</code></pre><h3 id="求一个数的平方根，精度0-01"><a href="#求一个数的平方根，精度0-01" class="headerlink" title="求一个数的平方根，精度0.01"></a>求一个数的平方根，精度0.01</h3><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;    <span class="hljs-keyword">double</span> l = <span class="hljs-number">0</span>, r = a;    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;        <span class="hljs-keyword">double</span> m = l + (r - l) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">double</span> val = m * m - a;        <span class="hljs-keyword">if</span> (Math.<span class="hljs-built_in">abs</span>(val) &lt;= <span class="hljs-number">0.01</span>) &#123;            System.out.<span class="hljs-built_in">println</span>(m);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">0.01</span>)            r = m;        <span class="hljs-keyword">else</span>            l = m;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题相关算法题</title>
    <link href="/2021/03/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/03/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="0-1"><a href="#0-1" class="headerlink" title="0/1"></a>0/1</h3><h4 id="P1048-采药"><a href="#P1048-采药" class="headerlink" title="P1048 采药"></a>P1048 采药</h4><blockquote><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有 2 个整数 T和 M，用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。</p><p>接下来的 M行每行包括两个在 1到 100之间（包括 11和 100）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p><p>求规定时间内采到药物的最大总价值。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：</span><span class="hljs-meta">&gt;</span><span class="bash">70 3</span><span class="hljs-meta">&gt;</span><span class="bash">71 100</span><span class="hljs-meta">&gt;</span><span class="bash">69 1</span><span class="hljs-meta">&gt;</span><span class="bash">1 2</span><span class="hljs-meta">&gt;</span><span class="bash">输出：</span><span class="hljs-meta">&gt;</span><span class="bash">3</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> T = sc.nextInt();        <span class="hljs-keyword">int</span> m = sc.nextInt();        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            a[i] = sc.nextInt();            b[i] = sc.nextInt();        &#125;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">max</span>(T, a, b));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> T, <span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> [] b)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = T; j &gt;= a[i]; j--) &#123;                dp[j] = Math.<span class="hljs-built_in">max</span>(dp[j], dp[j - a[i]] + b[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[T];    &#125;&#125;</code></pre><h4 id="P1060-开心的金明"><a href="#P1060-开心的金明" class="headerlink" title="P1060 开心的金明"></a>P1060 开心的金明</h4><blockquote><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N<em>N</em>元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的N<em>N</em>元。于是，他把每件物品规定了一个重要度，分为55等：用整数1-51−5表示，第55等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过N<em>N</em>元（可以等于N<em>N</em>元）的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>设第j<em>j</em>件物品的价格为v[j]<em>v</em>[<em>j</em>]，重要度为w[j]<em>w</em>[<em>j</em>]，共选中了k<em>k</em>件物品，编号依次为j_1,j_2,…,j_k<em>j</em>1,<em>j</em>2,…,<em>j**k</em>，则所求的总和为：</p><p>v[j_1] \times w[j_1]+v[j_2] \times w[j_2]+ …+v[j_k] \times w[j_k]<em>v</em>[<em>j</em>1]×<em>w</em>[<em>j</em>1]+<em>v</em>[<em>j</em>2]×<em>w</em>[<em>j</em>2]+…+<em>v</em>[<em>j**k</em>]×<em>w</em>[<em>j**k</em>]。</p><p>请你帮助金明设计一个满足要求的购物单。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，为2个正整数，用一个空格隔开：n,m（其中N(&lt;30000)表示总钱数，m(&lt;25)为希望购买物品的个数。）</p><p>从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有2个非负整数v p（其中v*表示该物品的价格v≤10000)，p表示该物品的重要度(1-5)</p><p>输出不超过总钱数的物品的价格与重要度乘积的总和的最大值(&lt;100000000)</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span> <span class="hljs-meta">&gt;</span><span class="bash">1000 5</span><span class="hljs-meta">&gt;</span><span class="bash">800 2</span><span class="hljs-meta">&gt;</span><span class="bash">400 5</span><span class="hljs-meta">&gt;</span><span class="bash">300 5</span><span class="hljs-meta">&gt;</span><span class="bash">400 3</span><span class="hljs-meta">&gt;</span><span class="bash">200 2</span><span class="hljs-meta">&gt;</span><span class="bash">输出：</span><span class="hljs-meta">&gt;</span><span class="bash">3900</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> T = sc.nextInt(); <span class="hljs-comment">// 总钱数</span>        <span class="hljs-keyword">int</span> m = sc.nextInt(); <span class="hljs-comment">// 种类</span>        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            a[i] = sc.nextInt();            b[i] = prices[i] * sc.nextInt();        &#125;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">max</span>(T, a, a));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> T, <span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> [] a)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = T; j &gt;= a[i]; j--) &#123;                dp[j] = Math.<span class="hljs-built_in">max</span>(dp[j], dp[j - a[i]] + b[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[T];    &#125;&#125;</code></pre><h4 id="P1049-装箱问题"><a href="#P1049-装箱问题" class="headerlink" title="P1049 装箱问题"></a>P1049 装箱问题</h4><blockquote><p>有一个箱子容量为V正整数，0≤<em>V</em>≤20000），同时有n个物品（0&lt;<em>n</em>≤30，每个物品有一个体积（正整数）。</p><p>要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>1个整数，表示箱子容量</p><p>1个整数，表示有n个物品</p><p>接下来n行，分别表示这n个物品的各自体积</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>1个整数，表示箱子剩余空间。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：</span><span class="hljs-meta">&gt;</span><span class="bash">24</span><span class="hljs-meta">&gt;</span><span class="bash">6</span><span class="hljs-meta">&gt;</span><span class="bash">8</span><span class="hljs-meta">&gt;</span><span class="bash">3</span><span class="hljs-meta">&gt;</span><span class="bash">12</span><span class="hljs-meta">&gt;</span><span class="bash">7</span><span class="hljs-meta">&gt;</span><span class="bash">9</span><span class="hljs-meta">&gt;</span><span class="bash">7</span><span class="hljs-meta">&gt;</span><span class="bash">输出：</span><span class="hljs-meta">&gt;</span><span class="bash">0</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> T = sc.nextInt(); <span class="hljs-comment">// 箱子容量</span>        <span class="hljs-keyword">int</span> m = sc.nextInt(); <span class="hljs-comment">// m个物品</span>        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            a[i] = sc.nextInt();        &#125;        System.out.<span class="hljs-built_in">println</span>(T - <span class="hljs-built_in">max</span>(T, a, a));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> T, <span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> [] a)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = T; j &gt;= a[i]; j--) &#123;                dp[j] = Math.<span class="hljs-built_in">max</span>(dp[j], dp[j - a[i]] + a[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre><h4 id="P1164-小A点菜"><a href="#P1164-小A点菜" class="headerlink" title="P1164 小A点菜"></a>P1164 小A点菜</h4><blockquote><p>A身上有M元，去餐馆点菜。餐馆有N种，第i种卖ai元。每种菜只有一份。A想要点菜，正好吧身上钱花完，问一共有多少种点菜方法。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入格式</span><span class="hljs-meta">&gt;</span><span class="bash">第一行是两个数字，表示N和M。</span><span class="hljs-meta">&gt;</span><span class="bash">第二行起N个正数ai</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash">4 4</span><span class="hljs-meta">&gt;</span><span class="bash">1 1 2 2</span><span class="hljs-meta">&gt;</span><span class="bash">输出</span><span class="hljs-meta">&gt;</span><span class="bash">3</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> n = sc.nextInt(); <span class="hljs-comment">// 种类</span>        <span class="hljs-keyword">int</span> T = sc.nextInt(); <span class="hljs-comment">// 总钱</span>        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 多算一种</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            a[i] = sc.nextInt();        &#125;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">max</span>(T, a));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> T, <span class="hljs-keyword">int</span>[] a)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = T; j &gt;= a[i]; j--) &#123;                dp[j] += dp[j - a[i]]; <span class="hljs-comment">// 转移 求方案数 累加</span>            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[T];    &#125;&#125;</code></pre><h4 id="P1510-精卫填海"><a href="#P1510-精卫填海" class="headerlink" title="P1510 精卫填海"></a>P1510 精卫填海</h4><blockquote><p>东海未填平的区域还需要至少体积为v的木石才可以填平，而西山上的木石还剩下n块，每块的体积和把它衔到东海需要的体力分别为k和m。精卫已经填海填了这么长时间了，她也很累了，她还剩下的体力为c。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入格式</span><span class="hljs-meta">&gt;</span><span class="bash">输入文件的第一行是三个整数：v、n、c。</span><span class="hljs-meta">&gt;</span><span class="bash">从第二行到第n+1行分别为每块木石的体积和把它衔到东海需要的体力。</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash">100 2 10</span><span class="hljs-meta">&gt;</span><span class="bash">50 5</span><span class="hljs-meta">&gt;</span><span class="bash">50 5</span><span class="hljs-meta">&gt;</span><span class="bash">输出</span><span class="hljs-meta">&gt;</span><span class="bash">0</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash">10 2 1</span><span class="hljs-meta">&gt;</span><span class="bash">50 5</span><span class="hljs-meta">&gt;</span><span class="bash">10 2</span><span class="hljs-meta">&gt;</span><span class="bash">输出</span><span class="hljs-meta">&gt;</span><span class="bash">Impossible</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> T = sc.nextInt(); <span class="hljs-comment">// 还剩T体积填完</span>        <span class="hljs-keyword">int</span> n = sc.nextInt(); <span class="hljs-comment">// n块石头</span>        <span class="hljs-keyword">int</span> c = sc.nextInt(); <span class="hljs-comment">// 体力</span>        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            a[i] = sc.nextInt();            b[i] = sc.nextInt();        &#125;        <span class="hljs-keyword">int</span> k = <span class="hljs-built_in">max</span>(T, a, b, c);        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">-1</span>)            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Impossible&quot;</span>);        <span class="hljs-keyword">else</span>            System.out.<span class="hljs-built_in">println</span>(k);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> T, <span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[c + <span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = c; j &gt;= b[i]; j--) &#123;                dp[j] = Math.<span class="hljs-built_in">max</span>(dp[j], dp[j - b[i]] + a[i]);                <span class="hljs-keyword">if</span> (dp[j] &gt;= T) <span class="hljs-comment">// 填完判断</span>                    ans = Math.<span class="hljs-built_in">max</span>(ans, c - j);            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre><h4 id="找零钱的硬币数组合"><a href="#找零钱的硬币数组合" class="headerlink" title="找零钱的硬币数组合"></a>找零钱的硬币数组合</h4><blockquote><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><pre><code class="hljs subunit">&gt;输入: amount = 5, coins = [1, 2, 5]&gt;输出: 4&gt;解释: 有四种方式可以凑成总金额:&gt;5=5&gt;5=2<span class="hljs-string">+2</span><span class="hljs-string">+1</span>&gt;5=2<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span>&gt;5=1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span></code></pre><pre><code class="hljs makefile"><span class="hljs-section">&gt;输入: amount = 3, coins = [2]</span><span class="hljs-section">&gt;输出: 0</span><span class="hljs-section">&gt;解释: 只用面额2的硬币不能凑成总金额3。</span></code></pre><pre><code class="hljs makefile"><span class="hljs-section">&gt;输入: amount = 10, coins = [10] </span><span class="hljs-section">&gt;输出: 1</span></code></pre></blockquote><pre><code class="hljs groovy"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> change(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins) &#123;        <span class="hljs-keyword">if</span> (coins == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-attr">coin :</span> coins) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = coin; i &lt;= amount; i++) &#123;                dp[i] += dp[i - coin];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[amount];    &#125;&#125;</code></pre><h4 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h4><blockquote><p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><pre><code class="hljs prolog">&gt;输入: [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>]&gt;输出: true&gt;解释: 数组可以分割成 [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>] 和 [<span class="hljs-number">11</span>].</code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: [1, 2, 3, 5]</span><span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">false</span></span><span class="hljs-meta">&gt;</span><span class="bash">解释: 数组不能分割成两个元素和相等的子集</span></code></pre></blockquote><p>0/1背包</p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> canPartition(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = computeArraySum(nums);        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-built_in">int</span> w = <span class="hljs-keyword">sum</span> / <span class="hljs-number">2</span>;        <span class="hljs-built_in">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">boolean</span>[w + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> num : nums) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = w; i &gt;= num; i--) &#123;                dp[i] = dp[i] || dp[i - num];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[w];    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> computeArraySum(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> num : nums) &#123;            <span class="hljs-keyword">sum</span> += num;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">sum</span>;    &#125;&#125;</code></pre><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="P1616-疯狂的采药"><a href="#P1616-疯狂的采药" class="headerlink" title="P1616 疯狂的采药"></a>P1616 疯狂的采药</h4><blockquote><p>输入第一行有两个整数，分别代表总共能够用来采药的时间 t和代表山洞里的草药的数目 m。</p><p>第 2到第 (m + 1) 行，每行两个整数，第 (i + 1)行的整数 ai, bi 分别表示采摘第 i 种草药的时间和该草药的价值。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash">70 3</span><span class="hljs-meta">&gt;</span><span class="bash">71 100</span><span class="hljs-meta">&gt;</span><span class="bash">69 1</span><span class="hljs-meta">&gt;</span><span class="bash">1 2</span><span class="hljs-meta">&gt;</span><span class="bash">输出</span><span class="hljs-meta">&gt;</span><span class="bash">140</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> T = sc.nextInt();        <span class="hljs-keyword">int</span> n = sc.nextInt();        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            a[i] = sc.nextInt();            b[i] = sc.nextInt();        &#125;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">max</span>(T, a, b));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> T, <span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = a[i]; j &lt;= T; j++) &#123;                dp[j] = Math.<span class="hljs-built_in">max</span>(dp[j], dp[j - a[i]] + b[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[T];    &#125;&#125;</code></pre><h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h4><blockquote><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：coins = [1, 2, 5], amount = 11</span><span class="hljs-meta">&gt;</span><span class="bash">输出：3</span> <span class="hljs-meta">&gt;</span><span class="bash">解释：11 = 5 + 5 + 1</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">2</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">3</span>&gt;输出：-<span class="hljs-number">1</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">0</span>&gt;输出：<span class="hljs-number">0</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">1</span>&gt;输出：<span class="hljs-number">1</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">2</span>&gt;输出：<span class="hljs-number">2</span></code></pre></blockquote><p>完全背包问题</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = coin; i &lt;= amount; i++) &#123; <span class="hljs-comment">//将逆序遍历改为正序遍历</span>            <span class="hljs-comment">// 三种情况</span>                <span class="hljs-keyword">if</span> (i == coin) &#123;                    dp[i] = <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">0</span> &amp;&amp; dp[i - coin] != <span class="hljs-number">0</span>) &#123;                    dp[i] = dp[i - coin] + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i - coin] != <span class="hljs-number">0</span>) &#123;                    dp[i] = Math.<span class="hljs-built_in">min</span>(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : dp[amount];    &#125;&#125;</code></pre><h4 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h4><blockquote><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: s = <span class="hljs-string">&quot;leetcode&quot;</span>, wordDict = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]</span><span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">true</span></span><span class="hljs-meta">&gt;</span><span class="bash">解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;leet code&quot;</span>。</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: s = <span class="hljs-string">&quot;applepenapple&quot;</span>, wordDict = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pen&quot;</span>]</span><span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">true</span></span><span class="hljs-meta">&gt;</span><span class="bash">解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;applepenapple&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;apple pen apple&quot;</span>。</span>    注意你可以重复使用字典中的单词。</code></pre><pre><code class="hljs nix">&gt;输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;catsandog&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]&gt;输出: <span class="hljs-literal">false</span></code></pre></blockquote><p>求解顺序的完全背包问题</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s, List&lt;<span class="hljs-keyword">String</span>&gt; wordDict)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span>: wordDict) &#123;                <span class="hljs-comment">// 对物品的迭代应该放在最里层</span>                <span class="hljs-keyword">int</span> len = <span class="hljs-keyword">word</span>.length();                <span class="hljs-keyword">if</span> (len &lt;= i &amp;&amp; <span class="hljs-keyword">word</span>.equals(s.substring(i - len , i))) &#123;                    dp[i] = dp[i] || dp[i - len];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><blockquote><p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。</p><p>输出为：对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：</span><span class="hljs-meta">&gt;</span><span class="bash">1</span><span class="hljs-meta">&gt;</span><span class="bash">8 2</span><span class="hljs-meta">&gt;</span><span class="bash">2 100 4</span><span class="hljs-meta">&gt;</span><span class="bash">4 100 2</span><span class="hljs-meta">&gt;</span><span class="bash">输出：</span><span class="hljs-meta">&gt;</span><span class="bash">400</span></code></pre></blockquote><blockquote><p>有一个体积为V的背包，有m种物品，每种物品有体积和价值，且数量一定。求背包能装下的最大价值。</p><p>输入为第一行两个整数V和m。接下来m行，每行3个整数，表示第i种物品的数量、体积和价值。</p><p>输出为一个整数，表示背包能装下的最大价值。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：</span><span class="hljs-meta">&gt;</span><span class="bash">10 4</span><span class="hljs-meta">&gt;</span><span class="bash">2 3 2</span><span class="hljs-meta">&gt;</span><span class="bash">2 4 3</span><span class="hljs-meta">&gt;</span><span class="bash">1 2 2</span><span class="hljs-meta">&gt;</span><span class="bash">4 5 3</span><span class="hljs-meta">&gt;</span><span class="bash">输出：</span><span class="hljs-meta">&gt;</span><span class="bash">8</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> n = sc.nextInt(); <span class="hljs-comment">// money</span>        <span class="hljs-keyword">int</span> m = sc.nextInt(); <span class="hljs-comment">// m种类</span>        <span class="hljs-keyword">int</span>[] prices = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            prices[i] = sc.nextInt();            weights[i] = sc.nextInt();            nums[i] = sc.nextInt();        &#125;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">max</span>(n, prices, weights, nums));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span>[] weights, <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt;= prices[i]; j--) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= nums[i] &amp;&amp; k * prices[i] &lt;= j; k++) &#123;                    dp[j] = Math.<span class="hljs-built_in">max</span>(dp[j], dp[j - k * prices[i]] + k * weights[i]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre><h3 id="多维费用背包"><a href="#多维费用背包" class="headerlink" title="多维费用背包"></a>多维费用背包</h3><h4 id="P1507-NASA的食物计划"><a href="#P1507-NASA的食物计划" class="headerlink" title="P1507 NASA的食物计划"></a>P1507 NASA的食物计划</h4><blockquote><p>航天飞机的体积有限,当然如果载过重的物品,燃料会浪费很多钱,每件食品都有各自的体积、质量以及所含卡路里,在告诉你体积和质量的最大值的情况下,请输出能达到的食品方案所含卡路里的最大值,当然每个食品只能使用一次.</p><p>输入为：</p><p>第一行 两个数 体积最大值(&lt;400)和质量最大值(&lt;400)</p><p>第二行 一个数 食品总数N(&lt;50).</p><p>第三行－第3+N行</p><p>每行三个数 体积(&lt;400) 质量(&lt;400) 所含卡路里(&lt;500)</p><p>输出为：</p><p>一个数 所能达到的最大卡路里(int范围内)</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：</span><span class="hljs-meta">&gt;</span><span class="bash">320 350</span><span class="hljs-meta">&gt;</span><span class="bash">4</span><span class="hljs-meta">&gt;</span><span class="bash">160 40 120</span><span class="hljs-meta">&gt;</span><span class="bash">80 110 240</span><span class="hljs-meta">&gt;</span><span class="bash">220 70 310</span><span class="hljs-meta">&gt;</span><span class="bash">40 400 220</span><span class="hljs-meta">&gt;</span><span class="bash">输出：</span><span class="hljs-meta">&gt;</span><span class="bash">550</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> vMax = sc.nextInt();        <span class="hljs-keyword">int</span> mMax = sc.nextInt();        <span class="hljs-keyword">int</span> m = sc.nextInt();        <span class="hljs-keyword">int</span>[] vs = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">int</span>[] ms = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">int</span>[] kas = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            vs[i] = sc.nextInt();            ms[i] = sc.nextInt();            kas[i] = sc.nextInt();        &#125;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">max</span>(vMax, mMax, vs, ms, kas));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vMax, <span class="hljs-keyword">int</span> mMax, <span class="hljs-keyword">int</span>[] vs, <span class="hljs-keyword">int</span>[] ms, <span class="hljs-keyword">int</span>[] kas)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[vMax + <span class="hljs-number">1</span>][mMax + <span class="hljs-number">1</span>];        <span class="hljs-comment">// 种类</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; vs.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = vMax; j &gt;= vs[i]; j--) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = mMax; k &gt;= ms[i]; k--) &#123;                    dp[j][k] = Math.<span class="hljs-built_in">max</span>(dp[j][k], dp[j - vs[i]][k - ms[i]] + kas[i]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[vMax][mMax];    &#125;&#125;</code></pre><h4 id="1和0"><a href="#1和0" class="headerlink" title="1和0"></a>1和0</h4><blockquote><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：strs = [<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;0001&quot;</span>, <span class="hljs-string">&quot;111001&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>], m = 5, n = 3</span><span class="hljs-meta">&gt;</span><span class="bash">输出：4</span><span class="hljs-meta">&gt;</span><span class="bash">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>&#125; ，因此答案是 4 。</span><span class="hljs-meta">&gt;</span><span class="bash">其他满足题意但较小的子集包括 &#123;<span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>&#125; 和 &#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>&#125; 。&#123;<span class="hljs-string">&quot;111001&quot;</span>&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">strs</span> = [<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>], <span class="hljs-attr">m</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">1</span>&gt;输出：<span class="hljs-number">2</span>&gt;解释：最大的子集是 &#123;<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>&#125; ，所以答案是 <span class="hljs-number">2</span> 。</code></pre></blockquote><p>这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span> (strs == null || strs.length == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">// 俩包， 0 1</span>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> s : strs)&#123;            <span class="hljs-keyword">int</span> zeros = <span class="hljs-number">0</span>, ones = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray())&#123;                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;0&#x27;</span>)                    zeros++; <span class="hljs-comment">// 统计数量</span>                <span class="hljs-keyword">else</span>                     ones++; <span class="hljs-comment">// 统计数量</span>            &#125;            <span class="hljs-comment">// 开始dp</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m; i &gt;= zeros; i--)&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n; j &gt;= ones; j--)&#123;                    <span class="hljs-comment">// 优化过后的dp</span>                    dp[i][j] = Math.<span class="hljs-built_in">max</span>(dp[i][j], dp[i - zeros][j - ones] + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;         <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序相关算法题</title>
    <link href="/2021/03/22/%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/03/22/%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ul><pre><code class="hljs excel">public class MergeSort &#123;    public static void mergeSort(<span class="hljs-built_in">int</span>[] arr) &#123;        <span class="hljs-built_in">if</span> (arr == null || arr.length &lt; <span class="hljs-number">2</span>) &#123;            return;        &#125;        mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);    &#125;    public static void mergeSort(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>) &#123;        <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> == <span class="hljs-built_in">right</span>) return;        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span> + ((<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) &gt;&gt; <span class="hljs-number">1</span>);        // <span class="hljs-built_in">left</span>        mergeSort(arr, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span>);        // <span class="hljs-built_in">right</span>        mergeSort(arr, <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>);        // merge        merge(arr, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span>, <span class="hljs-built_in">right</span>);    &#125;    public static void merge(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>) &#123;        <span class="hljs-built_in">int</span>[] help = new <span class="hljs-built_in">int</span>[<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span> + <span class="hljs-number">1</span>];        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> <span class="hljs-symbol">p1</span> = <span class="hljs-built_in">left</span>;        <span class="hljs-built_in">int</span> <span class="hljs-symbol">p2</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;        while (<span class="hljs-symbol">p1</span> &lt;= <span class="hljs-built_in">mid</span> &amp;&amp; <span class="hljs-symbol">p2</span> &lt;= <span class="hljs-built_in">right</span>) &#123;            help[i++] = arr[<span class="hljs-symbol">p1</span>] &lt; arr[<span class="hljs-symbol">p2</span>] ? arr[<span class="hljs-symbol">p1</span>++] <span class="hljs-symbol">:</span> arr[<span class="hljs-symbol">p2</span>++];        &#125;        while(<span class="hljs-symbol">p1</span> &lt;= <span class="hljs-built_in">mid</span>) &#123;            help[i++] = arr[<span class="hljs-symbol">p1</span>++];        &#125;        while(<span class="hljs-symbol">p2</span> &lt;= <span class="hljs-built_in">right</span>) &#123;            help[i++] = arr[<span class="hljs-symbol">p2</span>++];        &#125;        for (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; help.length; j++) &#123;            arr[<span class="hljs-built_in">left</span> + j] = help[j];        &#125;    &#125;&#125;</code></pre><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><ul><li>从数列中挑出一个元素，称为”基准”；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以放到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作；</li><li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ul><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] quickSort(<span class="hljs-built_in">int</span>[] arr) &#123;        <span class="hljs-keyword">return</span> quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] quickSort(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right) &#123;        <span class="hljs-keyword">if</span> (left &lt; right) &#123;            <span class="hljs-built_in">int</span> partitionIndex = partition(arr, left, right);            <span class="hljs-comment">// 左半部分递归</span>            quickSort(arr, left, partitionIndex - <span class="hljs-number">1</span>);            <span class="hljs-comment">// 右半部分递归</span>            quickSort(arr, partitionIndex + <span class="hljs-number">1</span>, right);        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> partition(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> left, <span class="hljs-built_in">int</span> right) &#123;        <span class="hljs-built_in">int</span> pivot = left;        <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = pivot + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-keyword">index</span>; i &lt;= right; i++) &#123;            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;                swap(arr, i, <span class="hljs-keyword">index</span>++);            &#125;        &#125;        swap(arr, pivot, <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> swap(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;        <span class="hljs-built_in">int</span> temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    &#125;&#125;</code></pre><h3 id="1、最小的k个数"><a href="#1、最小的k个数" class="headerlink" title="1、最小的k个数"></a>1、<a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">最小的k个数</a></h3><blockquote><p>给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K&gt;数组的长度，那么返回一个空的数组</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash">[4,5,1,6,2,7,3,8],4</span><span class="hljs-meta">&gt;</span><span class="bash">返回值</span><span class="hljs-meta">&gt;</span><span class="bash">[1,2,3,4]</span></code></pre></blockquote><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-built_in">public</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt; GetLeastNumbers_Solution(<span class="hljs-type">int</span> [] <span class="hljs-keyword">input</span>, <span class="hljs-type">int</span> k) &#123;        ArrayList&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (input == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">input</span>.length == <span class="hljs-number">0</span> || k &gt; <span class="hljs-keyword">input</span>.length) <span class="hljs-keyword">return</span> list;        Arrays.sort(<span class="hljs-keyword">input</span>);        // 犯规就犯规        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;            list.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">input</span>[i]);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><h3 id="2-数组中的第K个最大元素-855"><a href="#2-数组中的第K个最大元素-855" class="headerlink" title="2. 数组中的第K个最大元素(855)"></a>2. 数组中的第K个最大元素(855)</h3><blockquote><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><pre><code class="hljs makefile"><span class="hljs-section">&gt;输入: [3,2,1,5,6,4] 和 k = 2</span><span class="hljs-section">&gt;输出: 5</span><span class="hljs-section">&gt;输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><span class="hljs-section">&gt;输出: 4</span></code></pre></blockquote><p>排序 ：时间复杂度 O(NlogN)，空间复杂度 O(1)</p><pre><code class="hljs reasonml">public <span class="hljs-built_in">int</span> find<span class="hljs-constructor">KthLargest(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(nums);    return nums<span class="hljs-literal">[<span class="hljs-identifier">nums</span>.<span class="hljs-identifier">length</span> - <span class="hljs-identifier">k</span>]</span>;&#125;</code></pre><p>堆 ：时间复杂度 O(NlogK)，空间复杂度 O(K)。</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(); <span class="hljs-comment">// 小顶堆</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : nums) &#123;        pq.add(val);        <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>() &gt; k)  <span class="hljs-comment">// 维护堆的大小为 K</span>            pq.poll();    &#125;    <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">peek</span>();&#125;</code></pre><p>快排</p><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> findKthLargest(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k) &#123;    <span class="hljs-comment">// 注意k</span>    k = nums.length - k;    <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, h = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (l &lt; h) &#123;        <span class="hljs-built_in">int</span> j = partition(nums, l, h);        <span class="hljs-keyword">if</span> (j == k) &#123;            <span class="hljs-keyword">break</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; k) &#123;            l = j + <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            h = j - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> nums[k];&#125;<span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> partition(<span class="hljs-built_in">int</span>[] a, <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> h) &#123;    <span class="hljs-built_in">int</span> pivot = l;    <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = pivot + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-keyword">index</span>; i &lt;= h; i++) &#123;        <span class="hljs-keyword">if</span> (a[i] &lt; a[pivot])            swap(a, i, <span class="hljs-keyword">index</span>++);    &#125;    swap(a, pivot, <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> swap(<span class="hljs-built_in">int</span>[] a, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;    <span class="hljs-built_in">int</span> t = a[i];    a[i] = a[j];    a[j] = t;&#125;</code></pre><h3 id="3-寻找两个正序数组的中位数"><a href="#3-寻找两个正序数组的中位数" class="headerlink" title="3. 寻找两个正序数组的中位数"></a>3. 寻找两个正序数组的中位数</h3><blockquote><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><pre><code class="hljs inform7">&gt;输入：nums1 = <span class="hljs-comment">[1,3]</span>, nums2 = <span class="hljs-comment">[2]</span>&gt;输出：2.00000&gt;解释：合并数组 = <span class="hljs-comment">[1,2,3]</span> ，中位数 2</code></pre><pre><code class="hljs gcode">&gt;输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]&gt;输出：<span class="hljs-number">2.50000</span>&gt;解释：合并数组 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] ，中位数 <span class="hljs-comment">(2 + 3)</span> / <span class="hljs-number">2</span> = <span class="hljs-number">2.5</span></code></pre><pre><code class="hljs gcode">&gt;输入：<span class="hljs-symbol">nums1</span> = [], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>]&gt;输出：<span class="hljs-number">1.00000</span></code></pre><pre><code class="hljs gcode">&gt;输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]&gt;输出：<span class="hljs-number">0.00000</span></code></pre></blockquote><p>// 归并</p><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-built_in">public</span> <span class="hljs-type">double</span> findMedianSortedArrays(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;        <span class="hljs-type">int</span>[] <span class="hljs-keyword">temp</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[nums1.length + nums2.length];        // 归并，三个指针，走起        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;            <span class="hljs-keyword">temp</span>[t++] = nums1[i] &lt;= nums2[j] ? nums1[i++] : nums2[j++];        &#125;        <span class="hljs-keyword">while</span> (i &lt; nums1.length) &#123;            <span class="hljs-keyword">temp</span>[t++] = nums1[i++];        &#125;        <span class="hljs-keyword">while</span> (j &lt; nums2.length) &#123;            <span class="hljs-keyword">temp</span>[t++]  = nums2[j++];        &#125;        // 加起来，取中位数        <span class="hljs-type">double</span> b = (<span class="hljs-keyword">temp</span>[(<span class="hljs-keyword">temp</span>.length - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] + <span class="hljs-keyword">temp</span>[<span class="hljs-keyword">temp</span>.length / <span class="hljs-number">2</span>]) * <span class="hljs-number">1.0</span> / <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> b;    &#125;&#125;</code></pre><h3 id="4-根据字符出现频率排序"><a href="#4-根据字符出现频率排序" class="headerlink" title="4. 根据字符出现频率排序"></a>4. 根据字符出现频率排序</h3><pre><code class="hljs reasonml"><span class="hljs-comment">// 注意list的sort</span><span class="hljs-keyword">class</span> Solution &#123;    public String frequency<span class="hljs-constructor">Sort(String <span class="hljs-params">s</span>)</span> &#123;        <span class="hljs-keyword">if</span> (s<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>s.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>)            return s;        <span class="hljs-comment">// 先map统计</span>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length<span class="hljs-literal">()</span>; i++)&#123;            <span class="hljs-built_in">char</span> c = s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>;            map.put(c, map.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">c</span>, 0)</span> + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">// 然后map.entrySet传进来</span>        List&lt;Map.Entry&lt;Character, Integer&gt;&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(map.entry<span class="hljs-constructor">Set()</span>);        <span class="hljs-comment">// 按照value排序</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>sort(<span class="hljs-built_in">list</span>, (o1, o2) -&gt; &#123;            return o2.get<span class="hljs-constructor">Value()</span> - o1.get<span class="hljs-constructor">Value()</span>;        &#125;);        <span class="hljs-comment">// list</span>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;        <span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : <span class="hljs-built_in">list</span>)&#123;            <span class="hljs-built_in">int</span> cnt = entry.get<span class="hljs-constructor">Value()</span>;            <span class="hljs-built_in">char</span> key = entry.get<span class="hljs-constructor">Key()</span>;            <span class="hljs-keyword">while</span> (cnt-- &gt; <span class="hljs-number">0</span>)                sb.append(key);        &#125;        return sb.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高热度题参要</title>
    <link href="/2021/03/21/%E9%AB%98%E7%83%AD%E5%BA%A6%E9%A2%98/"/>
    <url>/2021/03/21/%E9%AB%98%E7%83%AD%E5%BA%A6%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><pre><code class="hljs inform7">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。给定 nums = <span class="hljs-comment">[2, 7, 11, 15]</span>, target = 9因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> = 2 + 7 = 9所以返回 <span class="hljs-comment">[0, 1]</span></code></pre><p><strong>双指针</strong></p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] twoSum(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target) &#123;        <span class="hljs-built_in">int</span> p1 = <span class="hljs-number">0</span>, p2 = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;            <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = nums[p1] + nums[p2];            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> &lt; target)                 p1++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> &gt; target)                 p2--;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span>                 <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;p1, p2&#125;;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;&#125;;    &#125;&#125;</code></pre><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h2><pre><code class="hljs clean">给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 <span class="hljs-number">0</span> 之外，这两个数都不会以 <span class="hljs-number">0</span> 开头。输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span></code></pre><ol><li>两个链表相加，先判断边界</li><li>创建一个新的链表</li><li>while中也要注意边界</li><li>两个链表的值、进位相加</li><li>是否赋值给进位</li><li>三个链表移动指针</li></ol><pre><code class="hljs yaml"><span class="hljs-string">class</span> <span class="hljs-string">Solution</span> &#123;    <span class="hljs-string">public</span> <span class="hljs-string">ListNode</span> <span class="hljs-string">addTwoNumbers(ListNode</span> <span class="hljs-string">l1</span>, <span class="hljs-string">ListNode</span> <span class="hljs-string">l2)</span> &#123;        <span class="hljs-string">if</span> <span class="hljs-string">(l1</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">l2</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> <span class="hljs-string">return</span> <span class="hljs-literal">null</span><span class="hljs-string">;</span>        <span class="hljs-string">if</span> <span class="hljs-string">(l1</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> <span class="hljs-string">return</span> <span class="hljs-string">l2;</span>        <span class="hljs-string">if</span> <span class="hljs-string">(l2</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> <span class="hljs-string">return</span> <span class="hljs-string">l1;</span>        <span class="hljs-string">ListNode</span> <span class="hljs-string">p1</span> <span class="hljs-string">=</span> <span class="hljs-string">l1;</span>        <span class="hljs-string">ListNode</span> <span class="hljs-string">p2</span> <span class="hljs-string">=</span> <span class="hljs-string">l2;</span>        <span class="hljs-string">ListNode</span> <span class="hljs-string">l3</span> <span class="hljs-string">=</span> <span class="hljs-string">new</span> <span class="hljs-string">ListNode(-1);</span>        <span class="hljs-string">ListNode</span> <span class="hljs-string">p3</span> <span class="hljs-string">=</span> <span class="hljs-string">l3;</span>        <span class="hljs-string">int</span> <span class="hljs-string">carried</span> <span class="hljs-string">=</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>        <span class="hljs-string">while</span> <span class="hljs-string">(p1</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">||</span> <span class="hljs-string">p2</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> &#123;            <span class="hljs-string">int</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> <span class="hljs-string">p1</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">?</span> <span class="hljs-attr">p1.val :</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>            <span class="hljs-string">int</span> <span class="hljs-string">b</span> <span class="hljs-string">=</span> <span class="hljs-string">p2</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">?</span> <span class="hljs-attr">p2.val :</span> <span class="hljs-number">0</span><span class="hljs-string">;</span>            <span class="hljs-string">p3.next</span> <span class="hljs-string">=</span> <span class="hljs-string">new</span> <span class="hljs-string">ListNode((a</span> <span class="hljs-string">+</span> <span class="hljs-string">b</span> <span class="hljs-string">+</span> <span class="hljs-string">carried)</span> <span class="hljs-string">%</span> <span class="hljs-number">10</span><span class="hljs-string">);</span>            <span class="hljs-string">carried</span> <span class="hljs-string">=</span> <span class="hljs-string">(a</span> <span class="hljs-string">+</span> <span class="hljs-string">b</span> <span class="hljs-string">+</span> <span class="hljs-string">carried)</span> <span class="hljs-string">/</span> <span class="hljs-number">10</span><span class="hljs-string">;</span>            <span class="hljs-string">p3</span> <span class="hljs-string">=</span> <span class="hljs-string">p3.next;</span>            <span class="hljs-string">p1</span> <span class="hljs-string">=</span> <span class="hljs-string">p1</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">?</span> <span class="hljs-attr">p1.next :</span> <span class="hljs-literal">null</span><span class="hljs-string">;</span>            <span class="hljs-string">p2</span> <span class="hljs-string">=</span> <span class="hljs-string">p2</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span> <span class="hljs-string">?</span> <span class="hljs-attr">p2.next :</span> <span class="hljs-literal">null</span><span class="hljs-string">;</span>        &#125;        <span class="hljs-string">p3.next</span> <span class="hljs-string">=</span> <span class="hljs-string">carried</span> <span class="hljs-type">!=</span> <span class="hljs-number">0</span> <span class="hljs-string">?</span> <span class="hljs-string">new</span> <span class="hljs-string">ListNode(1)</span> <span class="hljs-string">:</span> <span class="hljs-literal">null</span><span class="hljs-string">;</span>        <span class="hljs-string">return</span> <span class="hljs-string">l3.next;</span>    &#125;&#125;</code></pre><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h2><pre><code class="hljs makefile">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<span class="hljs-section">输入: &quot;abcabcbb&quot;</span><span class="hljs-section">输出: 3 </span><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><span class="hljs-section">输入: &quot;bbbbb&quot;</span><span class="hljs-section">输出: 1</span><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></code></pre><p>HashMap+两个指针 两个指针分别记录字母的起始和结束，用map来存</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLongestSubstring(String <span class="hljs-params">s</span>)</span> &#123;        <span class="hljs-built_in">int</span> n = s.length<span class="hljs-literal">()</span>, ans = <span class="hljs-number">0</span>;        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span> (map.contains<span class="hljs-constructor">Key(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">j</span>)</span>)) &#123;                i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(map.get(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>), i);            &#125;            ans = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(ans, j - i + <span class="hljs-number">1</span>);            map.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>, j + <span class="hljs-number">1</span>);        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><pre><code class="hljs 1c">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 <span class="hljs-number">1000</span>。输入: <span class="hljs-string">&quot;babad&quot;</span>输出: <span class="hljs-string">&quot;bab&quot;</span>注意: <span class="hljs-string">&quot;aba&quot;</span> 也是一个有效答案。</code></pre><p>中心扩展</p><ul><li>两种情况</li><li>奇数长度</li><li>偶数长度</li><li>取最长，求起始和结束位置</li><li>用substring即可</li></ul><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == null || s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, <span class="hljs-built_in">end</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录起始位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;            <span class="hljs-comment">// 两种情况 以i为中心，以i和i+1为中心</span>            <span class="hljs-keyword">int</span> len1 = expand(s, i - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 中心扩展 </span>            <span class="hljs-keyword">int</span> len2 = expand(s, i, i + <span class="hljs-number">1</span>);            <span class="hljs-keyword">int</span> len = Math.<span class="hljs-built_in">max</span>(len1, len2); <span class="hljs-comment">// 取最长的长度</span>            <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-built_in">end</span> - start) &#123;                start = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;                <span class="hljs-built_in">end</span> = i + len / <span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> s.substring(start, <span class="hljs-built_in">end</span> + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;            l--;            r++;        &#125;        <span class="hljs-comment">// 这里要注意</span>        <span class="hljs-keyword">return</span> r - l - <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a>6. Z 字形变换</h2><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>     <span class="hljs-comment">// 0|     1   5   9     13</span>     <span class="hljs-comment">// 1|     2 4 6 8 10 12 14 16</span>     <span class="hljs-comment">// 2|     3   7   11    15</span>     <span class="hljs-comment">// 每一行右边的字符的 ’索引值’ 都是其左边的字符的 ’索引值’ 加上它 ’下面剩余行数’ 的两倍或 ’上面行数’ 的两倍（交替相加）</span>    <span class="hljs-comment">// 以第二行为例，</span>    <span class="hljs-comment">// 对于4这个字符而言， 4 = 2(左边的索引) + 2(两倍) * 1(下面有一行)</span>    <span class="hljs-comment">// 6 = 4 + 2 * 1(上面有一行)</span>    <span class="hljs-comment">// 8 = 6 + 2 * 1(下面有一行)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s, <span class="hljs-keyword">int</span> numRows)</span> </span>&#123;        <span class="hljs-keyword">if</span> (numRows &lt;= <span class="hljs-number">1</span>)            <span class="hljs-keyword">return</span> s;                <span class="hljs-keyword">char</span>[] cs = s.toCharArray();        <span class="hljs-keyword">String</span> res = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++)&#123;            <span class="hljs-keyword">int</span> up = i; <span class="hljs-comment">// 上方的行数</span>            <span class="hljs-keyword">int</span> down = numRows - <span class="hljs-number">1</span> - i; <span class="hljs-comment">// 下方的行数</span>            <span class="hljs-keyword">int</span> temp = i;            <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (temp &lt; cs.length)&#123;                <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; down != <span class="hljs-number">0</span>) &#123;                    res += cs[temp];                    temp += <span class="hljs-number">2</span> * down;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &amp;&amp; up != <span class="hljs-number">0</span>)&#123;                    res += cs[temp];                    temp += <span class="hljs-number">2</span> * up;                &#125;                cnt++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h2><pre><code class="hljs arduino">给出一个 <span class="hljs-number">32</span> 位的有符号整数，你需要将这个整数中每位上的数字进行反转。输入: <span class="hljs-number">123</span>输出: <span class="hljs-number">321</span>输入: <span class="hljs-number">-123</span>输出: <span class="hljs-number">-321</span>输入: <span class="hljs-number">120</span>输出: <span class="hljs-number">21</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        注意题目条件        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 常用公式</span>            ans = ans * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;            x /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-comment">// 判断是否溢出</span>        <span class="hljs-keyword">if</span>(ans &gt; Integer.MAX_VALUE || ans &lt; Integer.MIN_VALUE) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)ans;    &#125;&#125;</code></pre><h2 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h2><pre><code class="hljs gml">判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。输入: <span class="hljs-number">121</span>输出: <span class="hljs-literal">true</span>输入: <span class="hljs-number">-121</span>输出: <span class="hljs-literal">false</span>解释: 从左向右读, 为 <span class="hljs-number">-121</span> 。 从右向左读, 为 <span class="hljs-number">121</span>- 。因此它不是一个回文数。输入: <span class="hljs-number">10</span>输出: <span class="hljs-literal">false</span>解释: 从右向左读, 为 <span class="hljs-number">01</span> 。因此它不是一个回文数。class Solution &#123;    public boolean isPalindrome(int <span class="hljs-symbol">x</span>) &#123;        <span class="hljs-comment">// 0也是回文数</span>        <span class="hljs-keyword">if</span> (<span class="hljs-symbol">x</span> == <span class="hljs-number">0</span>)             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 特殊条件</span>        <span class="hljs-keyword">if</span> (<span class="hljs-symbol">x</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-symbol">x</span> % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)             <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 只需要一半</span>        int right = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> ( <span class="hljs-symbol">x</span> &gt; right) &#123;            right = right * <span class="hljs-number">10</span> + <span class="hljs-symbol">x</span> % <span class="hljs-number">10</span>;            <span class="hljs-symbol">x</span> /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-symbol">x</span> == right || <span class="hljs-symbol">x</span> == right / <span class="hljs-number">10</span>;    &#125;&#125;</code></pre><h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><pre><code class="hljs arduino">给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, <span class="hljs-number">0</span>)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 <span class="hljs-number">2</span>。输入：[<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]输出：<span class="hljs-number">49</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] <span class="hljs-built_in">height</span>)</span> </span>&#123;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-built_in">height</span>.length - <span class="hljs-number">1</span>; i &lt; j;) &#123;            <span class="hljs-comment">// 双指针，谁小取谁，判断移动</span>            <span class="hljs-keyword">int</span> minHeight = <span class="hljs-built_in">height</span>[i] &lt; <span class="hljs-built_in">height</span>[j] ? <span class="hljs-built_in">height</span>[i++] : <span class="hljs-built_in">height</span>[j--];            <span class="hljs-comment">// 每一次都要维护最大值</span>            <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, (j - i + <span class="hljs-number">1</span>) * minHeight);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;    &#125;&#125;</code></pre><h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><pre><code class="hljs processing">编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 <span class="hljs-string">&quot;&quot;</span>。输入: [<span class="hljs-string">&quot;flower&quot;</span>,<span class="hljs-string">&quot;flow&quot;</span>,<span class="hljs-string">&quot;flight&quot;</span>]输出: <span class="hljs-string">&quot;fl&quot;</span>输入: [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;racecar&quot;</span>,<span class="hljs-string">&quot;car&quot;</span>]输出: <span class="hljs-string">&quot;&quot;</span>解释: 输入不存在公共前缀。class Solution &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> longestCommonPrefix(<span class="hljs-keyword">String</span>[] strs) &#123;        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>)             <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span> = strs[<span class="hljs-number">0</span>];        <span class="hljs-comment">// 循环用indexOf和substring</span>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++) &#123;            <span class="hljs-keyword">while</span>(strs[i].indexOf(<span class="hljs-built_in">str</span>) != <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 每次substring去掉最后一位</span>                <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span>.substring(<span class="hljs-number">0</span>, <span class="hljs-built_in">str</span>.length() - <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>;    &#125;&#125;</code></pre><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h2><pre><code class="hljs inform7">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。给定数组 nums = <span class="hljs-comment">[-1, 0, 1, 2, -1, -4]</span>，满足要求的三元组集合为：<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[-1, 0, 1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[-1, -1, 2]</span></span><span class="hljs-comment">]</span></code></pre><p>这道题三要素：</p><ol><li>排序</li><li>双指针</li><li>去重复</li></ol><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; three<span class="hljs-constructor">Sum(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;        <span class="hljs-comment">// 排序的目的就是来告别重复</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(nums);        List&lt;List&lt;Integer&gt;&gt; ls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-comment">// 判断是否元素大于0,大于0，没必要操作了</span>            <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &gt; <span class="hljs-number">0</span>) break;             <span class="hljs-comment">// 判断是否重复</span>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span>) continue;            <span class="hljs-comment">// 双指针操作</span>            <span class="hljs-built_in">int</span> l = i + <span class="hljs-number">1</span>, r = nums.length - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (l &lt; r) &#123;                <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> + nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span> &lt; -nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) l++;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> + nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span> &gt; -nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) r--;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 相等了哈</span>                    ls.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">nums</span>[<span class="hljs-params">i</span>], <span class="hljs-params">nums</span>[<span class="hljs-params">l</span>], <span class="hljs-params">nums</span>[<span class="hljs-params">r</span>])</span>);                    <span class="hljs-comment">// 防止重复</span>                    <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span> + <span class="hljs-number">1</span>]</span>) l++;                    <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span> - <span class="hljs-number">1</span>]</span>) r--;                    l++;                    r--;                &#125;            &#125;        &#125;        return ls;    &#125;&#125;</code></pre><p>哪种代码好理解就用哪种</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; three<span class="hljs-constructor">Sum(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;        <span class="hljs-comment">// 排序</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(nums);        List&lt;List&lt;Integer&gt;&gt; ls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>(i &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> != nums<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span>)) &#123; <span class="hljs-comment">//跳过可能重复的</span>                <span class="hljs-comment">// 转化为两数之和</span>                <span class="hljs-built_in">int</span> l = i + <span class="hljs-number">1</span>, r = nums.length - <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span> - nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;                <span class="hljs-keyword">while</span>(l &lt; r) &#123;                    <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> + nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span><span class="hljs-operator"> == </span>sum) &#123;                        ls.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">nums</span>[<span class="hljs-params">i</span>], <span class="hljs-params">nums</span>[<span class="hljs-params">l</span>], <span class="hljs-params">nums</span>[<span class="hljs-params">r</span>])</span>);                        <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span> + <span class="hljs-number">1</span>]</span>) l++; <span class="hljs-comment">// 还是一样，跳过重复</span>                        <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span> - <span class="hljs-number">1</span>]</span>) r--;                        l++;                        r--;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> + nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span> &lt; sum) &#123;                        <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span> + <span class="hljs-number">1</span>]</span>) l++;                        l++;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span> - <span class="hljs-number">1</span>]</span>) r--;                        r--;                    &#125;                &#125;            &#125;        &#125;        return ls;    &#125;&#125;</code></pre><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h2><pre><code class="hljs prolog">给定一个仅包含数字 <span class="hljs-number">2</span><span class="hljs-number">-9</span> 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 <span class="hljs-number">1</span> 不对应任何字母。输入：<span class="hljs-string">&quot;23&quot;</span>输出：[<span class="hljs-string">&quot;ad&quot;</span>, <span class="hljs-string">&quot;ae&quot;</span>, <span class="hljs-string">&quot;af&quot;</span>, <span class="hljs-string">&quot;bd&quot;</span>, <span class="hljs-string">&quot;be&quot;</span>, <span class="hljs-string">&quot;bf&quot;</span>, <span class="hljs-string">&quot;cd&quot;</span>, <span class="hljs-string">&quot;ce&quot;</span>, <span class="hljs-string">&quot;cf&quot;</span>].</code></pre><p>回溯 不需要标记 但是记得deleteCharAt</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-keyword">private</span> static final String<span class="hljs-literal">[]</span> KEYS = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;    public List&lt;String&gt; letter<span class="hljs-constructor">Combinations(String <span class="hljs-params">digits</span>)</span> &#123;        List&lt;String&gt; combinnations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">if</span> (digits<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>digits.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return combinnations;        <span class="hljs-keyword">do</span><span class="hljs-constructor">Combination(<span class="hljs-params">new</span> StringBuilder()</span>, combinnations, digits);        return combinnations;    &#125;        <span class="hljs-keyword">private</span> void <span class="hljs-keyword">do</span><span class="hljs-constructor">Combination(StringBuilder <span class="hljs-params">prefix</span>, List&lt;String&gt; <span class="hljs-params">combinnations</span>, <span class="hljs-params">final</span> String <span class="hljs-params">digits</span>)</span> &#123;        <span class="hljs-keyword">if</span> (prefix.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span>digits.length<span class="hljs-literal">()</span>) &#123;            combinnations.add(prefix.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);            return;        &#125;        <span class="hljs-built_in">int</span> curDigits = digits.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">prefix</span>.<span class="hljs-params">length</span>()</span>) - <span class="hljs-character">&#x27;0&#x27;</span>;        String letters = KEYS<span class="hljs-literal">[<span class="hljs-identifier">curDigits</span>]</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">char</span> c : letters.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>) &#123;            prefix.append(c);            <span class="hljs-keyword">do</span><span class="hljs-constructor">Combination(<span class="hljs-params">prefix</span>, <span class="hljs-params">combinnations</span>, <span class="hljs-params">digits</span>)</span>;            prefix.delete<span class="hljs-constructor">CharAt(<span class="hljs-params">prefix</span>.<span class="hljs-params">length</span>()</span> - <span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h2><pre><code class="hljs clean">给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 n = <span class="hljs-number">2.</span>当删除了倒数第二个节点后，链表变为 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5.</span></code></pre><p>快慢指针 分情况</p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="hljs-built_in">int</span> n) &#123;        ListNode fast = head;        <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;            fast = fast.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-comment">// 这里没懂， 得举例子就懂了</span>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span>)             <span class="hljs-keyword">return</span> head.<span class="hljs-keyword">next</span>;        ListNode slow = head;        <span class="hljs-keyword">while</span> (fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            fast = fast.<span class="hljs-keyword">next</span>;            slow = slow.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-comment">// 这里也懂了...举个例子就行</span>        slow.<span class="hljs-keyword">next</span> = slow.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">return</span> head;    &#125;&#125;</code></pre><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><pre><code class="hljs actionscript">给定一个只包括 <span class="hljs-string">&#x27;(&#x27;</span>，<span class="hljs-string">&#x27;)&#x27;</span>，<span class="hljs-string">&#x27;&#123;&#x27;</span>，<span class="hljs-string">&#x27;&#125;&#x27;</span>，<span class="hljs-string">&#x27;[&#x27;</span>，<span class="hljs-string">&#x27;]&#x27;</span> 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。输入: <span class="hljs-string">&quot;()&quot;</span>输出: <span class="hljs-literal">true</span>输入: <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span>输出: <span class="hljs-literal">true</span>输入: <span class="hljs-string">&quot;(]&quot;</span>输出: <span class="hljs-literal">false</span>输入: <span class="hljs-string">&quot;([)]&quot;</span>输出: <span class="hljs-literal">false</span></code></pre><p>栈思想</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;        Stack&lt;Character&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stack</span>.isEmpty())                 <span class="hljs-built_in">stack</span>.push(c);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(isSym(<span class="hljs-built_in">stack</span>.<span class="hljs-built_in">peek</span>(), c))                 <span class="hljs-built_in">stack</span>.pop();            <span class="hljs-keyword">else</span>                 <span class="hljs-built_in">stack</span>.push(c);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>.isEmpty();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSym</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c1, <span class="hljs-keyword">char</span> c2)</span> </span>&#123;        <span class="hljs-keyword">return</span> (c1 == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; c2 == <span class="hljs-string">&#x27;)&#x27;</span>)            || (c1 == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; c2 == <span class="hljs-string">&#x27;&#125;&#x27;</span>)            || (c1 == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; c2 == <span class="hljs-string">&#x27;]&#x27;</span>);    &#125;&#125;</code></pre><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h2><pre><code class="hljs haskell">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;</span><span class="hljs-class">    public <span class="hljs-type">ListNode</span> mergeTwoLists(<span class="hljs-type">ListNode</span> <span class="hljs-title">l1</span>, <span class="hljs-type">ListNode</span> <span class="hljs-title">l2</span>) &#123;</span><span class="hljs-class">        if (<span class="hljs-title">l1</span> == <span class="hljs-title">null</span>) return l2;</span><span class="hljs-class">        if (<span class="hljs-title">l2</span> == <span class="hljs-title">null</span>) return l1;</span><span class="hljs-class">        if (<span class="hljs-title">l1</span>.<span class="hljs-title">val</span> &lt; <span class="hljs-title">l2</span>.<span class="hljs-title">val</span>) &#123;</span><span class="hljs-class">            l1.next = mergeTwoLists(<span class="hljs-title">l1</span>.<span class="hljs-title">next</span>, <span class="hljs-title">l2</span>);</span><span class="hljs-class">            return l1;</span><span class="hljs-class">        &#125; else &#123;</span><span class="hljs-class">            l2.next = mergeTwoLists(<span class="hljs-title">l1</span>, <span class="hljs-title">l2</span>.<span class="hljs-title">next</span>);</span><span class="hljs-class">            return l2;</span><span class="hljs-class">        &#125;</span><span class="hljs-class">    &#125;</span><span class="hljs-class">&#125;</span></code></pre><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h2><blockquote><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：n = 3</span><span class="hljs-meta">&gt;</span><span class="bash">输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：n = 1</span><span class="hljs-meta">&gt;</span><span class="bash">输出：[<span class="hljs-string">&quot;()&quot;</span>]</span></code></pre></blockquote><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;<span class="hljs-built_in">String</span>&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">generateParenthesis</span>(<span class="hljs-params">int n</span>)</span> &#123;        dfs(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);        <span class="hljs-keyword">return</span> ret;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">dfs</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> ans, int cnt1, int cnt2, int n</span>)</span>&#123;        <span class="hljs-keyword">if</span> (cnt1 &gt; n || cnt2 &gt; n)            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (cnt1 == n &amp;&amp; cnt2 == n)            ret.add(ans);        <span class="hljs-keyword">if</span> (cnt1 &gt;= cnt2)&#123;            <span class="hljs-built_in">String</span> ans1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(ans);            dfs(ans + <span class="hljs-string">&quot;(&quot;</span>, cnt1 + <span class="hljs-number">1</span>, cnt2, n);            dfs(ans + <span class="hljs-string">&quot;)&quot;</span>, cnt1, cnt2 + <span class="hljs-number">1</span>, n);        &#125;    &#125;&#125;</code></pre><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h2><blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><pre><code class="hljs accesslog">&gt;输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span>&gt;输出：<span class="hljs-string">[2,1,4,3,5]</span></code></pre><pre><code class="hljs accesslog">&gt;输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">3</span>&gt;输出：<span class="hljs-string">[3,2,1,4,5]</span></code></pre><pre><code class="hljs accesslog">&gt;输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">1</span>&gt;输出：<span class="hljs-string">[1,2,3,4,5]</span></code></pre><pre><code class="hljs inform7">&gt;输入：head = <span class="hljs-comment">[1]</span>, k = 1&gt;输出：<span class="hljs-comment">[1]</span></code></pre></blockquote><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode reverseKGroup(ListNode head, <span class="hljs-built_in">int</span> k) &#123;        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);        ListNode pre = dummy, cur = head, <span class="hljs-keyword">next</span>;        dummy.<span class="hljs-keyword">next</span> = head;        ListNode p = head;        <span class="hljs-built_in">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>)&#123;            len++;            p = p.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-comment">// </span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; len / k; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; k - <span class="hljs-number">1</span>; j++) &#123;                <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;                                <span class="hljs-comment">// 注意这三步</span>                cur.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;                <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = pre.<span class="hljs-keyword">next</span>;                pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;            &#125;            <span class="hljs-comment">// 移动的时候注意</span>            pre = cur;            cur = pre.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre><h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h2><pre><code class="hljs angelscript">给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(<span class="hljs-number">1</span>) 额外空间的条件下完成。给定数组 nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], 函数应该返回新的长度 <span class="hljs-number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="hljs-number">1</span>, <span class="hljs-number">2</span>。 你不需要考虑数组中超出新长度后面的元素。<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> removeDuplicates(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span>(nums[p] != nums[i]) &#123;                nums[++p] = nums[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> p+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><pre><code class="hljs reasonml">给你一个数组 nums 和一个值 <span class="hljs-keyword">val</span>，你需要 原地 移除所有数值等于 <span class="hljs-keyword">val</span> 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 <span class="hljs-constructor">O(1)</span> 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。给定 nums = <span class="hljs-literal">[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span>, <span class="hljs-keyword">val</span> = <span class="hljs-number">3</span>,函数应该返回新的长度 <span class="hljs-number">2</span>, 并且 nums 中的前两个元素均为 <span class="hljs-number">2</span>。你不需要考虑数组中超出新长度后面的元素。<span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> remove<span class="hljs-constructor">Element(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123;        <span class="hljs-built_in">int</span> p = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> != <span class="hljs-keyword">val</span>)                 nums<span class="hljs-literal">[<span class="hljs-identifier">p</span><span class="hljs-operator">++</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;        &#125;        return p;    &#125;&#125;</code></pre><h2 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h2><pre><code class="hljs pgsql">实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从<span class="hljs-number">0</span>开始)。如果不存在，则返回  <span class="hljs-number">-1</span>。输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: <span class="hljs-number">2</span><span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> strStr(String haystack, String needle) &#123;       <span class="hljs-type">int</span> l = haystack.length(), n = needle.length();       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-keyword">start</span> &lt; l - n + <span class="hljs-number">1</span>; <span class="hljs-keyword">start</span>++) &#123;           // subtring + equals           <span class="hljs-keyword">if</span>(haystack.substring(<span class="hljs-keyword">start</span>, <span class="hljs-keyword">start</span> + n).equals(needle)) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">start</span>;           &#125;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;&#125;</code></pre><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h2><blockquote><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。</p><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">0</span>&gt;输出：<span class="hljs-number">4</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">3</span>&gt;输出：-<span class="hljs-number">1</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">0</span>&gt;输出：-<span class="hljs-number">1</span></code></pre></blockquote><p>变相的二分</p><pre><code class="hljs excel">class Solution &#123;    public <span class="hljs-built_in">int</span> <span class="hljs-built_in">search</span>(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target) &#123;        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = nums.length;        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = <span class="hljs-built_in">len</span> - <span class="hljs-number">1</span>;        while (<span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span>) &#123;            <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;            <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] == target)                return <span class="hljs-built_in">mid</span>;            else <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>] &lt; nums[<span class="hljs-built_in">right</span>]) &#123;                // 注意边界条件                <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &lt; target &amp;&amp; target &lt;= nums[<span class="hljs-built_in">right</span>])                    <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;                else                     <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;            &#125; else &#123;                <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">left</span>] &lt;= target &amp;&amp; target &lt; nums[<span class="hljs-built_in">mid</span>])                    <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;                else                     <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;            &#125;        &#125;        return -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h2><pre><code class="hljs makefile">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。<span class="hljs-section">输入: [1,3,5,6], 5</span><span class="hljs-section">输出: 2</span><span class="hljs-section">输入: [1,3,5,6], 2</span><span class="hljs-section">输出: 1</span><span class="hljs-section">输入: [1,3,5,6], 7</span><span class="hljs-section">输出: 4</span><span class="hljs-section">输入: [1,3,5,6], 0</span><span class="hljs-section">输出: 0</span></code></pre><p>二分法 但要考虑边界</p><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> h = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;            <span class="hljs-keyword">int</span> mid = l + (h - l) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[mid] &lt; <span class="hljs-keyword">target</span>)                 l = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; <span class="hljs-keyword">target</span>)                 h = mid - <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span>                 <span class="hljs-keyword">return</span> mid;        &#125;        <span class="hljs-comment">// 注意边界</span>        <span class="hljs-keyword">if</span> (h &lt; <span class="hljs-number">0</span> &amp;&amp; l == <span class="hljs-number">0</span>)             <span class="hljs-keyword">return</span> (l + h) % <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span>             <span class="hljs-keyword">return</span> (l + h) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h2><pre><code class="hljs excel">给定一个正整数 <span class="hljs-built_in">n</span>（<span class="hljs-number">1</span> ≤ <span class="hljs-built_in">n</span> ≤ <span class="hljs-number">30</span>），输出外观数列的第 <span class="hljs-built_in">n</span> 项。注意：整数序列中的每一项将表示为一个字符串。「外观数列」是一个整数序列，从数字 <span class="hljs-number">1</span> 开始，序列中的每一项都是对前一项的描述。前五项如下：<span class="hljs-number">1</span>.     <span class="hljs-number">1</span><span class="hljs-number">2</span>.     <span class="hljs-number">11</span><span class="hljs-number">3</span>.     <span class="hljs-number">21</span><span class="hljs-number">4</span>.     <span class="hljs-number">1211</span><span class="hljs-number">5</span>.     <span class="hljs-number">111221</span>第一项是数字 <span class="hljs-number">1</span>描述前一项，这个数是 <span class="hljs-number">1</span> 即 “一个 <span class="hljs-number">1</span> ”，记作 <span class="hljs-number">11</span>描述前一项，这个数是 <span class="hljs-number">11</span> 即 “两个 <span class="hljs-number">1</span> ” ，记作 <span class="hljs-number">21</span>描述前一项，这个数是 <span class="hljs-number">21</span> 即 “一个 <span class="hljs-number">2</span> 一个 <span class="hljs-number">1</span> ” ，记作 <span class="hljs-number">1211</span>描述前一项，这个数是 <span class="hljs-number">1211</span> 即 “一个 <span class="hljs-number">1</span> 一个 <span class="hljs-number">2</span> 两个 <span class="hljs-number">1</span> ” ，记作 <span class="hljs-number">111221</span>输入<span class="hljs-symbol">:</span> <span class="hljs-number">1</span>输出<span class="hljs-symbol">:</span> <span class="hljs-string">&quot;1&quot;</span>解释：这是一个基本样例。输入<span class="hljs-symbol">:</span> <span class="hljs-number">4</span>输出<span class="hljs-symbol">:</span> <span class="hljs-string">&quot;1211&quot;</span>解释：当 <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span> 时，序列是 <span class="hljs-string">&quot;21&quot;</span>，其中我们有 <span class="hljs-string">&quot;2&quot;</span> 和 <span class="hljs-string">&quot;1&quot;</span> 两组，<span class="hljs-string">&quot;2&quot;</span> 可以读作 <span class="hljs-string">&quot;12&quot;</span>，也就是出现频次 = <span class="hljs-number">1</span> 而 值 = <span class="hljs-number">2</span>；类似 <span class="hljs-string">&quot;1&quot;</span> 可以读作 <span class="hljs-string">&quot;11&quot;</span>。所以答案是 <span class="hljs-string">&quot;12&quot;</span> 和 <span class="hljs-string">&quot;11&quot;</span> 组合在一起，也就是 <span class="hljs-string">&quot;1211&quot;</span>。</code></pre><p>StringBuffer + cnt</p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> String countAndSay(<span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;        &#125;        String <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;1&quot;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();            <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;            <span class="hljs-built_in">char</span> code = <span class="hljs-built_in">str</span>.charAt(<span class="hljs-number">0</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">str</span>.length(); j++) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">str</span>.charAt(j) != code) &#123;                    sb.append(<span class="hljs-keyword">count</span>);                    sb.append(code);                    code = <span class="hljs-built_in">str</span>.charAt(j);                    <span class="hljs-keyword">count</span> = <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">count</span>++;                &#125;            &#125;            sb.append(<span class="hljs-keyword">count</span>);            sb.append(<span class="hljs-built_in">str</span>.charAt(<span class="hljs-built_in">str</span>.length() - <span class="hljs-number">1</span>));            <span class="hljs-built_in">str</span> = sb.toString();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>;    &#125;&#125;</code></pre><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><blockquote><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><pre><code class="hljs dns">&gt;输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]&gt;输出：<span class="hljs-number">6</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：height = [4,2,0,3,2,5]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：9</span></code></pre><p>在坐标系上绘画出高度图看。</p></blockquote><p>双指针</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] <span class="hljs-built_in">height</span>)</span> </span>&#123;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-built_in">height</span>.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(l &lt; r) &#123;            <span class="hljs-comment">// 双指针维护最小值</span>            <span class="hljs-built_in">min</span> = <span class="hljs-built_in">height</span>[<span class="hljs-built_in">height</span>[l] &lt; <span class="hljs-built_in">height</span>[r] ? l++ : r--];            <span class="hljs-comment">// 接着维护最大值</span>            <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span>);            <span class="hljs-comment">// 累加差值</span>            res += <span class="hljs-built_in">max</span> - <span class="hljs-built_in">min</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h2><blockquote><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><pre><code class="hljs gcode">&gt;输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;3&quot;</span>&gt;输出: <span class="hljs-string">&quot;6&quot;</span></code></pre><pre><code class="hljs gcode">&gt;输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;456&quot;</span>&gt;输出: <span class="hljs-string">&quot;56088&quot;</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">String</span> num1, <span class="hljs-keyword">String</span> num2)</span> </span>&#123;        <span class="hljs-keyword">int</span> len1 = num1.length();        <span class="hljs-keyword">int</span> len2 = num2.length();        <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span> || len2 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;        <span class="hljs-keyword">int</span>[] mul = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1 + len2];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = len2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;                <span class="hljs-keyword">int</span> n = (num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * (num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>) + mul[i + j + <span class="hljs-number">1</span>];                mul[i + j + <span class="hljs-number">1</span>] = n % <span class="hljs-number">10</span>;                mul[i + j] += n / <span class="hljs-number">10</span>;            &#125;        &#125;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &lt; len1 + len2 - <span class="hljs-number">1</span> &amp;&amp; mul[i] == <span class="hljs-number">0</span>) i++;        <span class="hljs-keyword">while</span> (i &lt; len1 + len2) sb.append(mul[i++]);        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><pre><code class="hljs angelscript">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>],输出: <span class="hljs-number">6</span>解释: 连续子数组 [<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大，为 <span class="hljs-number">6</span>。<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxSubArray(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> preSum = nums[<span class="hljs-number">0</span>];        <span class="hljs-built_in">int</span> maxSum = preSum;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 注意条件</span>            preSum = preSum &gt; <span class="hljs-number">0</span> ? preSum + nums[i] : nums[i];            maxSum = Math.max(maxSum, preSum);        &#125;        <span class="hljs-keyword">return</span> maxSum;    &#125;&#125;</code></pre><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><pre><code class="hljs makefile">给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。<span class="hljs-section">输入: [2,3,1,1,4]</span><span class="hljs-section">输出: true</span><span class="hljs-section">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><span class="hljs-section">输入: [3,2,1,0,4]</span><span class="hljs-section">输出: false</span><span class="hljs-section">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span></code></pre><p>贪心</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-comment">// 注意条件</span>            <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-built_in">max</span>) &#123;                <span class="hljs-comment">// 最远索引</span>                <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, nums[i] + i);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// 注意判断</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span> &gt;= n - <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h2><pre><code class="hljs makefile">给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。<span class="hljs-section">输入: [1,2,3]</span><span class="hljs-section">输出: [1,2,4]</span><span class="hljs-section">解释: 输入数组表示数字 123。</span><span class="hljs-section">输入: [4,3,2,1]</span><span class="hljs-section">输出: [4,3,2,2]</span><span class="hljs-section">解释: 输入数组表示数字 4321。</span></code></pre><p>正常操作 加法中常用 a = x % 10 b = x / 10</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> plus<span class="hljs-constructor">One(<span class="hljs-params">int</span>[] <span class="hljs-params">digits</span>)</span> &#123;        <span class="hljs-built_in">int</span> length = digits.length;        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">length</span> + <span class="hljs-number">1</span>]</span>;        <span class="hljs-built_in">int</span> carry = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;            <span class="hljs-built_in">int</span> sums = digits<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> + carry;            res<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = sums % <span class="hljs-number">10</span>;            carry = sums<span class="hljs-operator"> / </span><span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">if</span> (carry<span class="hljs-operator"> == </span><span class="hljs-number">1</span>) &#123;            res<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">1</span>;            return res;        &#125;        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">OfRange(<span class="hljs-params">res</span>,0,<span class="hljs-params">length</span>)</span>;    &#125;&#125;</code></pre><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><pre><code class="hljs tap">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬<span class="hljs-number"> 1 </span>或<span class="hljs-number"> 2 </span>个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶2. <span class="hljs-number"> 2 </span>阶输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶</code></pre><p>自底向上</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> climbStairs(<span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;        <span class="hljs-built_in">int</span> pre2 = <span class="hljs-number">1</span>, pre1 = <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;            <span class="hljs-built_in">int</span> cur = pre2 + pre1;            pre2 = pre1;            pre1 = cur;        &#125;        <span class="hljs-keyword">return</span> pre1;    &#125;&#125;</code></pre><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h2><pre><code class="hljs makefile">给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。<span class="hljs-section">说明:</span>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<span class="hljs-section">输入:</span>nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6],       n = 3<span class="hljs-section">输出: [1,2,2,3,5,6]</span></code></pre><p>三指针</p><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> merge(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n) &#123;    <span class="hljs-type">int</span> index1 = m - <span class="hljs-number">1</span>, index2 = n - <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> indexMerge = m + n - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (index1 &gt;= <span class="hljs-number">0</span> || index2 &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">if</span> (index1 &lt; <span class="hljs-number">0</span>) &#123;            nums1[indexMerge<span class="hljs-comment">--] = nums2[index2--];</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index2 &lt; <span class="hljs-number">0</span>) &#123;            nums1[indexMerge<span class="hljs-comment">--] = nums1[index1--];</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;            nums1[indexMerge<span class="hljs-comment">--] = nums1[index1--];</span>        &#125; <span class="hljs-keyword">else</span> &#123;            nums1[indexMerge<span class="hljs-comment">--] = nums2[index2--];</span>        &#125;    &#125;&#125;</code></pre><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h2><pre><code class="hljs inform7">给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。    3   / \  9  20    /  \   15   7<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span></span><span class="hljs-comment">]</span></code></pre><p>队列</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-built_in">queue</span>.add(root);        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">queue</span>.isEmpty()) &#123;            ArrayList&lt;Integer&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">int</span> cnt = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">while</span> (cnt-- &gt; <span class="hljs-number">0</span>) &#123;                TreeNode node = <span class="hljs-built_in">queue</span>.poll();                <span class="hljs-keyword">if</span> (node == null)                    <span class="hljs-keyword">continue</span>;                <span class="hljs-built_in">list</span>.add(node.val);                <span class="hljs-built_in">queue</span>.add(node.left);                <span class="hljs-built_in">queue</span>.add(node.right);            &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>)                ret.add(<span class="hljs-built_in">list</span>);        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><pre><code class="hljs glsl">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。注意：你不能在买入股票前卖出股票。输入: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]输出: <span class="hljs-number">5</span>解释: 在第 <span class="hljs-number">2</span> 天（股票价格 = <span class="hljs-number">1</span>）的时候买入，在第 <span class="hljs-number">5</span> 天（股票价格 = <span class="hljs-number">6</span>）的时候卖出，最大利润 = <span class="hljs-number">6</span><span class="hljs-number">-1</span> = <span class="hljs-number">5</span> 。     注意利润不能是 <span class="hljs-number">7</span><span class="hljs-number">-1</span> = <span class="hljs-number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票输入: [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]输出: <span class="hljs-number">0</span>解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。class Solution &#123;    public <span class="hljs-type">int</span> maxProfit(<span class="hljs-type">int</span>[] prices) &#123;        <span class="hljs-comment">// 边界</span>        <span class="hljs-keyword">if</span>(prices.<span class="hljs-built_in">length</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 长度</span>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">length</span>;        <span class="hljs-comment">// min</span>        <span class="hljs-type">int</span> <span class="hljs-built_in">min</span> = prices[<span class="hljs-number">0</span>];        <span class="hljs-comment">// max</span>        <span class="hljs-type">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-comment">// 一直找最小的股</span>            <span class="hljs-built_in">min</span> = prices[i] &lt; <span class="hljs-built_in">min</span> ? prices[i] : <span class="hljs-built_in">min</span>;            <span class="hljs-comment">// 遍历一圈，存最大的利润</span>            <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, prices[i] - <span class="hljs-built_in">min</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;    &#125;&#125;</code></pre><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h2><pre><code class="hljs angelscript">给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/<span class="hljs-number">2</span> ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出: <span class="hljs-number">3</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> majorityElement(<span class="hljs-built_in">int</span>[] nums) &#123;        Arrays.sort(nums);        <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];    &#125;&#125;</code></pre><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><pre><code class="hljs tap">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。输入：[1,2,3,1]输出：4解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。输入：[2,7,9,3,1]输出：12解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。     偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。class Solution &#123;    public int rob(int[] nums) &#123;        int pre2 = 0, pre1 = 0;        for (int i = 0; i &lt; nums.length; i++) &#123;            int cur = Math.max(pre2 + nums[i], pre1);            pre2 = pre1;            pre1 = cur;        &#125;        return pre1;    &#125;&#125;</code></pre><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><pre><code class="hljs gradle">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-keyword">NULL</span>输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-keyword">NULL</span><span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-keyword">public</span> ListNode reverseList(ListNode head) &#123;        <span class="hljs-comment">// 尾递归</span>        <span class="hljs-comment">// return reverse(null, head);</span>        <span class="hljs-comment">// 头插</span>        ListNode pre = <span class="hljs-keyword">null</span>;        ListNode cur = head;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;            ListNode <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;            cur.<span class="hljs-keyword">next</span> = pre;            pre = cur;            cur = <span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">return</span> pre;    &#125;    <span class="hljs-keyword">private</span> ListNode <span class="hljs-keyword">reverse</span>(ListNode pre, ListNode cur) &#123;        <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> pre;        ListNode <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;        cur.<span class="hljs-keyword">next</span> = pre;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">reverse</span>(cur, <span class="hljs-keyword">next</span>);    &#125;&#125;</code></pre><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h2><pre><code class="hljs arduino">使用队列实现栈的下列操作：push(x) -- 元素 x 入栈pop() -- 移除栈顶元素top() -- 获取栈顶元素empty() -- 返回栈是否为空<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;</span>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; <span class="hljs-built_in">queue</span>;    <span class="hljs-comment">/** Initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    &#125;        <span class="hljs-comment">/** Push element x onto stack. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-built_in">queue</span>.add(x);        <span class="hljs-comment">// 加完取长度</span>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();        <span class="hljs-comment">// 倒置</span>        <span class="hljs-keyword">while</span> (cnt-- &gt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-built_in">queue</span>.add(<span class="hljs-built_in">queue</span>.poll());        &#125;    &#125;        <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">remove</span>();    &#125;        <span class="hljs-comment">/** Get the top element. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">peek</span>();    &#125;        <span class="hljs-comment">/** Returns whether the stack is empty. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>.isEmpty();    &#125;&#125;</code></pre><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h2><pre><code class="hljs accesslog">输入: <span class="hljs-string">[0,1,0,3,12]</span>输出: <span class="hljs-string">[1,3,12,0,0]</span></code></pre><ol><li>先把不是0的移动左</li><li>最后陆续加0</li></ol><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    public <span class="hljs-keyword">void</span> moveZeroes(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> idx = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">num</span> != <span class="hljs-number">0</span>)                 nums[idx++] = <span class="hljs-built_in">num</span>;        &#125;        <span class="hljs-keyword">while</span> (idx &lt; nums.length) &#123;            nums[idx++] =<span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><h2 id="1103-分糖果-II"><a href="#1103-分糖果-II" class="headerlink" title="1103. 分糖果 II"></a>1103. 分糖果 II</h2><pre><code class="hljs inform7">排排坐，分糖果。我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans<span class="hljs-comment">[i]</span> 表示第 i 个小朋友分到的糖果数）。输入：candies = 7, num_people = 4输出：<span class="hljs-comment">[1,2,3,1]</span>解释：第一次，ans<span class="hljs-comment">[0]</span> += 1，数组变为 <span class="hljs-comment">[1,0,0,0]</span>。第二次，ans<span class="hljs-comment">[1]</span> += 2，数组变为 <span class="hljs-comment">[1,2,0,0]</span>。第三次，ans<span class="hljs-comment">[2]</span> += 3，数组变为 <span class="hljs-comment">[1,2,3,0]</span>。第四次，ans<span class="hljs-comment">[3]</span> += 1（因为此时只剩下 1 颗糖果），最终数组变为 <span class="hljs-comment">[1,2,3,1]</span>。输入：candies = 10, num_people = 3输出：<span class="hljs-comment">[5,2,3]</span>解释：第一次，ans<span class="hljs-comment">[0]</span> += 1，数组变为 <span class="hljs-comment">[1,0,0]</span>。第二次，ans<span class="hljs-comment">[1]</span> += 2，数组变为 <span class="hljs-comment">[1,2,0]</span>。第三次，ans<span class="hljs-comment">[2]</span> += 3，数组变为 <span class="hljs-comment">[1,2,3]</span>。第四次，ans<span class="hljs-comment">[0]</span> += 4，最终数组变为 <span class="hljs-comment">[5,2,3]</span>。class Solution &#123;    public int<span class="hljs-comment">[]</span> distributeCandies(int candies, int num_people) &#123;        int<span class="hljs-comment">[]</span> ans = new int<span class="hljs-comment">[num_people]</span>;        int i;        for (i = 0; candies &gt; 0; i++) &#123;            ans<span class="hljs-comment">[i % num_people]</span> += i + 1;            candies -= i + 1;        &#125;        ans<span class="hljs-comment">[(i - 1) % num_people]</span> += candies;        return ans;    &#125;&#125;</code></pre><h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a>994. 腐烂的橘子</h2><blockquote><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1</p><pre><code class="hljs lua">&gt;输入：<span class="hljs-string">[[2,1,1],[1,1,0],[0,1,1]]</span>&gt;输出：<span class="hljs-number">4</span></code></pre><pre><code class="hljs lua">&gt;输入：<span class="hljs-string">[[2,1,1],[0,1,1],[1,0,1]]</span>&gt;输出：<span class="hljs-number">-1</span>&gt;解释：左下角的橘子（第 <span class="hljs-number">2</span> 行， 第 <span class="hljs-number">0</span> 列）永远不会腐烂，因为腐烂只会发生在 <span class="hljs-number">4</span> 个正向上。</code></pre></blockquote><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> int orangesRotting(int[][] grid) &#123;        <span class="hljs-comment">// 俺就不判断了，直接上</span>        int[][] dir = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;        Queue&lt;Pair&lt;Integer, Integer&gt;&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedList</span>&lt;&gt;();        int m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        int cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示新鲜的橘子</span>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)                    cnt++; <span class="hljs-comment">// 新鲜橘子计数</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>)                    q.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(i, j)); <span class="hljs-comment">// 腐烂橘子的坐标</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span> || q.size() == m * n)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        int step = <span class="hljs-number">0</span>; <span class="hljs-comment">// 轮数</span>        <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">0</span> &amp;&amp; !q.isEmpty())&#123;            int size = q.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                Pair&lt;Integer, Integer&gt; p = q.poll();                int x = p.getKey(), y = p.getValue();                <span class="hljs-keyword">for</span> (int[] d : <span class="hljs-type">dir</span>) &#123;                    int <span class="hljs-keyword">new</span><span class="hljs-type">X</span> = x + d[<span class="hljs-number">0</span>];                    int <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> = y + d[<span class="hljs-number">1</span>];                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">X</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">new</span><span class="hljs-type">X</span> &gt;= m || <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> &gt;= n) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">if</span> (grid[<span class="hljs-keyword">new</span><span class="hljs-type">X</span>][<span class="hljs-keyword">new</span><span class="hljs-type">Y</span>] == <span class="hljs-number">1</span>) &#123;                        grid[<span class="hljs-keyword">new</span><span class="hljs-type">X</span>][<span class="hljs-keyword">new</span><span class="hljs-type">Y</span>] = <span class="hljs-number">2</span>;                        q.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(<span class="hljs-keyword">new</span><span class="hljs-type">X</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Y</span>));                        cnt--;                    &#125;                &#125;            &#125;            step++;        &#125;        <span class="hljs-keyword">return</span> cnt &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-type">step</span>;    &#125;&#125;</code></pre><h2 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a>23. 合并K个排序链表</h2><pre><code class="hljs clean">输入:[  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span>]输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span></code></pre><p>最小堆</p><pre><code class="hljs livescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    public ListNode mergeKLists(ListNode[] lists) &#123;        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;<span class="hljs-function"><span class="hljs-params">((o1, o2) -&gt; o1.val - o2.val)</span>;</span><span class="hljs-function">        <span class="hljs-title">ListNode</span> <span class="hljs-title">dummy</span> = <span class="hljs-title">new</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>;</span><span class="hljs-function">        <span class="hljs-title">ListNode</span> <span class="hljs-title">p</span> = <span class="hljs-title">dummy</span>;</span><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-params">(ListNode node : lists)</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-params">(node != <span class="hljs-literal">null</span>)</span> <span class="hljs-title">queue</span>.<span class="hljs-title">add</span><span class="hljs-params">(node)</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function">        <span class="hljs-title">while</span> <span class="hljs-params">(!queue.isEmpty())</span> &#123;</span><span class="hljs-function">            <span class="hljs-title">p</span>.<span class="hljs-title">next</span> = <span class="hljs-title">queue</span>.<span class="hljs-title">poll</span><span class="hljs-params">()</span>;</span><span class="hljs-function">            <span class="hljs-title">p</span> = <span class="hljs-title">p</span>.<span class="hljs-title">next</span>;</span><span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-params">(p.next != <span class="hljs-literal">null</span>)</span> <span class="hljs-title">queue</span>.<span class="hljs-title">add</span><span class="hljs-params">(p.next)</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">dummy</span>.<span class="hljs-title">next</span>;</span><span class="hljs-function">    &#125;   </span><span class="hljs-function">&#125;</span></code></pre><p>分治</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;   <span class="hljs-keyword">public</span> ListNode <span class="hljs-function"><span class="hljs-title">mergeKLists</span>(<span class="hljs-params">ListNode[] lists</span>)</span> &#123;        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">private</span> ListNode <span class="hljs-function"><span class="hljs-title">merge</span>(<span class="hljs-params">ListNode[] lists, int left, int right</span>)</span> &#123;        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span> lists[left];        int mid = left + (right - left) / <span class="hljs-number">2</span>;        ListNode l1 = merge(lists, left, mid);        ListNode l2 = merge(lists, mid + <span class="hljs-number">1</span>, right);        <span class="hljs-keyword">return</span> mergeTwoLists(l1, l2);    &#125;    <span class="hljs-keyword">private</span> ListNode <span class="hljs-function"><span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params">ListNode l1, ListNode l2</span>)</span> &#123;        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l2;        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l1;        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;            l1.next = mergeTwoLists(l1.next, l2);            <span class="hljs-keyword">return</span> l1;        &#125; <span class="hljs-keyword">else</span> &#123;            l2.next = mergeTwoLists(l1,l2.next);            <span class="hljs-keyword">return</span> l2;        &#125;    &#125;&#125;</code></pre><h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><pre><code class="hljs axapta">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。给定 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>, 你应该返回 <span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3.</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode swapPairs(ListNode head) &#123;        ListNode node = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);        node.<span class="hljs-keyword">next</span> = head;        ListNode pre = node;        <span class="hljs-keyword">while</span> (pre.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span> &amp;&amp; pre.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            ListNode l1 = pre.<span class="hljs-keyword">next</span>, l2 = pre.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            ListNode <span class="hljs-keyword">next</span> = l2.<span class="hljs-keyword">next</span>;            l1.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;            l2.<span class="hljs-keyword">next</span> = l1;            pre.<span class="hljs-keyword">next</span> = l2;            pre = l1;        &#125;        <span class="hljs-keyword">return</span> node.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h2><blockquote><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;(()&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：2</span><span class="hljs-meta">&gt;</span><span class="bash">解释：最长有效括号子串是 <span class="hljs-string">&quot;()&quot;</span></span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;)()())&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：4</span><span class="hljs-meta">&gt;</span><span class="bash">解释：最长有效括号子串是 <span class="hljs-string">&quot;()()&quot;</span></span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：0</span></code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> longest<span class="hljs-constructor">ValidParentheses(String <span class="hljs-params">s</span>)</span> &#123;        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">s</span>.<span class="hljs-identifier">length</span>()]</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length<span class="hljs-literal">()</span>; i++)&#123;            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;)&#x27;</span>) &#123;                <span class="hljs-built_in">int</span> j = i - dp<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span> - <span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;(&#x27;</span>)                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = (i - j + <span class="hljs-number">1</span>) + ((j - <span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span> ? dp<span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span> : <span class="hljs-number">0</span>);            &#125;            ans = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(ans, dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h2><pre><code class="hljs inform7">给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 <span class="hljs-comment">[-1, -1]</span>。输入: nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8输出: <span class="hljs-comment">[3,4]</span>输入: nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6输出: <span class="hljs-comment">[-1,-1]</span></code></pre><p>双指针+二分法</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> search<span class="hljs-constructor">Range(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">target</span>)</span> &#123;        <span class="hljs-built_in">int</span> first = find<span class="hljs-constructor">First(<span class="hljs-params">nums</span>, <span class="hljs-params">target</span>)</span>;        <span class="hljs-built_in">int</span> last = find<span class="hljs-constructor">First(<span class="hljs-params">nums</span>, <span class="hljs-params">target</span> + 1)</span> - <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (first<span class="hljs-operator"> == </span>nums.length<span class="hljs-operator"> || </span>nums<span class="hljs-literal">[<span class="hljs-identifier">first</span>]</span> != target) &#123;            return <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;        &#125; <span class="hljs-keyword">else</span> &#123;            return <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;first, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(first, last)&#125;;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> find<span class="hljs-constructor">First(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">target</span>)</span> &#123;        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, h = nums.length; <span class="hljs-comment">// h 的初始值和往常不一样</span>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;            <span class="hljs-built_in">int</span> m = l + ( h - l)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span> &gt;= target) h = m;            <span class="hljs-keyword">else</span> l = m + <span class="hljs-number">1</span>;        &#125;        return l;    &#125;&#125;</code></pre><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h2><pre><code class="hljs inform7">给定一个 没有重复 数字的序列，返回其所有可能的全排列。输入: <span class="hljs-comment">[1,2,3]</span>输出:<span class="hljs-comment">[</span><span class="hljs-comment">  <span class="hljs-comment">[1,2,3]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[1,3,2]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[2,1,3]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[2,3,1]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[3,1,2]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[3,2,1]</span></span><span class="hljs-comment">]</span></code></pre><p>dfs</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">permute</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        List&lt;List&lt;Integer&gt;&gt; permutes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;Integer&gt; permuteList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">boolean</span>[] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];        backtracking(permuteList, permutes, hasVisited, nums);        <span class="hljs-keyword">return</span> permutes;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (permuteList.<span class="hljs-built_in">size</span>() == nums.length) &#123;            permutes.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(permuteList)); <span class="hljs-comment">// 重新构造一个List</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; visited.length; i++) &#123;            <span class="hljs-keyword">if</span> (visited[i]) <span class="hljs-keyword">continue</span>;            visited[i] = <span class="hljs-literal">true</span>;            permuteList.add(nums[i]);            backtracking(permuteList, permutes, visited, nums);            permuteList.<span class="hljs-built_in">remove</span>(permuteList.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);            visited[i] = <span class="hljs-literal">false</span>;        &#125;            &#125;&#125;</code></pre><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><pre><code class="hljs prolog">给出一个区间的集合，请合并所有重叠的区间。输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]解释: 区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]输出: [[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]]解释: 区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。class <span class="hljs-symbol">Solution</span> &#123;    public int[][] merge(int[][] intervals) &#123;        if (intervals == null || intervals.length &lt;= <span class="hljs-number">1</span>) return intervals;        <span class="hljs-symbol">Arrays</span>.sort(intervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);        <span class="hljs-symbol">List</span>&lt;int[]&gt; list = new <span class="hljs-symbol">ArrayList</span>&lt;&gt;();        int i = <span class="hljs-number">0</span>;        int n = intervals.length;        while (i &lt; n) &#123;            int l = intervals[i][<span class="hljs-number">0</span>];            int r = intervals[i][<span class="hljs-number">1</span>];            while (i &lt; n - <span class="hljs-number">1</span> &amp;&amp; r &gt;= intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;                r = <span class="hljs-symbol">Math</span>.max(r, intervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);                i++;            &#125;            list.add(new int[] &#123;l, r&#125;);            i++;        &#125;        return list.toArray(new int[list.size()][<span class="hljs-number">2</span>]);    &#125;&#125;</code></pre><h2 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h2><pre><code class="hljs typescript">给定一个仅包含大小写字母和空格 <span class="hljs-string">&#x27; &#x27;</span> 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。如果不存在最后一个单词，请返回 <span class="hljs-number">0</span> 。说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。输入: <span class="hljs-string">&quot;Hello World&quot;</span>输出: <span class="hljs-number">5</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">lengthOfLastWord</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;        <span class="hljs-built_in">String</span>[] strs = s.split(<span class="hljs-string">&quot; &quot;</span>);        <span class="hljs-keyword">if</span>(strs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> strs[strs.length-<span class="hljs-number">1</span>].length();    &#125;&#125;</code></pre><h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h2><pre><code class="hljs reasonml">给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 非空 字符串且只包含数字 <span class="hljs-number">1</span> 和 <span class="hljs-number">0</span>。输入: a = <span class="hljs-string">&quot;11&quot;</span>, b = <span class="hljs-string">&quot;1&quot;</span>输出: <span class="hljs-string">&quot;100&quot;</span>输入: a = <span class="hljs-string">&quot;1010&quot;</span>, b = <span class="hljs-string">&quot;1011&quot;</span>输出: <span class="hljs-string">&quot;10101&quot;</span><span class="hljs-keyword">class</span> Solution &#123;    public String add<span class="hljs-constructor">Binary(String <span class="hljs-params">a</span>, String <span class="hljs-params">b</span>)</span> &#123;        <span class="hljs-built_in">int</span> i = a.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>, j = b.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;        StringBuilder str = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;        <span class="hljs-keyword">while</span> (carry<span class="hljs-operator"> == </span><span class="hljs-number">1</span><span class="hljs-operator"> || </span>i &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> || </span>j &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>a.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>--)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;1&#x27;</span>) carry++;            <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>b.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>--)</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;1&#x27;</span>) carry++;            <span class="hljs-comment">// 注意这里</span>            str.append(carry % <span class="hljs-number">2</span>);            carry /= <span class="hljs-number">2</span>;        &#125;        return str.reverse<span class="hljs-literal">()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;    &#125;</code></pre><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><pre><code class="hljs typescript">给定一个二叉树，检查它是否是镜像对称的。    <span class="hljs-number">1</span>   / \  <span class="hljs-number">2</span>   <span class="hljs-number">2</span> / \ / \<span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSymmetric</span>(<span class="hljs-params">TreeNode root</span>)</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> isSymmetric(root.left, root.right);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSymmetric</span>(<span class="hljs-params">TreeNode t1, TreeNode t2</span>)</span> &#123;        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span> &amp;&amp; t2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span> || t2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (t1.val != t2.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t1.right, t2.left);    &#125;&#125;</code></pre><h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. 验证回文串</h2><pre><code class="hljs smalltalk">给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：本题中，我们将空字符串定义为有效的回文串。输入: <span class="hljs-comment">&quot;A man, a plan, a canal: Panama&quot;</span>输出: <span class="hljs-keyword">true</span>输入: <span class="hljs-comment">&quot;race a car&quot;</span>输出: <span class="hljs-keyword">false</span></code></pre><p>双指针</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public boolean is<span class="hljs-constructor">Palindrome(String <span class="hljs-params">s</span>)</span> &#123;        <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">&quot;&quot;</span>)) return <span class="hljs-literal">true</span>;        s = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;        <span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> sChar = s.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, r = sChar.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;            <span class="hljs-keyword">if</span> (sChar<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span><span class="hljs-operator"> == </span>sChar<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span>) &#123;                l++;                r--;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!is<span class="hljs-constructor">NormalChar(<span class="hljs-params">sChar</span>[<span class="hljs-params">l</span>])</span>) &#123;                l++;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!is<span class="hljs-constructor">NormalChar(<span class="hljs-params">sChar</span>[<span class="hljs-params">r</span>])</span>) &#123;                r--;            &#125; <span class="hljs-keyword">else</span> &#123;                return <span class="hljs-literal">false</span>;            &#125;        &#125;        return <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">private</span> boolean is<span class="hljs-constructor">NormalChar(<span class="hljs-params">char</span> <span class="hljs-params">a</span>)</span>&#123;        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Character</span>.</span></span>is<span class="hljs-constructor">LowerCase(<span class="hljs-params">a</span>)</span><span class="hljs-operator"> || </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Character</span>.</span></span>is<span class="hljs-constructor">UpperCase(<span class="hljs-params">a</span>)</span><span class="hljs-operator"> || </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Character</span>.</span></span>is<span class="hljs-constructor">Digit(<span class="hljs-params">a</span>)</span>;    &#125;&#125;</code></pre><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><pre><code class="hljs reasonml">给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。    <span class="hljs-number">3</span><span class="hljs-operator">   / </span>\  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><span class="hljs-operator">    /  </span>\   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> max<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;        <span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>null) return <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> l = max<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;        <span class="hljs-built_in">int</span> r = max<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;        return <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(l, r);    &#125;&#125;</code></pre><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h2><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1]</span><span class="hljs-section">输出: 1</span></code></pre><p>异或</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> singleNumber(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> num : nums)             ret = ret ^ num;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><pre><code class="hljs hsp">给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 <span class="hljs-keyword">pos</span> 来表示链表尾连接到链表中的位置（索引从 <span class="hljs-number">0</span> 开始）。 如果 <span class="hljs-keyword">pos</span> 是 <span class="hljs-number">-1</span>，则在该链表中没有环。输入：head = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-4</span>], <span class="hljs-keyword">pos</span> = <span class="hljs-number">1</span>输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>快慢指针</p><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> hasCycle(ListNode head) &#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        ListNode l1 = head, l2 = head.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span> &amp;&amp; l2.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (l1 == l2) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            l1 = l1.<span class="hljs-keyword">next</span>;            l2 = l2.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><pre><code class="hljs prolog">给你一个由 <span class="hljs-string">&#x27;1&#x27;</span>（陆地）和 <span class="hljs-string">&#x27;0&#x27;</span>（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。输入:[[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>]]输出: <span class="hljs-number">1</span>输入:[[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>],[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>]]输出: <span class="hljs-number">3</span>解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</code></pre><p>dfs</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m, n;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] direaction = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">if</span> (grid == <span class="hljs-keyword">null</span> || grid.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        m = grid.length;        n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> islandsNum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;                    dfs(grid, i, j);                    islandsNum++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> islandsNum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;=n || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] d : direaction) &#123;            dfs(grid, i + d[<span class="hljs-number">0</span>], j + d[<span class="hljs-number">1</span>]);        &#125;    &#125;&#125;</code></pre><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><pre><code class="hljs makefile">在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。<span class="hljs-section">输入: [3,2,1,5,6,4] 和 k = 2</span><span class="hljs-section">输出: 5</span><span class="hljs-section">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><span class="hljs-section">输出: 4</span></code></pre><p>快排</p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> findKthLargest(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k) &#123;        k = nums.length - k;        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, h = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (l &lt; h) &#123;            <span class="hljs-built_in">int</span> j = partition(nums, l , h);            <span class="hljs-keyword">if</span> (j == k) &#123;                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; k) &#123;                l = j + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                h = j - <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[k];    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> partition(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r) &#123;        <span class="hljs-built_in">int</span> pivot = l;        <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = pivot + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-keyword">index</span>; i &lt;= r; i++) &#123;            <span class="hljs-keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;                swap(arr, i, <span class="hljs-keyword">index</span>++);            &#125;        &#125;        swap(arr, pivot, <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> swap(<span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;        <span class="hljs-built_in">int</span> t = arr[i];        arr[i] = arr[j];        arr[j] = t;     &#125;&#125;</code></pre><h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h2><pre><code class="hljs arduino">给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 <span class="hljs-string">&quot;Aa&quot;</span> 不能当做一个回文字符串。注意:假设字符串的长度不会超过 <span class="hljs-number">1010</span>。输入:<span class="hljs-string">&quot;abccccdd&quot;</span>输出:<span class="hljs-number">7</span>解释:我们可以构造的最长的回文串是<span class="hljs-string">&quot;dccaccd&quot;</span>, 它的长度是 <span class="hljs-number">7</span>。<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] cnts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;            cnts[c]++;        &#125;        <span class="hljs-keyword">int</span> palindrome = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 偶数个字母加起来，就算不是偶数个，也拿偶数个，比如5拿4</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> cnt : cnts) &#123;            palindrome += (cnt / <span class="hljs-number">2</span>) * <span class="hljs-number">2</span>;        &#125;        <span class="hljs-comment">// 小于，则说明有个字母或多个字母是奇数个，拿一放中间</span>        <span class="hljs-keyword">if</span> (palindrome &lt; s.length()) &#123;            palindrome++;        &#125;        <span class="hljs-keyword">return</span> palindrome;    &#125;&#125;</code></pre><h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h2><pre><code class="hljs stylus">给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]输出：此列表中的结点 <span class="hljs-number">3</span> (序列化形式：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])返回的结点值为 <span class="hljs-number">3</span> 。 (测评系统对该结点序列化表述是 [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans<span class="hljs-selector-class">.val</span> = <span class="hljs-number">3</span>, ans<span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.val</span> = <span class="hljs-number">4</span>, ans<span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.val</span> = <span class="hljs-number">5</span>, 以及 ans<span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.next</span><span class="hljs-selector-class">.next</span> = NULL.输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]输出：此列表中的结点 <span class="hljs-number">4</span> (序列化形式：[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])由于该列表有两个中间结点，值分别为 <span class="hljs-number">3</span> 和 <span class="hljs-number">4</span>，我们返回第二个结点。</code></pre><p>快慢指针</p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode middleNode(ListNode head) &#123;        ListNode p = head, q = head;        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">null</span> &amp;&amp; q.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            q = q.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            p = p.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">return</span> p;    &#125;&#125;</code></pre><h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a>41. 缺失的第一个正数</h2><pre><code class="hljs makefile">给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。<span class="hljs-section">输入: [1,2,0]</span><span class="hljs-section">输出: 3</span><span class="hljs-section">输入: [3,4,-1,1]</span><span class="hljs-section">输出: 2</span><span class="hljs-section">输入: [7,8,9,11,12]</span><span class="hljs-section">输出: 1</span></code></pre><p>怎么会怎么来，排序，接着遍历。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> firstMissingPositive(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">1</span>;        Arrays.sort(nums);        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] &gt; ans) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span> (nums[i] == ans) ans++;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h2><pre><code class="hljs clean">html一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？输入: m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span>输出: <span class="hljs-number">3</span>解释:从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<span class="hljs-number">1.</span> 向右 -&gt; 向右 -&gt; 向下<span class="hljs-number">2.</span> 向右 -&gt; 向下 -&gt; 向右<span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向右</code></pre><p>dp</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        Arrays.<span class="hljs-built_in">fill</span>(dp, <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;                dp[j] += dp[j - <span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];    &#125;&#125;</code></pre><h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h2><pre><code class="hljs smalltalk">输入: <span class="hljs-comment">&quot;the sky is blue&quot;</span>输出: <span class="hljs-comment">&quot;blue is sky the&quot;</span>输入: <span class="hljs-comment">&quot;  hello world!  &quot;</span>输出: <span class="hljs-comment">&quot;world! hello&quot;</span>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。输入: <span class="hljs-comment">&quot;a good   example&quot;</span>输出: <span class="hljs-comment">&quot;example good a&quot;</span>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre><p>用了api</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public String reverse<span class="hljs-constructor">Words(String <span class="hljs-params">s</span>)</span> &#123;        String<span class="hljs-literal">[]</span> words = s.trim<span class="hljs-literal">()</span>.split(<span class="hljs-string">&quot; +&quot;</span>);        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>reverse(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">words</span>)</span>);        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>join(<span class="hljs-string">&quot; &quot;</span>, words);    &#125;&#125;</code></pre><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h2><pre><code class="hljs stylus">设计一个支持 push ，pop ，<span class="hljs-attribute">top</span> 操作，并能在常数时间内检索到最小元素的栈。<span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">(x)</span></span> —— 将元素 x 推入栈中。<span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span> —— 删除栈顶的元素。<span class="hljs-function"><span class="hljs-title">top</span><span class="hljs-params">()</span></span> —— 获取栈顶元素。<span class="hljs-function"><span class="hljs-title">getMin</span><span class="hljs-params">()</span></span> —— 检索栈中的最小元素。</code></pre><p>辅助栈</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; dataStack;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; minStack;    <span class="hljs-comment">/** initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;        dataStack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        minStack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        dataStack.push(x);        minStack.push(minStack.isEmpty() ? x : Math.<span class="hljs-built_in">min</span>(minStack.<span class="hljs-built_in">peek</span>(), x));    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        dataStack.pop();        minStack.pop();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> dataStack.<span class="hljs-built_in">peek</span>();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>;    &#125;&#125;</code></pre><h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h2><pre><code class="hljs dns">给定一个无序的整数数组，找到其中最长上升子序列的长度。输入: [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]输出: <span class="hljs-number">4</span> 解释: 最长的上升子序列是 [<span class="hljs-number">2,3,7,101</span>]，它的长度是 <span class="hljs-number">4</span>。</code></pre><p>dp</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLIS(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;        <span class="hljs-keyword">if</span> (nums.length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">nums</span>.<span class="hljs-identifier">length</span>]</span>;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>fill(dp, <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &gt; nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>) &#123;                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, dp<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 关键这里，</span>                &#125;            &#125;        &#125;        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>stream(dp).max<span class="hljs-literal">()</span>.<span class="hljs-keyword">or</span><span class="hljs-constructor">Else(0)</span>;    &#125;&#125;</code></pre><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><pre><code class="hljs makefile">给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。<span class="hljs-section">输入: coins = [1, 2, 5], amount = 11</span><span class="hljs-section">输出: 3 </span><span class="hljs-section">解释: 11 = 5 + 5 + 1</span><span class="hljs-section">输入: coins = [2], amount = 3</span><span class="hljs-section">输出: -1</span></code></pre><p>完全背包</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = coin; i &lt;= amount; i++) &#123; <span class="hljs-comment">//将逆序遍历改为正序遍历</span>                <span class="hljs-keyword">if</span> (i == coin) &#123;                    dp[i] = <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">0</span> &amp;&amp; dp[i - coin] != <span class="hljs-number">0</span>) &#123;                    dp[i] = dp[i - coin] + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i - coin] != <span class="hljs-number">0</span>) &#123;                    dp[i] = Math.<span class="hljs-built_in">min</span>(dp[i], dp[i - coin] + <span class="hljs-number">1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : dp[amount];    &#125;&#125;</code></pre><h2 id="1013-将数组分成和相等的三个部分"><a href="#1013-将数组分成和相等的三个部分" class="headerlink" title="1013. 将数组分成和相等的三个部分"></a>1013. 将数组分成和相等的三个部分</h2><pre><code class="hljs axapta">给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 <span class="hljs-literal">true</span>，否则返回 <span class="hljs-literal">false</span>。形式上，如果可以找出索引 i+<span class="hljs-number">1</span> &lt; j 且满足 A[<span class="hljs-number">0</span>] + A[<span class="hljs-number">1</span>] + ... + A[i] == A[i+<span class="hljs-number">1</span>] + A[i+<span class="hljs-number">2</span>] + ... + A[j<span class="hljs-number">-1</span>] == A[j] + A[j<span class="hljs-number">-1</span>] + ... + A[A.length - <span class="hljs-number">1</span>] 就可以将数组三等分。输入：[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">-7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-literal">true</span>解释：<span class="hljs-number">0</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span> = <span class="hljs-number">-6</span> + <span class="hljs-number">6</span> - <span class="hljs-number">7</span> + <span class="hljs-number">9</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span> + <span class="hljs-number">0</span> + <span class="hljs-number">1</span>输入：[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-literal">false</span>输入：[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-9</span>,<span class="hljs-number">4</span>]输出：<span class="hljs-literal">true</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> canThreePartsEqualSum(<span class="hljs-built_in">int</span>[] A) &#123;        <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 遍历数组求总和</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> num : A) &#123;            <span class="hljs-keyword">sum</span> += num;        &#125;        <span class="hljs-comment">// 数组A的和如果不能被3整除直接返回false</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">// 遍历数组累加，每累加到目标值cnt加1，表示又找到1段</span>        <span class="hljs-keyword">sum</span> /= <span class="hljs-number">3</span>;        <span class="hljs-built_in">int</span> curSum = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++) &#123;            curSum += A[i];            <span class="hljs-keyword">if</span> (curSum == <span class="hljs-keyword">sum</span>) &#123;                cnt++;                curSum = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-comment">// 最后判断是否找到了3段（注意如果目标值是0的话可以大于3段）</span>        <span class="hljs-keyword">return</span> cnt == <span class="hljs-number">3</span> || (cnt &gt; <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-keyword">sum</span> == <span class="hljs-number">0</span>);    &#125;&#125;</code></pre><h2 id="1160-拼写单词"><a href="#1160-拼写单词" class="headerlink" title="1160. 拼写单词"></a>1160. 拼写单词</h2><pre><code class="hljs livecodeserver">给你一份『词汇表』（字符串数组） <span class="hljs-keyword">words</span> 和一张『字母表』（字符串） <span class="hljs-keyword">chars</span>。假如你可以用 <span class="hljs-keyword">chars</span> 中的『字母』（字符）拼写出 <span class="hljs-keyword">words</span> 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。注意：每次拼写（指拼写词汇表中的一个单词）时，<span class="hljs-keyword">chars</span> 中的每个字母都只能用一次。返回词汇表 <span class="hljs-keyword">words</span> 中你掌握的所有单词的 长度之和。输入：<span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;bt&quot;</span>,<span class="hljs-string">&quot;hat&quot;</span>,<span class="hljs-string">&quot;tree&quot;</span>], <span class="hljs-keyword">chars</span> = <span class="hljs-string">&quot;atach&quot;</span>输出：<span class="hljs-number">6</span>解释： 可以形成字符串 <span class="hljs-string">&quot;cat&quot;</span> 和 <span class="hljs-string">&quot;hat&quot;</span>，所以答案是 <span class="hljs-number">3</span> + <span class="hljs-number">3</span> = <span class="hljs-number">6</span>。输入：<span class="hljs-keyword">words</span> = [<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;leetcode&quot;</span>], <span class="hljs-keyword">chars</span> = <span class="hljs-string">&quot;welldonehoneyr&quot;</span>输出：<span class="hljs-number">10</span>解释：可以形成字符串 <span class="hljs-string">&quot;hello&quot;</span> 和 <span class="hljs-string">&quot;world&quot;</span>，所以答案是 <span class="hljs-number">5</span> + <span class="hljs-number">5</span> = <span class="hljs-number">10</span>。</code></pre><p>类似于map的数组即可。双map</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countCharacters</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] words, <span class="hljs-keyword">String</span> chars)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] hash = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : chars.toCharArray()) &#123;            hash[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;        &#125;        <span class="hljs-keyword">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span> : words) &#123;            Arrays.<span class="hljs-built_in">fill</span>(tmp, <span class="hljs-number">0</span>);            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : <span class="hljs-keyword">word</span>.toCharArray()) &#123;                tmp[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;                <span class="hljs-keyword">if</span> (tmp[ch - <span class="hljs-string">&#x27;a&#x27;</span>] &gt; hash[ch - <span class="hljs-string">&#x27;a&#x27;</span>])                     flag = <span class="hljs-literal">false</span>;            &#125;            len += flag ? <span class="hljs-keyword">word</span>.length() : <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> len;    &#125;&#125;</code></pre><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h2><pre><code class="hljs arduino">给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出:[  [<span class="hljs-number">3</span>],  [<span class="hljs-number">1</span>],  [<span class="hljs-number">2</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  []]class Solution &#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;Integer&gt; tempSubset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">size</span> &lt;= nums.length; <span class="hljs-built_in">size</span>++) &#123;            backtracking(<span class="hljs-number">0</span>, tempSubset, subsets, <span class="hljs-built_in">size</span>, nums); <span class="hljs-comment">// 不同的子集大小</span>        &#125;        <span class="hljs-keyword">return</span> subsets;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets,</span></span><span class="hljs-function"><span class="hljs-params">                            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tempSubset.<span class="hljs-built_in">size</span>() == <span class="hljs-built_in">size</span>) &#123;            subsets.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tempSubset));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length; i++) &#123;            tempSubset.add(nums[i]);            backtracking(i + <span class="hljs-number">1</span>, tempSubset, subsets, <span class="hljs-built_in">size</span>, nums);            tempSubset.<span class="hljs-built_in">remove</span>(tempSubset.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h2><pre><code class="hljs xquery">给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">3</span>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>class Solution &#123;    public ListNode deleteDuplicates(ListNode<span class="hljs-built_in"> head</span>) &#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(head</span> == null ||<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> == null) <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;       <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = deleteDuplicates<span class="hljs-built_in">(head</span>.<span class="hljs-keyword">next</span>);        <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>.val ==<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>.val ?<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> :<span class="hljs-built_in"> head</span>;    &#125;&#125;</code></pre><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h2><pre><code class="hljs css">给定一个二叉树，返回它的中序 遍历。输入: <span class="hljs-selector-attr">[1,null,2,3]</span>   1    \     2    /   3输出: <span class="hljs-selector-attr">[1,3,2]</span></code></pre><p>栈</p><pre><code class="hljs lasso">class Solution &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; ret = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-built_in">null</span>) <span class="hljs-keyword">return</span> ret;        <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();        TreeNode cur = root;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-built_in">null</span> || !<span class="hljs-built_in">stack</span>.isEmpty()) &#123;            <span class="hljs-keyword">while</span> (cur != <span class="hljs-built_in">null</span>) &#123;                <span class="hljs-built_in">stack</span>.push(cur);                cur = cur.left; <span class="hljs-comment">// 遍历到做左</span>            &#125;            TreeNode node = <span class="hljs-built_in">stack</span>.pop(); <span class="hljs-comment">// 从下往上弹</span>            ret.add(node.val);            cur = node.right; <span class="hljs-comment">// 弹完遍历右</span>        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h2><pre><code class="hljs kotlin">给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。输入:       <span class="hljs-number">1</span>         <span class="hljs-number">1</span>          / \       / \         <span class="hljs-number">2</span>   <span class="hljs-number">3</span>     <span class="hljs-number">2</span>   <span class="hljs-number">3</span>        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],   [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出: <span class="hljs-literal">true</span>输入:      <span class="hljs-number">1</span>          <span class="hljs-number">1</span>          /           \         <span class="hljs-number">2</span>             <span class="hljs-number">2</span>        [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],     [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-literal">false</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> boolean isSameTree(TreeNode p, TreeNode q) &#123;        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span>(p.<span class="hljs-keyword">val</span> != q.<span class="hljs-keyword">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);    &#125;&#125;</code></pre><h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h2><pre><code class="hljs csharp">输入: <span class="hljs-number">5</span>输出:[<span class="hljs-meta"></span><span class="hljs-meta">     [1</span>],    [<span class="hljs-meta">1,1</span>],   [<span class="hljs-meta">1,2,1</span>],  [<span class="hljs-meta">1,3,3,1</span>], [<span class="hljs-meta">1,4,6,4,1</span>]]<span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="hljs-built_in">int</span> numRows) &#123;        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;            List&lt;Integer&gt; curRow = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || j == i) &#123;                    curRow.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == <span class="hljs-number">1</span>) &#123;                    <span class="hljs-keyword">continue</span>;                &#125;                List&lt;Integer&gt; preRow = ans.<span class="hljs-keyword">get</span>(i - <span class="hljs-number">1</span>);                <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = preRow.<span class="hljs-keyword">get</span>(j - <span class="hljs-number">1</span>) + preRow.<span class="hljs-keyword">get</span>(j);                curRow.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">value</span>);            &#125;            ans.<span class="hljs-keyword">add</span>(curRow);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p>双指针，A走完，走B，B走完，走A</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode <span class="hljs-function"><span class="hljs-title">getIntersectionNode</span>(<span class="hljs-params">ListNode headA, ListNode headB</span>)</span> &#123;        ListNode l1 = headA, l2 = headB;        <span class="hljs-keyword">while</span> (l1 != l2) &#123;            l1 = (l1 == <span class="hljs-literal">null</span>) ? headB : l1.next;            l2 = (l2 == <span class="hljs-literal">null</span>) ? headA : l2.next;        &#125;        <span class="hljs-keyword">return</span> l1;    &#125;&#125;</code></pre><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><pre><code class="hljs lasso">编写一个算法来判断一个数 n 是不是快乐数。「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 <span class="hljs-number">1</span>，也可能是 无限循环 但始终变不到 <span class="hljs-number">1</span>。如果 可以变为  <span class="hljs-number">1</span>，那么这个数就是快乐数。如果 n 是快乐数就返回 <span class="hljs-literal">True</span> ；不是，则返回 <span class="hljs-literal">False</span> 。输入：<span class="hljs-number">19</span>输出：<span class="hljs-literal">true</span>解释：<span class="hljs-number">12</span> + <span class="hljs-number">92</span> = <span class="hljs-number">82</span><span class="hljs-number">82</span> + <span class="hljs-number">22</span> = <span class="hljs-number">68</span><span class="hljs-number">62</span> + <span class="hljs-number">82</span> = <span class="hljs-number">100</span><span class="hljs-number">12</span> + <span class="hljs-number">02</span> + <span class="hljs-number">02</span> = <span class="hljs-number">1</span>class Solution &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isHappy(int n) &#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        HashSet&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">set</span> = <span class="hljs-literal">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">while</span>(<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>) &#123;            int <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">sum</span> += (n % <span class="hljs-number">10</span>) *(n % <span class="hljs-number">10</span>);                n /= <span class="hljs-number">10</span>;            &#125;            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">sum</span> == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">set</span>.add(<span class="hljs-keyword">sum</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            n = <span class="hljs-keyword">sum</span>;        &#125;    &#125;&#125;</code></pre><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h2><p>请判断一个链表是否为回文链表。</p><pre><code class="hljs axapta">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>输出: <span class="hljs-literal">false</span>输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>输出: <span class="hljs-literal">true</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isPalindrome(ListNode head) &#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 找中点</span>        ListNode slow = head, fast = head.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            slow = slow.<span class="hljs-keyword">next</span>;            fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>) slow = slow.<span class="hljs-keyword">next</span>;        <span class="hljs-comment">// cut</span>        cut(head, slow);        <span class="hljs-comment">// 比较</span>        <span class="hljs-keyword">return</span> isEqual(head, <span class="hljs-keyword">reverse</span>(slow));            &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> cut (ListNode head, ListNode cutNode) &#123;        ListNode node = head;        <span class="hljs-keyword">while</span>(node.<span class="hljs-keyword">next</span> != cutNode) &#123;            node = node.<span class="hljs-keyword">next</span>;        &#125;        node.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;    &#125;        <span class="hljs-keyword">public</span> ListNode <span class="hljs-keyword">reverse</span>(ListNode head) &#123;        ListNode pre = <span class="hljs-literal">null</span>;        ListNode cur = head;        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;            ListNode nextNode = cur.<span class="hljs-keyword">next</span>;            cur.<span class="hljs-keyword">next</span> = pre;            pre = cur;            cur = nextNode;        &#125;        <span class="hljs-keyword">return</span> pre;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isEqual(ListNode l1, ListNode l2) &#123;        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span>(l1.val != l2.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            l1 = l1.<span class="hljs-keyword">next</span>;            l2 = l2.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h2><pre><code class="hljs css">编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <span class="hljs-selector-tag">char</span><span class="hljs-selector-attr">[]</span> 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 <span class="hljs-selector-tag">O</span>(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 <span class="hljs-selector-tag">ASCII</span> 码表中的可打印字符。输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]</span>输出：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]</span>输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]</span>输出：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>]</span></code></pre><p>双指针</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s)</span> </span>&#123;        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = s.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(p1 &lt; p2 )&#123;            swap(s, p1++, p2--);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">char</span> temp = s[i];        s[i] = s[j];        s[j] = temp;    &#125;&#125;</code></pre><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h2><pre><code class="hljs angelscript">给定一个包含了一些 <span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 的非空二维数组 grid 。一个 岛屿 是由一些相邻的 <span class="hljs-number">1</span> (代表土地) 构成的组合，这里的「相邻」要求两个 <span class="hljs-number">1</span> 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 <span class="hljs-number">0</span>（代表水）包围着。找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 <span class="hljs-number">0</span> 。)<span class="hljs-string">[[0,0,1,0,0,0,0,1,0,0,0,0,0]</span>,<span class="hljs-string"> [0,0,0,0,0,0,0,1,1,1,0,0,0]</span>,<span class="hljs-string"> [0,1,1,0,1,0,0,0,0,0,0,0,0]</span>,<span class="hljs-string"> [0,1,0,0,1,1,0,0,1,0,1,0,0]</span>,<span class="hljs-string"> [0,1,0,0,1,1,0,0,1,1,1,0,0]</span>,<span class="hljs-string"> [0,0,0,0,0,0,0,0,0,0,1,0,0]</span>,<span class="hljs-string"> [0,0,0,0,0,0,0,1,1,1,0,0,0]</span>,<span class="hljs-string"> [0,0,0,0,0,0,0,1,1,0,0,0,0]</span>] 对于上面这个给定矩阵应返回 <span class="hljs-number">6</span>。注意答案不应该是 <span class="hljs-number">11</span> ，因为岛屿只能包含水平或垂直的四个方向的 <span class="hljs-number">1</span> 。<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m, n;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[][] direaction = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxAreaOfIsland(<span class="hljs-built_in">int</span>[][] grid) &#123;        <span class="hljs-keyword">if</span>(grid == <span class="hljs-literal">null</span> || grid.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        m = grid.length;        n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-built_in">int</span> maxArea = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                maxArea = Math.max(maxArea, dfs(grid, i, j));            &#125;        &#125;        <span class="hljs-keyword">return</span> maxArea;    &#125;       <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> dfs(<span class="hljs-built_in">int</span>[][] grid, <span class="hljs-built_in">int</span> r, <span class="hljs-built_in">int</span> c) &#123;        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> || r &gt;= m || c &lt; <span class="hljs-number">0</span> || c &gt;= n || grid[r][c] == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        grid[r][c] = <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> area = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span>[] d : direaction) &#123;            area += dfs(grid, r + d[<span class="hljs-number">0</span>], c + d[<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> area;    &#125;&#125;</code></pre><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><pre><code class="hljs inform7">请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。例如，给定一个列表 temperatures = <span class="hljs-comment">[73, 74, 75, 71, 69, 72, 76, 73]</span>，你的输出应该是 <span class="hljs-comment">[1, 1, 4, 2, 1, 1, 0, 0]</span>。提示：气温 列表长度的范围是 <span class="hljs-comment">[1, 30000]</span>。每个气温的值的均为华氏度，都是在 <span class="hljs-comment">[30, 100]</span> 范围内的整数。</code></pre><p>递减栈</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;        Stack&lt;Integer&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T.length; i++) &#123;            <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stack</span>.isEmpty() &amp;&amp; T[i] &gt; T[<span class="hljs-built_in">stack</span>.<span class="hljs-built_in">peek</span>()]) &#123;                <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">stack</span>.pop();                res[t] = i - t;            &#125;            <span class="hljs-built_in">stack</span>.push(i);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><pre><code class="hljs fortran">给定一个无重复元素的数组 candidates 和一个目标数 <span class="hljs-keyword">target</span> ，找出 candidates 中所有可以使数字和为 <span class="hljs-keyword">target</span> 的组合。candidates 中的数字可以无限制重复被选取。输入: candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">7</span>,所求解集为:[  [<span class="hljs-number">7</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]输入: candidates = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">7</span>,所求解集为:[  [<span class="hljs-number">7</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; combinationSum(<span class="hljs-built_in">int</span>[] candidates, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>) &#123;        List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; combinations = new ArrayList&lt;&gt;();        backtracking(new ArrayList&lt;&gt;(), combinations, <span class="hljs-number">0</span>, <span class="hljs-keyword">target</span>, candidates);        <span class="hljs-keyword">return</span> combinations;    &#125;    <span class="hljs-keyword">private</span> void backtracking(List&lt;<span class="hljs-keyword">Integer</span>&gt; tempCombination, List&lt;List&lt;<span class="hljs-keyword">Integer</span>&gt;&gt; combinations,                            <span class="hljs-built_in">int</span> start, <span class="hljs-built_in">int</span> <span class="hljs-keyword">target</span>, <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span>[] candidates) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == <span class="hljs-number">0</span>) &#123;            combinations<span class="hljs-number">.</span>add(new ArrayList&lt;&gt;(tempCombination));            <span class="hljs-keyword">return</span>;        &#125;        for (<span class="hljs-built_in">int</span> i = start; i &lt; candidates<span class="hljs-number">.</span>length; i++) &#123;            <span class="hljs-keyword">if</span> (candidates[i] &lt;= <span class="hljs-keyword">target</span>) &#123;                tempCombination<span class="hljs-number">.</span>add(candidates[i]);                backtracking(tempCombination, combinations, i, <span class="hljs-keyword">target</span> - candidates[i], candidates);                tempCombination<span class="hljs-number">.</span>remove(tempCombination<span class="hljs-number">.</span><span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h2><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><pre><code class="hljs accesslog">​```html输入: <span class="hljs-string">[2,0,2,1,1,0]</span>输出: <span class="hljs-string">[0,0,1,1,2,2]</span></code></pre><p>zero和two作为双指针</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> zero = <span class="hljs-number">-1</span>, one = <span class="hljs-number">0</span>, two = nums.length;        <span class="hljs-keyword">while</span> (one &lt; two) &#123;            <span class="hljs-keyword">if</span> (nums[one] == <span class="hljs-number">0</span>) &#123;                swap(nums, ++zero, one++);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[one] == <span class="hljs-number">2</span>)&#123;                swap(nums, --two, one);            &#125; <span class="hljs-keyword">else</span> &#123;                ++one;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">int</span> t = a[i];        a[i] = a[j];        a[j] = t;    &#125;&#125;</code></pre><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><pre><code class="hljs reasonml">给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明: 叶子节点是指没有子节点的节点。    <span class="hljs-number">3</span><span class="hljs-operator">   / </span>\  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><span class="hljs-operator">    /  </span>\   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><span class="hljs-number">2</span><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> min<span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;        <span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>null) return <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> l = min<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;        <span class="hljs-built_in">int</span> r = min<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;        <span class="hljs-keyword">if</span>(l<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> || </span>r<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return l + r + <span class="hljs-number">1</span>;        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(l, r) + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a>120. 三角形最小路径和</h2><pre><code class="hljs inform7">给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。<span class="hljs-comment">[</span><span class="hljs-comment">     <span class="hljs-comment">[2]</span>,</span><span class="hljs-comment">    <span class="hljs-comment">[3,4]</span>,</span><span class="hljs-comment">   <span class="hljs-comment">[6,5,7]</span>,</span><span class="hljs-comment">  <span class="hljs-comment">[4,1,8,3]</span></span><span class="hljs-comment">]</span></code></pre><p>dp</p><pre><code class="hljs processing">class Solution &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> minimumTotal(List&lt;List&lt;Integer&gt;&gt; <span class="hljs-built_in">triangle</span>) &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> row = <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[row][<span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(row - <span class="hljs-number">1</span>).<span class="hljs-built_in">size</span>()];        <span class="hljs-comment">// 初始化</span>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j =<span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(i).<span class="hljs-built_in">size</span>(); j++) &#123;                dp[i][j] = <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(i).<span class="hljs-built_in">get</span>(j);            &#125;        &#125;        <span class="hljs-comment">// 从下往上， 初始化最后一行</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(row - <span class="hljs-number">1</span>).<span class="hljs-built_in">size</span>(); i++) &#123;            dp[row - <span class="hljs-number">1</span>][i] = <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(row - <span class="hljs-number">1</span>).<span class="hljs-built_in">get</span>(i);        &#125;        <span class="hljs-comment">// 动态规划</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = row - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(i).<span class="hljs-built_in">size</span>(); j++) &#123;                dp[i][j] = Math.<span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]) + <span class="hljs-built_in">triangle</span>.<span class="hljs-built_in">get</span>(i).<span class="hljs-built_in">get</span>(j);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];    &#125;&#125;</code></pre><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h2><pre><code class="hljs cpp">输入: [<span class="hljs-number">1</span>,null,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]     <span class="hljs-number">1</span>    \     <span class="hljs-number">2</span>    /   <span class="hljs-number">3</span> 输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Stack&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-built_in">stack</span>.push(root);        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stack</span>.isEmpty()) &#123;            TreeNode node = <span class="hljs-built_in">stack</span>.pop();            <span class="hljs-keyword">if</span> (node == null) <span class="hljs-keyword">continue</span>;            ret.add(node.val);            <span class="hljs-built_in">stack</span>.push(node.right);            <span class="hljs-built_in">stack</span>.push(node.left);        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre><h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h2><pre><code class="hljs stata">输入: [1,null,2,3]     1    \     2    /   3 输出: [3,2,1]<span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-keyword">List</span>&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;        <span class="hljs-keyword">List</span>&lt;Integer&gt; <span class="hljs-keyword">ret</span> = new ArrayList&lt;&gt;();        <span class="hljs-keyword">Stack</span>&lt;TreeNode&gt; <span class="hljs-keyword">stack</span> = new <span class="hljs-keyword">Stack</span>&lt;&gt;();        <span class="hljs-keyword">stack</span>.push(root);        <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">stack</span>.isEmpty()) &#123;            TreeNode node = <span class="hljs-keyword">stack</span>.pop();            <span class="hljs-keyword">if</span> (node == null) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">ret</span>.add(node.val);            <span class="hljs-keyword">stack</span>.push(node.left);            <span class="hljs-keyword">stack</span>.push(node.right);        &#125;        Collections.<span class="hljs-built_in">reverse</span>(<span class="hljs-keyword">ret</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;    &#125;&#125;</code></pre><h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h2><pre><code class="hljs makefile">给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<span class="hljs-section">输入: [2,3,-2,4]</span><span class="hljs-section">输出: 6</span><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><span class="hljs-section">输入: [-2,0,-1]</span><span class="hljs-section">输出: 0</span><span class="hljs-section">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span></code></pre><p>dp</p><pre><code class="hljs inform7">class Solution &#123;    public int maxProduct(int<span class="hljs-comment">[]</span> nums) &#123;        if (nums.length == 0) return 0;        int ans = Integer.MIN_VALUE;        int<span class="hljs-comment">[]</span> dpMax = new int<span class="hljs-comment">[nums.length + 1]</span>;        int<span class="hljs-comment">[]</span> dpMin = new int<span class="hljs-comment">[nums.length + 1]</span>;        dpMax<span class="hljs-comment">[0]</span> = 1;        dpMin<span class="hljs-comment">[0]</span> = 1;        for (int i = 1; i &lt;= nums.length; i++) &#123;            if (nums<span class="hljs-comment">[i-1]</span> &lt; 0) &#123;                int temp = dpMax<span class="hljs-comment">[i-1]</span>;                dpMax<span class="hljs-comment">[i-1]</span> = dpMin<span class="hljs-comment">[i-1]</span>;                dpMin<span class="hljs-comment">[i-1]</span> = temp;            &#125;            dpMax<span class="hljs-comment">[i]</span> = Math.max(dpMax<span class="hljs-comment">[i-1]</span>*nums<span class="hljs-comment">[i-1]</span>, nums<span class="hljs-comment">[i-1]</span>);            dpMin<span class="hljs-comment">[i]</span> = Math.min(dpMin<span class="hljs-comment">[i-1]</span>*nums<span class="hljs-comment">[i-1]</span>, nums<span class="hljs-comment">[i-1]</span>);            ans = Math.max(ans, dpMax<span class="hljs-comment">[i]</span>);        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h2><pre><code class="hljs axapta">给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。说明:返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。输入: numbers = [<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>], target = <span class="hljs-number">9</span>输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]解释: <span class="hljs-number">2</span> 与 <span class="hljs-number">7</span> 之和等于目标数 <span class="hljs-number">9</span> 。因此 index1 = <span class="hljs-number">1</span>, index2 = <span class="hljs-number">2</span> 。<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] twoSum(<span class="hljs-built_in">int</span>[] numbers, <span class="hljs-built_in">int</span> target) &#123;        <span class="hljs-keyword">if</span> (numbers == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 双指针</span>        <span class="hljs-built_in">int</span> p1 = <span class="hljs-number">0</span>, p2 = numbers.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;            <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = numbers[p1] + numbers[p2];            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> == target) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;p1+<span class="hljs-number">1</span>, p2+<span class="hljs-number">1</span>&#125;;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> &lt; target) p1++;            <span class="hljs-keyword">else</span> p2--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre><h2 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h2><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><pre><code class="hljs pgsql">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] 和 k = <span class="hljs-number">3</span>输出: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]解释:向右旋转 <span class="hljs-number">1</span> 步: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]向右旋转 <span class="hljs-number">2</span> 步: [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]向右旋转 <span class="hljs-number">3</span> 步: [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]输入: [<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>,<span class="hljs-number">3</span>,<span class="hljs-number">99</span>] 和 k = <span class="hljs-number">2</span>输出: [<span class="hljs-number">3</span>,<span class="hljs-number">99</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>]解释: 向右旋转 <span class="hljs-number">1</span> 步: [<span class="hljs-number">99</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>,<span class="hljs-number">3</span>]向右旋转 <span class="hljs-number">2</span> 步: [<span class="hljs-number">3</span>,<span class="hljs-number">99</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-100</span>]<span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> rotate(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;        <span class="hljs-type">int</span> n = nums.length;        k %= n;        reverse(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);        reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);        reverse(nums, k, n - <span class="hljs-number">1</span>);    &#125;    private <span class="hljs-type">void</span> reverse(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>) &#123;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;            <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = nums[<span class="hljs-keyword">start</span>];            nums[<span class="hljs-keyword">start</span>++] = nums[<span class="hljs-keyword">end</span>];            nums[<span class="hljs-keyword">end</span><span class="hljs-comment">--] = temp;</span>        &#125;    &#125;&#125;</code></pre><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><pre><code class="hljs livescript">     <span class="hljs-number">4</span>   /   <span class="hljs-string">\</span>  <span class="hljs-number">2</span>     <span class="hljs-number">7</span> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span>     <span class="hljs-number">4</span>   /   <span class="hljs-string">\</span>  <span class="hljs-number">7</span>     <span class="hljs-number">2</span> / <span class="hljs-string">\</span>   / <span class="hljs-string">\</span><span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    public TreeNode invertTree(TreeNode root) &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        TreeNode left = root.left;        root.left = invertTree(root.right);        root.right = invertTree(left);        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h2><pre><code class="hljs groovy">给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。输入: s = <span class="hljs-string">&quot;anagram&quot;</span>, t = <span class="hljs-string">&quot;nagaram&quot;</span>输出: <span class="hljs-literal">true</span>输入: s = <span class="hljs-string">&quot;rat&quot;</span>, t = <span class="hljs-string">&quot;car&quot;</span>输出: <span class="hljs-literal">false</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> isAnagram(String s, String t) &#123;        <span class="hljs-keyword">int</span>[] cnts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> <span class="hljs-attr">c :</span> s.toCharArray()) &#123;            cnts[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> <span class="hljs-attr">c :</span> t.toCharArray()) &#123;            cnts[c - <span class="hljs-string">&#x27;a&#x27;</span>]--;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-attr">c :</span> cnts) &#123;            <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h2><pre><code class="hljs makefile">给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<span class="hljs-section">输入: [1,3,4,2,2]</span><span class="hljs-section">输出: 2</span><span class="hljs-section">输入: [3,1,3,4,2]</span><span class="hljs-section">输出: 3</span></code></pre><p>快慢指针</p><pre><code class="hljs nginx"><span class="hljs-attribute">class</span> Solution &#123;    <span class="hljs-attribute">public</span> int findDuplicate(int[] nums) &#123;        <span class="hljs-attribute">int</span> slow = nums[<span class="hljs-number">0</span>], fast = nums[nums[<span class="hljs-number">0</span>]];        <span class="hljs-attribute">while</span> (slow != fast) &#123;            <span class="hljs-attribute">slow</span> = nums[slow];            <span class="hljs-attribute">fast</span> = nums[nums[fast]];        &#125;        <span class="hljs-attribute">fast</span> = <span class="hljs-number">0</span>;        <span class="hljs-attribute">while</span> (slow != fast) &#123;            <span class="hljs-attribute">slow</span> = nums[slow];            <span class="hljs-attribute">fast</span> = nums[fast];        &#125;        <span class="hljs-attribute">return</span> slow;    &#125;&#125;</code></pre><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h2><pre><code class="hljs typescript">给定字符串 s 和 t ，判断 s 是否为 t 的子序列。你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= <span class="hljs-number">500</span>,<span class="hljs-number">000</span>），而 s 是个短字符串（长度 &lt;=<span class="hljs-number">100</span>）。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<span class="hljs-string">&quot;ace&quot;</span>是<span class="hljs-string">&quot;abcde&quot;</span>的一个子序列，而<span class="hljs-string">&quot;aec&quot;</span>不是）。s = <span class="hljs-string">&quot;abc&quot;</span>, t = <span class="hljs-string">&quot;ahbgdc&quot;</span>返回 <span class="hljs-literal">true</span>.s = <span class="hljs-string">&quot;axc&quot;</span>, t = <span class="hljs-string">&quot;ahbgdc&quot;</span>返回 <span class="hljs-literal">false</span>.<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSubsequence</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s, <span class="hljs-built_in">String</span> t</span>)</span> &#123;        <span class="hljs-comment">// 这里用到了String到indexof</span>        int inx = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (char c : s.toCharArray()) &#123;            inx = t.indexOf(c, inx + <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (inx == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a>445. 两数相加 II</h2><pre><code class="hljs clean">给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 <span class="hljs-number">0</span> 之外，这两个数字都不会以零开头。输入：(<span class="hljs-number">7</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">8</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">7</span></code></pre><p>双栈</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public ListNode add<span class="hljs-constructor">TwoNumbers(ListNode <span class="hljs-params">l1</span>, ListNode <span class="hljs-params">l2</span>)</span> &#123;        Stack&lt;Integer&gt; l1Stack = build<span class="hljs-constructor">Stack(<span class="hljs-params">l1</span>)</span>;        Stack&lt;Integer&gt; l2Stack = build<span class="hljs-constructor">Stack(<span class="hljs-params">l2</span>)</span>;        ListNode head = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(-1)</span>;        <span class="hljs-built_in">int</span> carray = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!l1Stack.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> || </span>!l2Stack.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator"> || </span>carray != <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">int</span> x = l1Stack.is<span class="hljs-constructor">Empty()</span> ? <span class="hljs-number">0</span> : l1Stack.pop<span class="hljs-literal">()</span>;            <span class="hljs-built_in">int</span> y = l2Stack.is<span class="hljs-constructor">Empty()</span> ? <span class="hljs-number">0</span> : l2Stack.pop<span class="hljs-literal">()</span>;            <span class="hljs-built_in">int</span> sum = x + y + carray;            ListNode node = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ListNode(<span class="hljs-params">sum</span> % 10)</span>;            node.next = head.next;            head.next = node;            carray = sum<span class="hljs-operator"> / </span><span class="hljs-number">10</span>;        &#125;        return head.next;    &#125;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; build<span class="hljs-constructor">Stack(ListNode <span class="hljs-params">l</span>)</span> &#123;        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">while</span> (l != null) &#123;            stack.push(l.<span class="hljs-keyword">val</span>);            l = l.next;        &#125;        return stack;    &#125;&#125;</code></pre><h2 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836. 矩形重叠"></a>836. 矩形重叠</h2><pre><code class="hljs inform7">矩形以列表 <span class="hljs-comment">[x1, y1, x2, y2]</span> 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。给出两个矩形，判断它们是否重叠并返回结果。矩形以列表 <span class="hljs-comment">[x1, y1, x2, y2]</span> 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。给出两个矩形，判断它们是否重叠并返回结果。输入：rec1 = <span class="hljs-comment">[0,0,2,2]</span>, rec2 = <span class="hljs-comment">[1,1,3,3]</span>输出：true输入：rec1 = <span class="hljs-comment">[0,0,1,1]</span>, rec2 = <span class="hljs-comment">[1,0,2,1]</span>输出：falseclass Solution &#123;    public boolean isRectangleOverlap(int<span class="hljs-comment">[]</span> rec1, int<span class="hljs-comment">[]</span> rec2) &#123;        if (rec2<span class="hljs-comment">[1]</span> &gt;= rec1<span class="hljs-comment">[3]</span> || rec1<span class="hljs-comment">[1]</span> &gt;= rec2<span class="hljs-comment">[3]</span>) &#123;            return false;        &#125;        if (rec1<span class="hljs-comment">[0]</span> &gt;= rec2<span class="hljs-comment">[2]</span> || rec1<span class="hljs-comment">[2]</span> &lt;= rec2<span class="hljs-comment">[0]</span>) &#123;            return false;        &#125;        return true;    &#125;&#125;</code></pre><h2 id="914-卡牌分组"><a href="#914-卡牌分组" class="headerlink" title="914. 卡牌分组"></a>914. 卡牌分组</h2><pre><code class="hljs arduino">给定一副牌，每张牌上都写着一个整数。此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 <span class="hljs-number">1</span> 组或更多组：每组都有 X 张牌。组内所有的牌上都写着相同的整数。仅当你可选的 X &gt;= <span class="hljs-number">2</span> 时返回 <span class="hljs-literal">true</span>。输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]输出：<span class="hljs-literal">true</span>解释：可行的分组是 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]，[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]，[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]，[<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]输入：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]输出：<span class="hljs-literal">false</span>解释：没有满足要求的分组。class Solution &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> hasGroupsSizeX(<span class="hljs-keyword">int</span>[] deck) &#123;        <span class="hljs-comment">// hash</span>        HashMap&lt;Integer, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : deck) &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>.containsKey(num)) &#123;                <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(num, <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(num) + <span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(num, <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-comment">// 最大公约数</span>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : <span class="hljs-built_in">map</span>.values()) &#123;            t = gcd(t, a);        &#125;        <span class="hljs-keyword">return</span> t &gt;= <span class="hljs-number">2</span>;    &#125;    <span class="hljs-comment">// 最大公约数</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);    &#125;&#125;</code></pre><h2 id="1071-字符串的最大公因子"><a href="#1071-字符串的最大公因子" class="headerlink" title="1071. 字符串的最大公因子"></a>1071. 字符串的最大公因子</h2><pre><code class="hljs typescript">对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 <span class="hljs-number">1</span> 次或多次）时，我们才认定 “T 能除尽 S”。返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。输入：str1 = <span class="hljs-string">&quot;ABCABC&quot;</span>, str2 = <span class="hljs-string">&quot;ABC&quot;</span>输出：<span class="hljs-string">&quot;ABC&quot;</span>输入：str1 = <span class="hljs-string">&quot;ABABAB&quot;</span>, str2 = <span class="hljs-string">&quot;ABAB&quot;</span>输出：<span class="hljs-string">&quot;AB&quot;</span>输入：str1 = <span class="hljs-string">&quot;LEET&quot;</span>, str2 = <span class="hljs-string">&quot;CODE&quot;</span>输出：<span class="hljs-string">&quot;&quot;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">gcdOfStrings</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> str1, <span class="hljs-built_in">String</span> str2</span>)</span> &#123;        <span class="hljs-keyword">if</span> (!(str1 + str2).equals(str2 + str1)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;        &#125;        <span class="hljs-keyword">return</span> str2.substring(<span class="hljs-number">0</span>, gcd(str1.length(), str2.length()));    &#125;    <span class="hljs-keyword">private</span> int <span class="hljs-function"><span class="hljs-title">gcd</span>(<span class="hljs-params">int a, int b</span>)</span> &#123;        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);    &#125;&#125;</code></pre><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h2><pre><code class="hljs cpp">    <span class="hljs-comment">//源于离散数学及其应用的算法：（以3 4 5 2 1 为例）</span>    <span class="hljs-comment">//从后往前寻找第一次出现的正序对：（找到 4,5）</span>    <span class="hljs-comment">//之后因为从5 开始都是逆序，所以把他们反转就是正序：3 4 1 2 5</span>    <span class="hljs-comment">//之后4 的位置应该是：在它之后的，比他大的最小值（5）</span>    <span class="hljs-comment">//交换这两个值：得到 3 5 1 2 4</span>    <span class="hljs-comment">// 对于初始即为逆序的序列，将在反转步骤直接完成</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = nums.length;        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> i = len - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] &gt;= nums[i])            i--; <span class="hljs-comment">// 从后向前找第一个正序，这里最后i指向的是逆序起始位置</span>        reverse(nums, i, len - <span class="hljs-number">1</span>); <span class="hljs-comment">// 翻转后面的逆序区域，使其变为正序</span>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; len &amp;&amp; nums[j] &gt;= nums[i])            i++; <span class="hljs-comment">// 找到第一个比nums[j]大的元素，交换即可</span>        <span class="hljs-comment">// 交换</span>        swap(nums, i, j);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">while</span> (i &lt; j) &#123;            swap(nums, i++, j--);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;        <span class="hljs-keyword">int</span> t = nums[i];        nums[i] = nums[j];        nums[j] = t;    &#125;&#125;</code></pre><h2 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h2><blockquote><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><pre><code class="hljs csharp">&gt;输入:&gt;[ [<span class="hljs-meta"><span class="hljs-meta-string">&quot;5&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>], [<span class="hljs-meta"><span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;5&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>], [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>], [<span class="hljs-meta"><span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span></span>], [<span class="hljs-meta"><span class="hljs-meta-string">&quot;4&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span></span>], [<span class="hljs-meta"><span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;2&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span></span>], [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;2&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>], [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;4&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;5&quot;</span></span>], [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span></span>]&gt;]&gt;输出: <span class="hljs-literal">true</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-comment">// 记录某行，某位数字是否已经被摆放</span>        <span class="hljs-keyword">boolean</span>[][] row = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];        <span class="hljs-comment">// 记录某列，某位数字是否已经被摆放</span>        <span class="hljs-keyword">boolean</span>[][] col = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];        <span class="hljs-comment">// 记录某3x3宫格内，某位数字是否已经被摆放</span>        <span class="hljs-keyword">boolean</span>[][] block = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">9</span>][<span class="hljs-number">9</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;                    <span class="hljs-keyword">int</span> num = board[i][j] - <span class="hljs-string">&#x27;1&#x27;</span>;                    <span class="hljs-keyword">int</span> blockIdx = i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span> + j / <span class="hljs-number">3</span>;                    <span class="hljs-keyword">if</span> (row[i][num] || col[j][num] || block[blockIdx][num]) &#123;                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        row[i][num] = <span class="hljs-literal">true</span>;                        col[j][num] = <span class="hljs-literal">true</span>;                        block[blockIdx][num] = <span class="hljs-literal">true</span>;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h2><pre><code class="hljs pgsql">给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 输入: candidates = [<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], target = <span class="hljs-number">8</span>,所求解集为:[  [<span class="hljs-number">1</span>, <span class="hljs-number">7</span>],  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>],  [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>],  [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>]]<span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinationSum2(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target) &#123;        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinations = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();        Arrays.sort(candidates);        backtracking(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(), combinations, <span class="hljs-built_in">new</span> <span class="hljs-type">boolean</span>[candidates.length], <span class="hljs-number">0</span>, target, candidates);        <span class="hljs-keyword">return</span> combinations;    &#125;    private <span class="hljs-type">void</span> backtracking(List&lt;<span class="hljs-type">Integer</span>&gt; tempCombination, List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; combinations,                            <span class="hljs-type">boolean</span>[] hasVisited, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> target, final <span class="hljs-type">int</span>[] candidates) &#123;        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;            combinations.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(tempCombination));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">start</span>; i &lt; candidates.length; i++) &#123;            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; !hasVisited[i - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (candidates[i] &lt;= target) &#123;                tempCombination.<span class="hljs-keyword">add</span>(candidates[i]);                hasVisited[i] = <span class="hljs-keyword">true</span>;                backtracking(tempCombination, combinations, hasVisited, i + <span class="hljs-number">1</span>, target - candidates[i], candidates);                hasVisited[i] = <span class="hljs-keyword">false</span>;                tempCombination.remove(tempCombination.size() - <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h2><pre><code class="hljs arduino">给定一个可包含重复数字的序列，返回所有不重复的全排列。输入: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]输出:[  [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">permuteUnique</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        List&lt;List&lt;Integer&gt;&gt; permutes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;Integer&gt; permuteList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(nums); <span class="hljs-comment">// 排序</span>        <span class="hljs-keyword">boolean</span>[] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];        backtracking(permuteList, permutes, hasVisited, nums);        <span class="hljs-keyword">return</span> permutes;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (permuteList.<span class="hljs-built_in">size</span>() == nums.length) &#123;            permutes.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(permuteList));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; visited.length; i++) &#123;            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i <span class="hljs-number">-1</span>] &amp;&amp; !visited[i - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 防止重复</span>            &#125;            <span class="hljs-keyword">if</span> (visited[i]) <span class="hljs-keyword">continue</span>;            visited[i] = <span class="hljs-literal">true</span>;            permuteList.add(nums[i]);            backtracking(permuteList, permutes, visited, nums);            permuteList.<span class="hljs-built_in">remove</span>(permuteList.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);            visited[i] = <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;</code></pre><h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><pre><code class="hljs prolog">给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span>输出：<span class="hljs-number">3</span>解释：horse -&gt; rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)rorse -&gt; rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)rose -&gt; ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)class <span class="hljs-symbol">Solution</span> &#123;    public int minDistance(<span class="hljs-symbol">String</span> word1, <span class="hljs-symbol">String</span> word2) &#123;        if (word1 == null || word2 == null) &#123;            return <span class="hljs-number">0</span>;        &#125;        int m = word1.length(), n = word2.length();        int[][] dp = new int[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];        for (int i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;            dp[i][<span class="hljs-number">0</span>] = i;        &#125;        for (int i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            dp[<span class="hljs-number">0</span>][i] = i;        &#125;        for (int i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;            for (int j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;                if (word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>)) &#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];                &#125; else &#123;                    dp[i][j] = <span class="hljs-symbol">Math</span>.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-symbol">Math</span>.min(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        return dp[m][n];    &#125;&#125;</code></pre><h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h2><pre><code class="hljs arduino">给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。board =[  [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>],  [<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;S&#x27;</span>],  [<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>]]给定 <span class="hljs-keyword">word</span> = <span class="hljs-string">&quot;ABCCED&quot;</span>, 返回 <span class="hljs-literal">true</span>给定 <span class="hljs-keyword">word</span> = <span class="hljs-string">&quot;SEE&quot;</span>, 返回 <span class="hljs-literal">true</span>给定 <span class="hljs-keyword">word</span> = <span class="hljs-string">&quot;ABCB&quot;</span>, 返回 <span class="hljs-literal">false</span>class Solution &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] direction = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span>)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">word</span> == null || <span class="hljs-keyword">word</span>.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (board == null || board.length == <span class="hljs-number">0</span> || board[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        m = board.length;        n = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">boolean</span>[][] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; m; r++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n; c++) &#123;                <span class="hljs-keyword">if</span> (backtracking(<span class="hljs-number">0</span>, r, c, hasVisited, board, <span class="hljs-keyword">word</span>)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curLen, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">boolean</span>[][] visited, <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span>)</span> </span>&#123;        <span class="hljs-keyword">if</span> (curLen == <span class="hljs-keyword">word</span>.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> || r &gt;= m || c &lt; <span class="hljs-number">0</span> || c &gt;= n || board[r][c] != <span class="hljs-keyword">word</span>.charAt(curLen) || visited[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        visited[r][c] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] d : direction) &#123;            <span class="hljs-keyword">if</span> (backtracking(curLen + <span class="hljs-number">1</span>, r + d[<span class="hljs-number">0</span>], c + d[<span class="hljs-number">1</span>], visited, board, <span class="hljs-keyword">word</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        visited[r][c] = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><h2 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a>91. 解码方法</h2><pre><code class="hljs clean">一条包含字母 A-Z 的消息通过以下方式进行了编码：<span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">1</span><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">2</span>...<span class="hljs-string">&#x27;Z&#x27;</span> -&gt; <span class="hljs-number">26</span>输入: <span class="hljs-string">&quot;12&quot;</span>输出: <span class="hljs-number">2</span>解释: 它可以解码为 <span class="hljs-string">&quot;AB&quot;</span>（<span class="hljs-number">1</span> <span class="hljs-number">2</span>）或者 <span class="hljs-string">&quot;L&quot;</span>（<span class="hljs-number">12</span>）。输入: <span class="hljs-string">&quot;226&quot;</span>输出: <span class="hljs-number">3</span>解释: 它可以解码为 <span class="hljs-string">&quot;BZ&quot;</span> (<span class="hljs-number">2</span> <span class="hljs-number">26</span>), <span class="hljs-string">&quot;VF&quot;</span> (<span class="hljs-number">22</span> <span class="hljs-number">6</span>), 或者 <span class="hljs-string">&quot;BBF&quot;</span> (<span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span>) 。</code></pre><p>dp</p><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> numDecodings(String s) &#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-type">int</span> n = s.length();        <span class="hljs-type">int</span>[] dp = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;            <span class="hljs-type">int</span> one = <span class="hljs-type">Integer</span>.valueOf(s.substring(i - <span class="hljs-number">1</span>, i));            <span class="hljs-keyword">if</span> (one != <span class="hljs-number">0</span>) &#123;                dp[i] += dp[i - <span class="hljs-number">1</span>];            &#125;            <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-type">int</span> two = <span class="hljs-type">Integer</span>.valueOf(s.substring(i - <span class="hljs-number">2</span>, i));            <span class="hljs-keyword">if</span> (two &lt;= <span class="hljs-number">26</span>) &#123;                dp[i] += dp[i - <span class="hljs-number">2</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><pre><code class="hljs reasonml">给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过<span class="hljs-number">1</span>。    <span class="hljs-number">3</span><span class="hljs-operator">   / </span>\  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><span class="hljs-operator">    /  </span>\   <span class="hljs-number">15</span>   <span class="hljs-number">7</span>   <span class="hljs-literal">true</span>lass Solution &#123;    <span class="hljs-keyword">private</span> boolean res = <span class="hljs-literal">true</span>;    public boolean is<span class="hljs-constructor">Balanced(TreeNode <span class="hljs-params">root</span>)</span> &#123;        <span class="hljs-constructor">Depth(<span class="hljs-params">root</span>)</span>;        return res;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> Depth (TreeNode root) &#123;        <span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>null) return <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> l = <span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;        <span class="hljs-built_in">int</span> r = <span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(l - r) &gt; <span class="hljs-number">1</span>) res = <span class="hljs-literal">false</span>;;        return <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(l , r);    &#125;&#125;</code></pre><h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h2><pre><code class="hljs typescript">给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。输入: s = <span class="hljs-string">&quot;leetcode&quot;</span>, wordDict = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]输出: <span class="hljs-literal">true</span>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;leet code&quot;</span>。输入: s = <span class="hljs-string">&quot;applepenapple&quot;</span>, wordDict = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pen&quot;</span>]输出: <span class="hljs-literal">true</span>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;applepenapple&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;apple pen apple&quot;</span>。     注意你可以重复使用字典中的单词。来输入: s = <span class="hljs-string">&quot;catsandog&quot;</span>, wordDict = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]输出: <span class="hljs-literal">false</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">wordBreak</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s, List&lt;<span class="hljs-built_in">String</span>&gt; wordDict</span>)</span> &#123;        int n = s.length();        <span class="hljs-built_in">boolean</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">boolean</span>[n + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> word: wordDict) &#123;                <span class="hljs-comment">// 对物品的迭代应该放在最里层</span>                int len = word.length();                <span class="hljs-keyword">if</span> (len &lt;= i &amp;&amp; word.equals(s.substring(i - len , i))) &#123;                    dp[i] = dp[i] || dp[i - len];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre><h2 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h2><pre><code class="hljs arduino">给定一个整数数组，判断是否存在重复元素。如果任意一值在数组中出现至少两次，函数返回 <span class="hljs-literal">true</span> 。如果数组中每个元素都不相同，则返回 <span class="hljs-literal">false</span> 。输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]输出: <span class="hljs-literal">true</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        HashSet&lt;Integer&gt; <span class="hljs-built_in">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">set</span>.add(num)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><h2 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h2><pre><code class="hljs xquery">输入:<span class="hljs-built_in"> head</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], <span class="hljs-type">node</span> = <span class="hljs-number">5</span>输出: [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>]解释: 给定你链表中值为 <span class="hljs-number">5</span> 的第二个节点，那么在调用了你的函数之后，该链表应变为 <span class="hljs-number">4</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">9</span>.class Solution &#123;    public void deleteNode(ListNode <span class="hljs-type">node</span>) &#123;        <span class="hljs-type">node</span>.val = <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span>.val;        <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre><h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h2><pre><code class="hljs excel">给你一个长度为 <span class="hljs-built_in">n</span> 的整数数组 nums，其中 <span class="hljs-built_in">n</span> &gt; <span class="hljs-number">1</span>，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。输入<span class="hljs-symbol">:</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]输出<span class="hljs-symbol">:</span> [<span class="hljs-number">24</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>]class Solution &#123;    public <span class="hljs-built_in">int</span>[] productExceptSelf(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = nums.length;        <span class="hljs-built_in">int</span>[] products = new <span class="hljs-built_in">int</span>[<span class="hljs-built_in">n</span>];        Arrays.fill(products, <span class="hljs-number">1</span>);        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">1</span>;        for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">n</span>; i++) &#123;            <span class="hljs-built_in">left</span> *= nums[i - <span class="hljs-number">1</span>];            products[i] *= <span class="hljs-built_in">left</span>;        &#125;        <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = <span class="hljs-number">1</span>;        for (<span class="hljs-built_in">int</span> i = <span class="hljs-built_in">n</span> - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-built_in">right</span> *= nums[i + <span class="hljs-number">1</span>];            products[i] *= <span class="hljs-built_in">right</span>;        &#125;        return products;    &#125;&#125;</code></pre><h2 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p><pre><code class="hljs dart">输入: nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], nums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]输出: [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]输入: nums1 = [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>], nums2 = [<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>]输出: [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    public <span class="hljs-built_in">int</span>[] intersect(<span class="hljs-built_in">int</span>[] nums1, <span class="hljs-built_in">int</span>[] nums2) &#123;        ArrayList&lt;Integer&gt; list1 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums1) &#123;            list1.add(<span class="hljs-built_in">num</span>);        &#125;        ArrayList&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span> : nums2) &#123;            <span class="hljs-keyword">if</span> (list1.contains(<span class="hljs-built_in">num</span>)) &#123;                list2.add(<span class="hljs-built_in">num</span>);                list1.remove(<span class="hljs-built_in">num</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> list2.stream().mapToInt(Integer::valueOf).toArray();    &#125;&#125;</code></pre><h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a>461. 汉明距离</h2><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 x 和 y，计算它们之间的汉明距离。</p><pre><code class="hljs angelscript">输入: x = <span class="hljs-number">1</span>, y = <span class="hljs-number">4</span>输出: <span class="hljs-number">2</span>解释:<span class="hljs-number">1</span>   (<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>)<span class="hljs-number">4</span>   (<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>)       ↑   ↑上面的箭头指出了对应二进制位不同的位置。<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> hammingDistance(<span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y) &#123;        <span class="hljs-built_in">int</span> z = x ^ y;        <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (z != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> ((z &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) cnt++;            z = z &gt;&gt; <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> cnt;    &#125;&#125;</code></pre><h2 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a>572. 另一个树的子树</h2><pre><code class="hljs reasonml">给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。     <span class="hljs-number">3</span><span class="hljs-operator">    / </span>\   <span class="hljs-number">4</span>   <span class="hljs-number">5</span><span class="hljs-operator">  / </span>\ <span class="hljs-number">1</span>   <span class="hljs-number">2</span>    <span class="hljs-number">4</span> <span class="hljs-operator">  / </span>\ <span class="hljs-number">1</span>   <span class="hljs-number">2</span> <span class="hljs-keyword">class</span> Solution &#123;    public boolean is<span class="hljs-constructor">Subtree(TreeNode <span class="hljs-params">s</span>, TreeNode <span class="hljs-params">t</span>)</span> &#123;        <span class="hljs-keyword">if</span> (s<span class="hljs-operator"> == </span>null) return <span class="hljs-literal">false</span>;        return is<span class="hljs-constructor">SubtreeWithRoot(<span class="hljs-params">s</span>, <span class="hljs-params">t</span>)</span><span class="hljs-operator"> || </span>is<span class="hljs-constructor">Subtree(<span class="hljs-params">s</span>.<span class="hljs-params">left</span>, <span class="hljs-params">t</span>)</span><span class="hljs-operator"> || </span>is<span class="hljs-constructor">Subtree(<span class="hljs-params">s</span>.<span class="hljs-params">right</span>, <span class="hljs-params">t</span>)</span>;    &#125;    <span class="hljs-keyword">private</span> boolean is<span class="hljs-constructor">SubtreeWithRoot(TreeNode <span class="hljs-params">s</span>, TreeNode <span class="hljs-params">t</span>)</span> &#123;        <span class="hljs-keyword">if</span> (t<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>s<span class="hljs-operator"> == </span>null) return <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (t<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>s<span class="hljs-operator"> == </span>null) return <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (t.<span class="hljs-keyword">val</span> != s.<span class="hljs-keyword">val</span>) return <span class="hljs-literal">false</span>;        return is<span class="hljs-constructor">SubtreeWithRoot(<span class="hljs-params">s</span>.<span class="hljs-params">left</span>, <span class="hljs-params">t</span>.<span class="hljs-params">left</span>)</span><span class="hljs-operator"> &amp;&amp; </span>is<span class="hljs-constructor">SubtreeWithRoot(<span class="hljs-params">s</span>.<span class="hljs-params">right</span>, <span class="hljs-params">t</span>.<span class="hljs-params">right</span>)</span>;    &#125;&#125;</code></pre><h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><blockquote><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：<span class="hljs-string">&quot;abc&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：3</span><span class="hljs-meta">&gt;</span><span class="bash">解释：三个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span></span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：<span class="hljs-string">&quot;aaa&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：6</span><span class="hljs-meta">&gt;</span><span class="bash">解释：6个回文子串: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span></span></code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;    public <span class="hljs-built_in">int</span> count<span class="hljs-constructor">Substrings(String <span class="hljs-params">s</span>)</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length<span class="hljs-literal">()</span>; i++) &#123;            extend<span class="hljs-constructor">Substrings(<span class="hljs-params">s</span>, <span class="hljs-params">i</span>, <span class="hljs-params">i</span>)</span>; <span class="hljs-comment">// 奇数长度</span>            extend<span class="hljs-constructor">Substrings(<span class="hljs-params">s</span>, <span class="hljs-params">i</span>, <span class="hljs-params">i</span> + 1)</span>; <span class="hljs-comment">// 偶数长度</span>        &#125;        return cnt;    &#125;    <span class="hljs-keyword">private</span> void extend<span class="hljs-constructor">Substrings(String <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">start</span>, <span class="hljs-params">int</span> <span class="hljs-params">end</span>)</span> &#123;        <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-keyword">end</span> &lt; s.length<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">start</span>)</span><span class="hljs-operator"> == </span>s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">end</span>)</span>) &#123;            start--;            <span class="hljs-keyword">end</span>++;            cnt++;        &#125;    &#125;&#125;</code></pre><h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="680. 验证回文字符串 Ⅱ"></a>680. 验证回文字符串 Ⅱ</h2><p> 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><pre><code class="hljs reasonml">输入: <span class="hljs-string">&quot;aba&quot;</span>输出: True输入: <span class="hljs-string">&quot;abca&quot;</span>输出: True解释: 你可以删除c字符。<span class="hljs-keyword">class</span> Solution &#123;    public boolean valid<span class="hljs-constructor">Palindrome(String <span class="hljs-params">s</span>)</span> &#123;        <span class="hljs-comment">// 普通判断回文串用前后双指针即可，但是，难点在于如果去删除一个元素后的字符串是不是回文串</span>        <span class="hljs-comment">// 如果前后指针的元素不相等，此时子串的范围（i+1，j）或（j-1）的俩子串只要任意一个是，则结果是</span>        <span class="hljs-comment">// 否则，则不是</span>        <span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span>, j = s.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span> != s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>) &#123;                return is<span class="hljs-constructor">Vaild(<span class="hljs-params">s</span>, <span class="hljs-params">i</span>+1, <span class="hljs-params">j</span>)</span><span class="hljs-operator"> || </span>is<span class="hljs-constructor">Vaild(<span class="hljs-params">s</span>, <span class="hljs-params">i</span>, <span class="hljs-params">j</span>-1)</span>;            &#125;            i++;            j--;        &#125;        return <span class="hljs-literal">true</span>;    &#125;    public boolean is<span class="hljs-constructor">Vaild(String <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">i</span>, <span class="hljs-params">int</span> <span class="hljs-params">j</span>)</span> &#123;        <span class="hljs-keyword">while</span>(i &lt; j) &#123;            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span> != s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>) &#123;                return <span class="hljs-literal">false</span>;            &#125;            i++;            j--;        &#125;        return <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a>146. LRU缓存机制</h2><blockquote><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><pre><code class="hljs haxe">&gt;输入&gt;[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]&gt;[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]&gt;输出&gt;[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&gt;解释&gt;LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);&gt;lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span>&gt;lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span>&gt;lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span>&gt;lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span>&gt;lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span>&gt;lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span>&gt;lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span>&gt;lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span>&gt;lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cap = capacity;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.containsKey(key)) &#123;            <span class="hljs-keyword">int</span> value = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(key);            <span class="hljs-comment">// 查一次，就将查到到仍在队尾</span>            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">remove</span>(key);            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(key,value);            <span class="hljs-keyword">return</span> value;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.containsKey(key)) &#123;            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">remove</span>(key);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.<span class="hljs-built_in">size</span>() == cap) &#123;            <span class="hljs-comment">// 满了</span>            Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; iterator = <span class="hljs-built_in">map</span>.entrySet().iterator();            iterator.next();            iterator.<span class="hljs-built_in">remove</span>();        &#125;        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(key, value);    &#125;&#125;</code></pre><h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h2><blockquote><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><pre><code class="hljs inform7">&gt;输入: <span class="hljs-comment">[1,2,2]</span>&gt;输出:&gt;<span class="hljs-comment">[</span><span class="hljs-comment"> <span class="hljs-comment">[2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[1]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[1,2,2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[2,2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[1,2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[]</span></span><span class="hljs-comment">&gt;]</span></code></pre></blockquote><pre><code class="hljs arduino">给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]输出:[  [<span class="hljs-number">2</span>],  [<span class="hljs-number">1</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  []]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        Arrays.sort(nums);        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;Integer&gt; tempSubset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">boolean</span>[] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">size</span> &lt;= nums.length; <span class="hljs-built_in">size</span>++) &#123;            backtracking(<span class="hljs-number">0</span>, tempSubset, subsets, hasVisited, <span class="hljs-built_in">size</span>, nums); <span class="hljs-comment">// 不同的子集大小</span>        &#125;        <span class="hljs-keyword">return</span> subsets;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets, <span class="hljs-keyword">boolean</span>[] hasVisited,</span></span><span class="hljs-function"><span class="hljs-params">                            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tempSubset.<span class="hljs-built_in">size</span>() == <span class="hljs-built_in">size</span>) &#123;            subsets.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tempSubset));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !hasVisited[i - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            tempSubset.add(nums[i]);            hasVisited[i] = <span class="hljs-literal">true</span>;            backtracking(i + <span class="hljs-number">1</span>, tempSubset, subsets, hasVisited, <span class="hljs-built_in">size</span>, nums);            hasVisited[i] = <span class="hljs-literal">false</span>;            tempSubset.<span class="hljs-built_in">remove</span>(tempSubset.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h2><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><pre><code class="hljs sas"><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O O <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> O <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span> <span class="hljs-meta">X</span><span class="hljs-meta">X</span> O <span class="hljs-meta">X</span> <span class="hljs-meta">X</span>class Solution &#123;    private int[][] direction = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;;    private int m, n;    public void solve(char[][] board) &#123;        <span class="hljs-meta">if</span> (board == <span class="hljs-meta">null</span> || board.<span class="hljs-meta">length</span> == 0) <span class="hljs-meta">return</span>;        m = board.<span class="hljs-meta">length</span>;        n = board[0].<span class="hljs-meta">length</span>;        for (int i = 0; i &lt; m; i++) &#123;            dfs(board, i, 0);            dfs(board, i, n - 1);        &#125;        for (int i = 0; i &lt; n; i++) &#123;            dfs(board, 0, i);            dfs(board, m - 1, i);        &#125;        for (int i = 0; i &lt; m; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                <span class="hljs-meta">if</span> (board[i][j] == <span class="hljs-string">&#x27;T&#x27;</span>) &#123;                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;                &#125; <span class="hljs-meta">else</span> <span class="hljs-meta">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;                &#125;            &#125;        &#125;    &#125;    private void dfs(char[][] board, int r, int c) &#123;        <span class="hljs-meta">if</span>(r&lt;0 || r &gt;= m || c &lt; 0 || c &gt;= n || board[r][c] != <span class="hljs-string">&#x27;O&#x27;</span>) &#123;            <span class="hljs-meta">return</span>;        &#125;        board[r][c] = <span class="hljs-string">&#x27;T&#x27;</span>;        for (int[] d : direction) &#123;            dfs(board, r + d[0], c + d[1]);        &#125;    &#125;&#125;</code></pre><h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h2><pre><code class="hljs angelscript">假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>] 可能变为 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] )。请找出其中最小的元素。你可以假设数组中不存在重复元素。输入: [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">1</span>输入: [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">0</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> findMin(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> l = <span class="hljs-number">0</span>, h = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (l &lt; h) &#123;            <span class="hljs-built_in">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (nums[m] &lt;= nums[h]) &#123;                h = m;            &#125; <span class="hljs-keyword">else</span> &#123;                l = m + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[l];    &#125;&#125;</code></pre><h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><pre><code class="hljs cpp">输入：<span class="hljs-number">00000000000000000000000000001011</span>输出：<span class="hljs-number">3</span>解释：输入的二进制串 <span class="hljs-number">00000000000000000000000000001011</span> 中，共有三位为 <span class="hljs-string">&#x27;1&#x27;</span>。输入：<span class="hljs-number">00000000000000000000000010000000</span>输出：<span class="hljs-number">1</span>解释：输入的二进制串 <span class="hljs-number">00000000000000000000000010000000</span> 中，共有一位为 <span class="hljs-string">&#x27;1&#x27;</span>。<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-comment">// you need to treat n as an unsigned value</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>) &#123;            n &amp;= n - <span class="hljs-number">1</span>;            ans++;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre><h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a>213. 打家劫舍 II</h2><pre><code class="hljs java">你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。输入: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">3</span>解释: 你不能先偷窃 <span class="hljs-number">1</span> 号房屋（金额 = <span class="hljs-number">2</span>），然后偷窃 <span class="hljs-number">3</span> 号房屋（金额 = <span class="hljs-number">2</span>）, 因为他们是相邻的。输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]输出: <span class="hljs-number">4</span>解释: 你可以先偷窃 <span class="hljs-number">1</span> 号房屋（金额 = <span class="hljs-number">1</span>），然后偷窃 <span class="hljs-number">3</span> 号房屋（金额 = <span class="hljs-number">3</span>）。     偷窃到的最高金额 = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">4</span> 。<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">return</span> Math.max(rob(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">2</span>), rob(nums, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last)</span> </span>&#123;        <span class="hljs-keyword">int</span> pre2 = <span class="hljs-number">0</span>, pre1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = first; i &lt;= last; i++) &#123;            <span class="hljs-keyword">int</span> cur = Math.max(pre1, pre2 + nums[i]);            pre2 = pre1;            pre1 = cur;        &#125;        <span class="hljs-keyword">return</span> pre1;    &#125;&#125;</code></pre><h2 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a>219. 存在重复元素 II</h2><pre><code class="hljs csharp">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span>输出: <span class="hljs-literal">true</span>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span>输出: <span class="hljs-literal">true</span><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">containsNearbyDuplicate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k</span>)</span> &#123;        HashSet&lt;Integer&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">set</span>.contains(nums[i])) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;             <span class="hljs-keyword">set</span>.<span class="hljs-keyword">add</span>(nums[i]);            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">set</span>.size() &gt; k) &#123;                <span class="hljs-keyword">set</span>.<span class="hljs-keyword">remove</span>(nums[i - k]);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h2><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p>说明： 你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><pre><code class="hljs axapta">输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span>   <span class="hljs-number">3</span>  / \ <span class="hljs-number">1</span>   <span class="hljs-number">4</span>  \   <span class="hljs-number">2</span>输出: <span class="hljs-number">1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> kthSmallest(TreeNode root, <span class="hljs-built_in">int</span> k) &#123;        <span class="hljs-built_in">int</span> leftCnt = <span class="hljs-keyword">count</span>(root.left);        <span class="hljs-keyword">if</span> (leftCnt == k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root.val;        <span class="hljs-keyword">if</span> (leftCnt &gt; k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> kthSmallest(root.left, k);        <span class="hljs-keyword">return</span> kthSmallest(root.right, k - leftCnt - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> (TreeNode node) &#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-keyword">count</span>(node.left) + <span class="hljs-keyword">count</span>(node.right);    &#125;&#125;</code></pre><h2 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a>231. 2的幂</h2><blockquote><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方.</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: 1</span><span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">true</span></span><span class="hljs-meta">&gt;</span><span class="bash">解释: 20 = 1</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: 16</span><span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">true</span></span><span class="hljs-meta">&gt;</span><span class="bash">解释: 24 = 16</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: 218</span><span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">false</span></span></code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public boolean is<span class="hljs-constructor">PowerOfTwo(<span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span> &#123;        return n &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>bit<span class="hljs-constructor">Count(<span class="hljs-params">n</span>)</span><span class="hljs-operator"> == </span><span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h2><blockquote><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false</p><p>说明：</p><p>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：</span><span class="hljs-meta">&gt;</span><span class="bash">[<span class="hljs-string">&quot;MyQueue&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;peek&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]</span><span class="hljs-meta">&gt;</span><span class="bash">[[], [1], [2], [], [], []]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：</span><span class="hljs-meta">&gt;</span><span class="bash">[null, null, null, 1, 1, <span class="hljs-literal">false</span>]</span><span class="hljs-meta">&gt;</span><span class="bash">解释：</span><span class="hljs-meta">&gt;</span><span class="bash">MyQueue myQueue = new MyQueue();</span><span class="hljs-meta">&gt;</span><span class="bash">myQueue.push(1); // queue is: [1]</span><span class="hljs-meta">&gt;</span><span class="bash">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><span class="hljs-meta">&gt;</span><span class="bash">myQueue.peek(); // <span class="hljs-built_in">return</span> 1</span><span class="hljs-meta">&gt;</span><span class="bash">myQueue.pop(); // <span class="hljs-built_in">return</span> 1, queue is [2]</span><span class="hljs-meta">&gt;</span><span class="bash">myQueue.empty(); // <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span></span></code></pre></blockquote><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; <span class="hljs-keyword">in</span>;    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; <span class="hljs-keyword">out</span>;    <span class="hljs-comment">/** Initialize your data structure here. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">out</span> = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    &#125;        <span class="hljs-comment">/** Push element x to the back of queue. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;        <span class="hljs-keyword">in</span>.push(x);    &#125;        <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;        in2Out();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span>.pop();    &#125;        <span class="hljs-comment">/** Get the front element. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;        in2Out();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span>.peek();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in2Out</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">out</span>.isEmpty()) &#123;            <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">in</span>.isEmpty()) &#123;                <span class="hljs-keyword">out</span>.push(<span class="hljs-keyword">in</span>.pop());            &#125;        &#125;    &#125;        <span class="hljs-comment">/** Returns whether the queue is empty. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> boolean <span class="hljs-title">empty</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">in</span>.isEmpty() &amp;&amp; <span class="hljs-keyword">out</span>.isEmpty();    &#125;&#125;</code></pre><h2 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a>268. 缺失数字</h2><p>给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]输出: <span class="hljs-number">2</span>输入: [<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]输出: <span class="hljs-number">8</span><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> missingNumber(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            ret = ret ^ i ^ nums[i];        &#125;        <span class="hljs-keyword">return</span> ret ^ nums.length;    &#125;&#125;</code></pre><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><pre><code class="hljs stan">输入: n = <span class="hljs-number">12</span>输出: <span class="hljs-number">3</span> 解释: <span class="hljs-number">12</span> = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> + <span class="hljs-number">4.</span>输入: n = <span class="hljs-number">13</span>输出: <span class="hljs-number">2</span>解释: <span class="hljs-number">13</span> = <span class="hljs-number">4</span> + <span class="hljs-number">9.</span>class Solution &#123;    public <span class="hljs-keyword">int</span> numSquares(<span class="hljs-keyword">int</span> n) &#123;        List&lt;Integer&gt; squareList = generateSquareList(n);        <span class="hljs-keyword">int</span>[] dp = new <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            <span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = Integer.MAX_VALUE;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-built_in">square</span> : squareList) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">square</span> &gt; i) <span class="hljs-keyword">break</span>;                <span class="hljs-built_in">min</span> = Math.<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>, dp[i - <span class="hljs-built_in">square</span>] + <span class="hljs-number">1</span>);            &#125;            dp[i] = <span class="hljs-built_in">min</span>;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;    private List&lt;Integer&gt; generateSquareList(<span class="hljs-keyword">int</span> n) &#123;        List&lt;Integer&gt; squareList = new ArrayList&lt;&gt;();        <span class="hljs-keyword">int</span> diff = <span class="hljs-number">3</span>;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">square</span> = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">square</span> &lt;= n) &#123;            squareList.add(<span class="hljs-built_in">square</span>);            <span class="hljs-built_in">square</span> += diff;            diff += <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">return</span> squareList;    &#125;&#125;</code></pre><h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h2><pre><code class="hljs monkey">给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(<span class="hljs-number">1</span>)，时间复杂度应为 O(nodes)，nodes 为节点总数。输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-literal">NULL</span>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-literal">NULL</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">public</span> ListNode oddEvenList(ListNode head) &#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;        ListNode odd = head, even = head.<span class="hljs-keyword">next</span>, evenHead = even;        <span class="hljs-keyword">while</span> (even != <span class="hljs-literal">null</span> &amp;&amp; even.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            odd.<span class="hljs-keyword">next</span> = odd.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            odd = odd.<span class="hljs-keyword">next</span>;            even.<span class="hljs-keyword">next</span> = even.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            even = even.<span class="hljs-keyword">next</span>;        &#125;        odd.<span class="hljs-keyword">next</span> = evenHead;        <span class="hljs-keyword">return</span> head;    &#125;&#125;</code></pre><h2 id="378-有序矩阵中第K小的元素"><a href="#378-有序矩阵中第K小的元素" class="headerlink" title="378. 有序矩阵中第K小的元素"></a>378. 有序矩阵中第K小的元素</h2><pre><code class="hljs angelscript">给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。matrix = [<span class="hljs-string">   [ 1,  5,  9]</span>,<span class="hljs-string">   [10, 11, 13]</span>,<span class="hljs-string">   [12, 13, 15]</span>],k = <span class="hljs-number">8</span>,返回 <span class="hljs-number">13</span>。<span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> kthSmallest(<span class="hljs-built_in">int</span>[][] matrix, <span class="hljs-built_in">int</span> k) &#123;        <span class="hljs-built_in">int</span> m = matrix.length, n = matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-built_in">int</span> lo = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], hi = matrix[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];        <span class="hljs-keyword">while</span> (lo &lt;= hi) &#123;            <span class="hljs-built_in">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;            <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++) &#123;                    cnt++;                &#125;            &#125;            <span class="hljs-keyword">if</span> (cnt &lt; k) lo = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> hi = mid - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> lo;    &#125;&#125;</code></pre><h2 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h2><blockquote><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">s = <span class="hljs-string">&quot;leetcode&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">返回 0</span><span class="hljs-meta">&gt;</span><span class="bash">s = <span class="hljs-string">&quot;loveleetcode&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">返回 2</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;        HashMap&lt;Character, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray())&#123;            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(c, <span class="hljs-built_in">map</span>.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(s.charAt(i)) == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;&#125;</code></pre><h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h2><blockquote><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public String add<span class="hljs-constructor">Strings(String <span class="hljs-params">num1</span>, String <span class="hljs-params">num2</span>)</span> &#123;        StringBuilder str = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;        <span class="hljs-built_in">int</span> carry = <span class="hljs-number">0</span>, i = num1.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>, j = num2.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (carry<span class="hljs-operator"> == </span><span class="hljs-number">1</span><span class="hljs-operator"> || </span>i &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> || </span>j &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-built_in">int</span> x = i &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : num1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>--)</span> - <span class="hljs-character">&#x27;0&#x27;</span>;            <span class="hljs-built_in">int</span> y = j &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : num2.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>--)</span> - <span class="hljs-character">&#x27;0&#x27;</span>;            str.append((x + y + carry) % <span class="hljs-number">10</span>);            carry = (x + y + carry)<span class="hljs-operator"> / </span><span class="hljs-number">10</span>;         &#125;        return str.reverse<span class="hljs-literal">()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;    &#125;&#125;</code></pre><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h2><blockquote><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><pre><code class="hljs tap">&gt;输入: Tree<span class="hljs-number"> 1 </span>                    Tree<span class="hljs-number"> 2 </span>                         <span class="hljs-number"> 1 </span>                       <span class="hljs-number"> 2 </span>                                    / \                       / \                                  <span class="hljs-number"> 3 </span> <span class="hljs-number"> 2 </span>                   <span class="hljs-number"> 1 </span> <span class="hljs-number"> 3 </span>                             /                           \   \                          <span class="hljs-number"> 5 </span>                           <span class="hljs-number"> 4 </span> <span class="hljs-number"> 7 </span>                 &gt;输出: &gt;合并后的树:     3    / \  <span class="hljs-number"> 4 </span>  5  / \   \ <span class="hljs-number"> 5 </span> <span class="hljs-number"> 4 </span>  7</code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public TreeNode merge<span class="hljs-constructor">Trees(TreeNode <span class="hljs-params">t1</span>, TreeNode <span class="hljs-params">t2</span>)</span> &#123;        <span class="hljs-keyword">if</span> (t1<span class="hljs-operator"> == </span>null<span class="hljs-operator"> &amp;&amp; </span>t2<span class="hljs-operator"> == </span>null) return null;        <span class="hljs-keyword">if</span> (t1<span class="hljs-operator"> == </span>null) return t2;        <span class="hljs-keyword">if</span> (t2<span class="hljs-operator"> == </span>null) return t1;        TreeNode root = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">t1</span>.<span class="hljs-params">val</span> + <span class="hljs-params">t2</span>.<span class="hljs-params">val</span>)</span>;        root.left = merge<span class="hljs-constructor">Trees(<span class="hljs-params">t1</span>.<span class="hljs-params">left</span>, <span class="hljs-params">t2</span>.<span class="hljs-params">left</span>)</span>;        root.right = merge<span class="hljs-constructor">Trees(<span class="hljs-params">t1</span>.<span class="hljs-params">right</span>, <span class="hljs-params">t2</span>.<span class="hljs-params">right</span>)</span>;        return root;     &#125;&#125;</code></pre><h2 id="86-分隔链表-367"><a href="#86-分隔链表-367" class="headerlink" title="86. 分隔链表(367)"></a>86. 分隔链表(367)</h2><blockquote><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><pre><code class="hljs accesslog">&gt;输入：head = <span class="hljs-string">[1,4,3,2,5,2]</span>, x = <span class="hljs-number">3</span>&gt;输出：<span class="hljs-string">[1,2,2,4,3,5]</span></code></pre><pre><code class="hljs inform7">&gt;输入：head = <span class="hljs-comment">[2,1]</span>, x = 2&gt;输出：<span class="hljs-comment">[1,2]</span></code></pre></blockquote><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode partition(ListNode head, <span class="hljs-built_in">int</span> x) &#123;        ListNode dummy1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode dummy2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode node1 = dummy1, node2 = dummy2;        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">if</span> (head.val &lt; x)&#123;                node1.<span class="hljs-keyword">next</span> = head;                head = head.<span class="hljs-keyword">next</span>;                node1 = node1.<span class="hljs-keyword">next</span>;                node1.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                node2.<span class="hljs-keyword">next</span> = head;                head = head.<span class="hljs-keyword">next</span>;                node2 = node2.<span class="hljs-keyword">next</span>;                node2.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;            &#125;        &#125;        node1.<span class="hljs-keyword">next</span> = dummy2.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">return</span> dummy1.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS相关算法题</title>
    <link href="/2021/03/20/DFS%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/03/20/DFS%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-1、矩阵中的路径"><a href="#1-1、矩阵中的路径" class="headerlink" title="1.1、矩阵中的路径"></a>1.1、<a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=4&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">矩阵中的路径</a></h3><blockquote><p>设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p><pre><code class="hljs prolog">&gt;输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span>&gt;输出：true</code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">board</span> = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]], <span class="hljs-attr">word</span> = <span class="hljs-string">&quot;abcd&quot;</span>&gt;输出：<span class="hljs-literal">false</span></code></pre></blockquote><pre><code class="hljs axapta"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[][] <span class="hljs-keyword">next</span> = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> rows;<span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> cols;<span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> hasPath(<span class="hljs-built_in">char</span>[] array, <span class="hljs-built_in">int</span> rows, <span class="hljs-built_in">int</span> cols, <span class="hljs-built_in">char</span>[] <span class="hljs-built_in">str</span>) &#123;    <span class="hljs-keyword">if</span> (rows == <span class="hljs-number">0</span> || cols == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">this</span>.rows = rows;    <span class="hljs-keyword">this</span>.cols = cols;    <span class="hljs-built_in">boolean</span>[][] marked = <span class="hljs-keyword">new</span> <span class="hljs-built_in">boolean</span>[rows][cols];    <span class="hljs-built_in">char</span>[][] matrix = buildMatrix(array);    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++)        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++)            <span class="hljs-keyword">if</span> (backtracking(matrix, <span class="hljs-built_in">str</span>, marked, <span class="hljs-number">0</span>, i, j))                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> backtracking(<span class="hljs-built_in">char</span>[][] matrix, <span class="hljs-built_in">char</span>[] <span class="hljs-built_in">str</span>,                             <span class="hljs-built_in">boolean</span>[][] marked, <span class="hljs-built_in">int</span> pathLen, <span class="hljs-built_in">int</span> r, <span class="hljs-built_in">int</span> c) &#123;     <span class="hljs-comment">// 如果长度满足，则为true：true的条件                           </span>    <span class="hljs-keyword">if</span> (pathLen == <span class="hljs-built_in">str</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 如果任意满足，则false：false的条件</span>    <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> || r &gt;= rows || c &lt; <span class="hljs-number">0</span> || c &gt;= cols            || matrix[r][c] != <span class="hljs-built_in">str</span>[pathLen] || marked[r][c]) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-comment">// 我这个元素只能拿一次，递归的时候，你不能拿了</span>    marked[r][c] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span>[] n : <span class="hljs-keyword">next</span>)        <span class="hljs-keyword">if</span> (backtracking(matrix, <span class="hljs-built_in">str</span>, marked, pathLen + <span class="hljs-number">1</span>, r + n[<span class="hljs-number">0</span>], c + n[<span class="hljs-number">1</span>]))            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 递归结束，该元素为false，意味着，可以拿了，回溯嘛，就像线程切换一样</span>    marked[r][c] = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-built_in">char</span>[][] buildMatrix(<span class="hljs-built_in">char</span>[] array) &#123;    <span class="hljs-built_in">char</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[rows][cols];    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> r = <span class="hljs-number">0</span>, idx = <span class="hljs-number">0</span>; r &lt; rows; r++)        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> c = <span class="hljs-number">0</span>; c &lt; cols; c++)            matrix[r][c] = array[idx++];    <span class="hljs-keyword">return</span> matrix;&#125;</code></pre><h3 id="1-2-单词搜索-420"><a href="#1-2-单词搜索-420" class="headerlink" title="1.2. 单词搜索(420)"></a>1.2. 单词搜索(420)</h3><blockquote><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>board =<br>[<br> [‘A’,’B’,’C’,’E’],<br> [‘S’,’F’,’C’,’S’],<br> [‘A’,’D’,’E’,’E’]<br>]</p><p>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] direction = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span>)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">word</span> == null || <span class="hljs-keyword">word</span>.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (board == null || board.length == <span class="hljs-number">0</span> || board[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        m = board.length;        n = board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">boolean</span>[][] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; m; r++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n; c++) &#123;                <span class="hljs-keyword">if</span> (backtracking(<span class="hljs-number">0</span>, r, c, hasVisited, board, <span class="hljs-keyword">word</span>)) &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> curLen, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">boolean</span>[][] visited, <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> <span class="hljs-keyword">word</span>)</span> </span>&#123;        <span class="hljs-comment">// 符合条件</span>        <span class="hljs-keyword">if</span> (curLen == <span class="hljs-keyword">word</span>.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 不符合条件</span>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> || r &gt;= m || c &lt; <span class="hljs-number">0</span> || c &gt;= n || board[r][c] != <span class="hljs-keyword">word</span>.charAt(curLen) || visited[r][c]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 表面元素已用过</span>        visited[r][c] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] d : direction) &#123;            <span class="hljs-keyword">if</span> (backtracking(curLen + <span class="hljs-number">1</span>, r + d[<span class="hljs-number">0</span>], c + d[<span class="hljs-number">1</span>], visited, board, <span class="hljs-keyword">word</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-comment">// 可以重新使用</span>        visited[r][c] = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><h3 id="2-1、字符串的排列"><a href="#2-1、字符串的排列" class="headerlink" title="2.1、字符串的排列"></a>2.1、<a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=2&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">字符串的排列</a></h3><blockquote><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;abc&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]</span></code></pre></blockquote><pre><code class="hljs processing"><span class="hljs-keyword">private</span> ArrayList&lt;<span class="hljs-keyword">String</span>&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">public</span> ArrayList&lt;<span class="hljs-keyword">String</span>&gt; Permutation(<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">str</span>.length() == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> ret;    <span class="hljs-built_in">char</span>[] chars = <span class="hljs-built_in">str</span>.toCharArray();    <span class="hljs-comment">// 排序，过滤重复</span>    Arrays.<span class="hljs-built_in">sort</span>(chars);    backtracking(chars, <span class="hljs-keyword">new</span> <span class="hljs-built_in">boolean</span>[chars.length], <span class="hljs-keyword">new</span> StringBuilder());    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> backtracking(<span class="hljs-built_in">char</span>[] chars, <span class="hljs-built_in">boolean</span>[] hasUsed, StringBuilder s) &#123;    <span class="hljs-comment">// 满足条件</span>    <span class="hljs-keyword">if</span> (s.length() == chars.length) &#123;        ret.<span class="hljs-built_in">add</span>(s.toString());        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 遍历</span>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;        <span class="hljs-comment">// 我已经拿过了，不能在拿了。</span>        <span class="hljs-keyword">if</span> (hasUsed[i])            <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 避免重复，实际上优化！ 注意后面那个条件，上一个元素没用过</span>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; chars[i] == chars[i - <span class="hljs-number">1</span>] &amp;&amp; !hasUsed[i - <span class="hljs-number">1</span>]) <span class="hljs-comment">/* 保证不重复 */</span>            <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">// 标记只能取一次</span>        hasUsed[i] = <span class="hljs-keyword">true</span>;        s.<span class="hljs-built_in">append</span>(chars[i]);        backtracking(chars, hasUsed, s);        s.deleteCharAt(s.length() - <span class="hljs-number">1</span>);        hasUsed[i] = <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><h3 id="2-2-全排列-985"><a href="#2-2-全排列-985" class="headerlink" title="2.2. 全排列(985)"></a>2.2. 全排列(985)</h3><blockquote><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><pre><code class="hljs inform7">&gt;输入: <span class="hljs-comment">[1,2,3]</span>&gt;输出:&gt;<span class="hljs-comment">[</span><span class="hljs-comment"> <span class="hljs-comment">[1,2,3]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[1,3,2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[2,1,3]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[2,3,1]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[3,1,2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[3,2,1]</span></span><span class="hljs-comment">&gt;]</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">permute</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        List&lt;List&lt;Integer&gt;&gt; permutes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;Integer&gt; permuteList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">boolean</span>[] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];        backtracking(permuteList, permutes, hasVisited, nums);        <span class="hljs-keyword">return</span> permutes;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// 满足条件</span>        <span class="hljs-keyword">if</span> (permuteList.<span class="hljs-built_in">size</span>() == nums.length) &#123;            permutes.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(permuteList)); <span class="hljs-comment">// 重新构造一个List</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 遍历</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; visited.length; i++) &#123;            <span class="hljs-comment">// 已经拿过了，不能再拿了</span>            <span class="hljs-keyword">if</span> (visited[i])                 <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 标记</span>            visited[i] = <span class="hljs-literal">true</span>;            permuteList.add(nums[i]);            backtracking(permuteList, permutes, visited, nums);            <span class="hljs-comment">// 回溯</span>            permuteList.<span class="hljs-built_in">remove</span>(permuteList.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);            visited[i] = <span class="hljs-literal">false</span>;        &#125;            &#125;&#125;</code></pre><h3 id="2-3-全排列-II-429"><a href="#2-3-全排列-II-429" class="headerlink" title="2.3. 全排列 II(429)"></a>2.3. 全排列 II(429)</h3><blockquote><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[1,1,2]</span>&gt;输出：&gt;<span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><span class="hljs-comment"><span class="hljs-comment">[1,2,1]</span>,</span><span class="hljs-comment"><span class="hljs-comment">[2,1,1]</span>]</span></code></pre><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[1,2,3]</span>&gt;输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">permuteUnique</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        List&lt;List&lt;Integer&gt;&gt; permutes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;Integer&gt; permuteList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(nums); <span class="hljs-comment">// 排序，为了避免重复</span>        <span class="hljs-keyword">boolean</span>[] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];        backtracking(permuteList, permutes, hasVisited, nums);        <span class="hljs-keyword">return</span> permutes;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, <span class="hljs-keyword">boolean</span>[] visited, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-comment">// 满足条件</span>        <span class="hljs-keyword">if</span> (permuteList.<span class="hljs-built_in">size</span>() == nums.length) &#123;            permutes.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(permuteList));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 遍历</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; visited.length; i++) &#123;            <span class="hljs-comment">// 避免重复</span>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i <span class="hljs-number">-1</span>] &amp;&amp; !visited[i - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 防止重复</span>            &#125;            <span class="hljs-comment">// 表明已经拿了，退出</span>            <span class="hljs-keyword">if</span> (visited[i])                 <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 标记，只能拿一次</span>            visited[i] = <span class="hljs-literal">true</span>;            permuteList.add(nums[i]);            backtracking(permuteList, permutes, visited, nums);            <span class="hljs-comment">// 回溯</span>            permuteList.<span class="hljs-built_in">remove</span>(permuteList.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);            visited[i] = <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;</code></pre><h3 id="2-4-组合总和-582"><a href="#2-4-组合总和-582" class="headerlink" title="2.4. 组合总和(582)"></a>2.4. 组合总和(582)</h3><blockquote><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><pre><code class="hljs inform7">&gt;输入：candidates = <span class="hljs-comment">[2,3,6,7]</span>, target = 7,&gt;所求解集为：&gt;<span class="hljs-comment">[</span><span class="hljs-comment"> <span class="hljs-comment">[7]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[2,2,3]</span></span><span class="hljs-comment">&gt;]</span></code></pre><pre><code class="hljs inform7">&gt;输入：candidates = <span class="hljs-comment">[2,3,5]</span>, target = 8,&gt;所求解集为：&gt;<span class="hljs-comment">[</span><span class="hljs-comment"> <span class="hljs-comment">[2,2,2,2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[2,3,3]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[3,5]</span></span><span class="hljs-comment">&gt;]</span></code></pre></blockquote><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;        List&lt;List&lt;Integer&gt;&gt; combinations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        backtracking(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(), combinations, <span class="hljs-number">0</span>, <span class="hljs-keyword">target</span>, candidates);        <span class="hljs-keyword">return</span> combinations;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> backtracking(List&lt;Integer&gt; tempCombination, List&lt;List&lt;Integer&gt;&gt; combinations,                            <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] candidates) &#123;        <span class="hljs-comment">// target为0，则满足</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == <span class="hljs-number">0</span>) &#123;            combinations.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tempCombination));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 遍历从start开始</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;            <span class="hljs-comment">// 注意这个骚条件，满足才行</span>            <span class="hljs-keyword">if</span> (candidates[i] &lt;= <span class="hljs-keyword">target</span>) &#123;                tempCombination.add(candidates[i]);                backtracking(tempCombination, combinations, i, <span class="hljs-keyword">target</span> - candidates[i], candidates);                <span class="hljs-comment">// 回溯</span>                tempCombination.remove(tempCombination.size() - <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="2-5-组合总和-II-401"><a href="#2-5-组合总和-II-401" class="headerlink" title="2.5. 组合总和 II(401)"></a>2.5. 组合总和 II(401)</h3><blockquote><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><pre><code class="hljs inform7">&gt;输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8,&gt;所求解集为:&gt;<span class="hljs-comment">[</span><span class="hljs-comment"> <span class="hljs-comment">[1, 7]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[1, 2, 5]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[2, 6]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[1, 1, 6]</span></span><span class="hljs-comment">&gt;]</span></code></pre><pre><code class="hljs inform7">&gt;输入: candidates = <span class="hljs-comment">[2,5,2,1,2]</span>, target = 5,&gt;所求解集为:&gt;<span class="hljs-comment">[</span><span class="hljs-comment"> <span class="hljs-comment">[1,2,2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[5]</span></span><span class="hljs-comment">&gt;]</span></code></pre></blockquote><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>) &#123;        List&lt;List&lt;Integer&gt;&gt; combinations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        Arrays.sort(candidates); <span class="hljs-comment">// 为了避免重复</span>        backtracking(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(), combinations, <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[candidates.length], <span class="hljs-number">0</span>, <span class="hljs-keyword">target</span>, candidates);        <span class="hljs-keyword">return</span> combinations;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> backtracking(List&lt;Integer&gt; tempCombination, List&lt;List&lt;Integer&gt;&gt; combinations,                            <span class="hljs-keyword">boolean</span>[] hasVisited, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] candidates) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == <span class="hljs-number">0</span>) &#123;            combinations.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tempCombination));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;            <span class="hljs-keyword">if</span>(hasVisited[i])                <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 一样的道理</span>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="hljs-number">1</span>] &amp;&amp; !hasVisited[i - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (candidates[i] &lt;= <span class="hljs-keyword">target</span>) &#123;                tempCombination.add(candidates[i]);                <span class="hljs-comment">// 只能拿一次</span>                hasVisited[i] = <span class="hljs-keyword">true</span>;                backtracking(tempCombination, combinations, hasVisited, i, <span class="hljs-keyword">target</span> - candidates[i], candidates);                hasVisited[i] = <span class="hljs-keyword">false</span>;                tempCombination.remove(tempCombination.size() - <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="3-1-子集-633"><a href="#3-1-子集-633" class="headerlink" title="3.1. 子集(633)"></a>3.1. 子集(633)</h3><blockquote><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[1,2,3]</span>&gt;输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span></code></pre><pre><code class="hljs lua">&gt;输入：nums = [<span class="hljs-number">0</span>]&gt;输出：<span class="hljs-string">[[],[0]]</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;Integer&gt; tempSubset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">size</span> &lt;= nums.length; <span class="hljs-built_in">size</span>++) &#123;            backtracking(<span class="hljs-number">0</span>, tempSubset, subsets, <span class="hljs-built_in">size</span>, nums); <span class="hljs-comment">// 不同的子集大小</span>        &#125;        <span class="hljs-keyword">return</span> subsets;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets,</span></span><span class="hljs-function"><span class="hljs-params">                            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tempSubset.<span class="hljs-built_in">size</span>() == <span class="hljs-built_in">size</span>) &#123;            subsets.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tempSubset));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length; i++) &#123;            tempSubset.add(nums[i]);            backtracking(i + <span class="hljs-number">1</span>, tempSubset, subsets, <span class="hljs-built_in">size</span>, nums);            tempSubset.<span class="hljs-built_in">remove</span>(tempSubset.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h3 id="3-2-子集-II-304"><a href="#3-2-子集-II-304" class="headerlink" title="3.2. 子集 II(304)"></a>3.2. 子集 II(304)</h3><blockquote><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p><pre><code class="hljs inform7">&gt;输入: <span class="hljs-comment">[1,2,2]</span>&gt;输出:&gt;<span class="hljs-comment">[</span><span class="hljs-comment"> <span class="hljs-comment">[2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[1]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[1,2,2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[2,2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[1,2]</span>,</span><span class="hljs-comment"> <span class="hljs-comment">[]</span></span><span class="hljs-comment">&gt;]</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        Arrays.sort(nums); <span class="hljs-comment">// 注意</span>        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        List&lt;Integer&gt; tempSubset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">boolean</span>[] hasVisited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">size</span> &lt;= nums.length; <span class="hljs-built_in">size</span>++) &#123;            backtracking(<span class="hljs-number">0</span>, tempSubset, subsets, hasVisited, <span class="hljs-built_in">size</span>, nums); <span class="hljs-comment">// 不同的子集大小</span>        &#125;        <span class="hljs-keyword">return</span> subsets;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets, <span class="hljs-keyword">boolean</span>[] hasVisited,</span></span><span class="hljs-function"><span class="hljs-params">                            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (tempSubset.<span class="hljs-built_in">size</span>() == <span class="hljs-built_in">size</span>) &#123;            subsets.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tempSubset));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 注意</span>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !hasVisited[i - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            tempSubset.add(nums[i]);            hasVisited[i] = <span class="hljs-literal">true</span>;            backtracking(i + <span class="hljs-number">1</span>, tempSubset, subsets, hasVisited, <span class="hljs-built_in">size</span>, nums);            hasVisited[i] = <span class="hljs-literal">false</span>;            tempSubset.<span class="hljs-built_in">remove</span>(tempSubset.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h3 id="4-1-岛屿数量-853"><a href="#4-1-岛屿数量-853" class="headerlink" title="4.1. 岛屿数量(853)"></a>4.1. 岛屿数量(853)</h3><blockquote><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><pre><code class="hljs prolog">&gt;输入：grid = [ [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]&gt;]&gt;输出：<span class="hljs-number">1</span></code></pre><pre><code class="hljs prolog">&gt;输入：grid = [ [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]&gt;]&gt;输出：<span class="hljs-number">3</span></code></pre></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">// 像这种二维， 定义四个全局方向</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m, n;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] direaction = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">if</span> (grid == <span class="hljs-keyword">null</span> || grid.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        m = grid.length;        n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> islandsNum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-comment">// 不等于0，才能dfs</span>                <span class="hljs-keyword">if</span> (grid[i][j] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;                    dfs(grid, i, j);                    <span class="hljs-comment">// 成功一次，加一次</span>                    islandsNum++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> islandsNum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-comment">// 失败条件</span>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;=n || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 标记，已走过</span>        grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] d : direaction) &#123;            dfs(grid, i + d[<span class="hljs-number">0</span>], j + d[<span class="hljs-number">1</span>]);        &#125;    &#125;&#125;</code></pre><h3 id="4-2-岛屿的最大面积-648"><a href="#4-2-岛屿的最大面积-648" class="headerlink" title="4.2. 岛屿的最大面积(648)"></a>4.2. 岛屿的最大面积(648)</h3><blockquote><p>给定一个包含了一些 <code>0</code> 和 <code>1</code> 的非空二维数组 <code>grid</code> 。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 <code>0</code> 。)</p><pre><code class="hljs dns">&gt;[[<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,1,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,0,0</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">1,0,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,0,0</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">1,1,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0</span>]]</code></pre></blockquote><pre><code class="hljs mel">class Solution &#123;    private <span class="hljs-keyword">int</span> m, n;    private <span class="hljs-keyword">int</span>[][] direaction = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;    public <span class="hljs-keyword">int</span> maxAreaOfIsland(<span class="hljs-keyword">int</span>[][] <span class="hljs-keyword">grid</span>) &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">grid</span> == null || <span class="hljs-keyword">grid</span>.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        m = <span class="hljs-keyword">grid</span>.length;        n = <span class="hljs-keyword">grid</span>[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">int</span> maxArea = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-comment">// 这里可以加个条件，不等于0进来</span>                <span class="hljs-comment">// 每次取最大面积</span>                maxArea = Math.<span class="hljs-keyword">max</span>(maxArea, dfs(<span class="hljs-keyword">grid</span>, i, j));            &#125;        &#125;        <span class="hljs-keyword">return</span> maxArea;    &#125;       private <span class="hljs-keyword">int</span> dfs(<span class="hljs-keyword">int</span>[][] <span class="hljs-keyword">grid</span>, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) &#123;        <span class="hljs-comment">// 失败条件</span>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span> || r &gt;= m || c &lt; <span class="hljs-number">0</span> || c &gt;= n || <span class="hljs-keyword">grid</span>[r][c] == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 标记走过</span>        <span class="hljs-keyword">grid</span>[r][c] = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 开始dfs</span>        <span class="hljs-keyword">int</span> area = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] d : direaction) &#123;            area += dfs(<span class="hljs-keyword">grid</span>, r + d[<span class="hljs-number">0</span>], c + d[<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> area;    &#125;&#125;</code></pre><h3 id="5-电话号码的字母组合-1085"><a href="#5-电话号码的字母组合-1085" class="headerlink" title="5. 电话号码的字母组合(1085)"></a>5. 电话号码的字母组合(1085)</h3><blockquote><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：digits = <span class="hljs-string">&quot;23&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：[<span class="hljs-string">&quot;ad&quot;</span>,<span class="hljs-string">&quot;ae&quot;</span>,<span class="hljs-string">&quot;af&quot;</span>,<span class="hljs-string">&quot;bd&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;bf&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;ce&quot;</span>,<span class="hljs-string">&quot;cf&quot;</span>]</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：digits = <span class="hljs-string">&quot;2&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]</span></code></pre><p>在电话键盘上的对应顺序为：</p><p>2-abc，3-def，4-ghi，5-jkl，6-mno，7-pqrs，8-tuv，9-wxyz。</p></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-keyword">private</span> static final String<span class="hljs-literal">[]</span> KEYS = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>&#125;;    public List&lt;String&gt; letter<span class="hljs-constructor">Combinations(String <span class="hljs-params">digits</span>)</span> &#123;        List&lt;String&gt; combinnations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">if</span> (digits<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>digits.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return combinnations;        <span class="hljs-keyword">do</span><span class="hljs-constructor">Combination(<span class="hljs-params">new</span> StringBuilder()</span>, combinnations, digits);        return combinnations;    &#125;        <span class="hljs-keyword">private</span> void <span class="hljs-keyword">do</span><span class="hljs-constructor">Combination(StringBuilder <span class="hljs-params">prefix</span>, List&lt;String&gt; <span class="hljs-params">combinnations</span>, <span class="hljs-params">final</span> String <span class="hljs-params">digits</span>)</span> &#123;        <span class="hljs-keyword">if</span> (prefix.length<span class="hljs-literal">()</span><span class="hljs-operator"> == </span>digits.length<span class="hljs-literal">()</span>) &#123;            combinnations.add(prefix.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);            return;        &#125;        <span class="hljs-built_in">int</span> curDigits = digits.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">prefix</span>.<span class="hljs-params">length</span>()</span>) - <span class="hljs-character">&#x27;0&#x27;</span>;        String letters = KEYS<span class="hljs-literal">[<span class="hljs-identifier">curDigits</span>]</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">char</span> c : letters.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>) &#123;            prefix.append(c);            <span class="hljs-keyword">do</span><span class="hljs-constructor">Combination(<span class="hljs-params">prefix</span>, <span class="hljs-params">combinnations</span>, <span class="hljs-params">digits</span>)</span>;            prefix.delete<span class="hljs-constructor">CharAt(<span class="hljs-params">prefix</span>.<span class="hljs-params">length</span>()</span> - <span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre><h3 id="6-被围绕的区域-328"><a href="#6-被围绕的区域-328" class="headerlink" title="6. 被围绕的区域(328)"></a>6. 被围绕的区域(328)</h3><blockquote><p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><pre><code class="hljs prolog">&gt;输入：board = [[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>]]&gt;输出：[[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>]]&gt;解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 <span class="hljs-string">&#x27;O&#x27;</span> 都不会被填充为 <span class="hljs-string">&#x27;X&#x27;</span>。 任何不在边界上，或不与边界上的 <span class="hljs-string">&#x27;O&#x27;</span> 相连的 <span class="hljs-string">&#x27;O&#x27;</span> 最终都会被填充为 <span class="hljs-string">&#x27;X&#x27;</span>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</code></pre></blockquote><pre><code class="hljs aspectj"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] direction = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> m, n;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">if</span> (board == <span class="hljs-keyword">null</span> || board.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        m = board.length;        n = board[<span class="hljs-number">0</span>].length;        <span class="hljs-comment">// 边缘两列</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            dfs(board, i, <span class="hljs-number">0</span>);            dfs(board, i, n - <span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">// 上下两行</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            dfs(board, <span class="hljs-number">0</span>, i);            dfs(board, m - <span class="hljs-number">1</span>, i);        &#125;        <span class="hljs-comment">// 再走全部走一遍</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-comment">// 遇见T标记O</span>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;T&#x27;</span>) &#123;                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;                    <span class="hljs-comment">// 遇见O标记X</span>                &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)</span> </span>&#123;                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>&#123;        <span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span> || r &gt;= m || c &lt; <span class="hljs-number">0</span> || c &gt;= n || board[r][c] != <span class="hljs-string">&#x27;O&#x27;</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        board[r][c] = <span class="hljs-string">&#x27;T&#x27;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] d : direction) &#123;            dfs(board, r + d[<span class="hljs-number">0</span>], c + d[<span class="hljs-number">1</span>]);        &#125;    &#125;&#125;</code></pre><h3 id="7-求-1-n-这-n-个数字的排列组合有多少个"><a href="#7-求-1-n-这-n-个数字的排列组合有多少个" class="headerlink" title="7. 求 [1,n] 这 n 个数字的排列组合有多少个"></a>7. 求 [1,n] 这 n 个数字的排列组合有多少个</h3><p>条件：相邻的两个数字的绝对值不能等于1. 例如： 4 [2, 4, 1, 3] [3, 1, 4, 2]</p><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;List&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123;    Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);    n = sc.nextInt();    <span class="hljs-keyword">boolean</span>[] marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>];    dfs(<span class="hljs-number">0</span>, marked, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());    <span class="hljs-keyword">for</span> (List&lt;Integer&gt; <span class="hljs-built_in">list</span> : ret) &#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">list</span>.toString());    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">boolean</span>[] marked, ArrayList&lt;Integer&gt; <span class="hljs-built_in">list</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>.<span class="hljs-built_in">size</span>() == n) &#123;        ret.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-built_in">list</span>));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 开始遍历</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-comment">// 关键是这个条件</span>        <span class="hljs-keyword">if</span> (!marked[i] &amp;&amp; (<span class="hljs-built_in">list</span>.isEmpty() || Math.<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">list</span>.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">list</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) - i) != <span class="hljs-number">1</span>))&#123;            <span class="hljs-built_in">list</span>.add(i);            marked[i] = <span class="hljs-literal">true</span>;            dfs(x+<span class="hljs-number">1</span>, marked, <span class="hljs-built_in">list</span>);            <span class="hljs-built_in">list</span>.<span class="hljs-built_in">remove</span>(<span class="hljs-built_in">list</span>.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);            marked[i] = <span class="hljs-literal">false</span>;        &#125;    &#125;&#125;</code></pre><h3 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h3><blockquote><p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p><p>皇后攻击范围为横线，竖线，斜线。</p><pre><code class="hljs prolog">&gt;输入：n = <span class="hljs-number">4</span>&gt;输出：[[<span class="hljs-string">&quot;.Q..&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;..Q.&quot;</span>],[<span class="hljs-string">&quot;..Q.&quot;</span>,<span class="hljs-string">&quot;Q...&quot;</span>,<span class="hljs-string">&quot;...Q&quot;</span>,<span class="hljs-string">&quot;.Q..&quot;</span>]]&gt;解释：如上图所示，<span class="hljs-number">4</span> 皇后问题存在两个不同的解法。</code></pre><pre><code class="hljs lua">&gt;输入：n = <span class="hljs-number">1</span>&gt;输出：<span class="hljs-string">[[&quot;Q&quot;]]</span></code></pre></blockquote><pre><code class="hljs processing">class Solution &#123;    <span class="hljs-built_in">boolean</span>[] col = <span class="hljs-keyword">null</span>;    <span class="hljs-built_in">boolean</span>[] left = <span class="hljs-keyword">null</span>;    <span class="hljs-built_in">boolean</span>[] right = <span class="hljs-keyword">null</span>;    List&lt;List&lt;<span class="hljs-keyword">String</span>&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;<span class="hljs-keyword">String</span>&gt;&gt; solveNQueens(<span class="hljs-built_in">int</span> n) &#123;        col = <span class="hljs-keyword">new</span> <span class="hljs-built_in">boolean</span>[n];        left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">boolean</span>[<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>];        right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">boolean</span>[<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>];        <span class="hljs-built_in">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[n][n];        dfs(board, <span class="hljs-number">0</span>, n);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> dfs(<span class="hljs-built_in">char</span>[][] board, <span class="hljs-built_in">int</span> r, <span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-keyword">if</span> (r &gt;= n) &#123;            List&lt;<span class="hljs-keyword">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)                list.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(board[i]));            res.<span class="hljs-built_in">add</span>(list);            <span class="hljs-keyword">return</span>;        &#125;        Arrays.<span class="hljs-built_in">fill</span>(board[r], <span class="hljs-string">&#x27;.&#x27;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (!col[i] &amp;&amp; !left[r + i] &amp;&amp; !right[r - i + n - <span class="hljs-number">1</span>]) &#123;                board[r][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;                col[i] = <span class="hljs-keyword">true</span>;                left[r + i] = <span class="hljs-keyword">true</span>;                right[r - i + n - <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;                dfs(board, r + <span class="hljs-number">1</span>, n);                board[r][i] = <span class="hljs-string">&#x27;.&#x27;</span>;                col[i] = <span class="hljs-keyword">false</span>;                left[r + i] = <span class="hljs-keyword">false</span>;                right[r - i + n - <span class="hljs-number">1</span>] = <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a>329. 矩阵中的最长递增路径</h3><blockquote><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p><pre><code class="hljs inform7">&gt;输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[9,9,4]</span>,<span class="hljs-comment">[6,6,8]</span>,<span class="hljs-comment">[2,1,1]</span>]</span>&gt;输出：4 &gt;解释：最长递增路径为 <span class="hljs-comment">[1, 2, 6, 9]</span>。</code></pre><pre><code class="hljs inform7">&gt;输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[3,4,5]</span>,<span class="hljs-comment">[3,2,6]</span>,<span class="hljs-comment">[2,2,1]</span>]</span>&gt;输出：4 &gt;解释：最长递增路径是 <span class="hljs-comment">[3, 4, 5, 6]</span>。注意不允许在对角线方向上移动。</code></pre></blockquote><pre><code class="hljs stan">class Solution &#123;    <span class="hljs-keyword">int</span>[][] next = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">int</span> <span class="hljs-built_in">rows</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">cols</span> = <span class="hljs-number">0</span>;    boolean[][] marked = null;    <span class="hljs-keyword">int</span>[][] res = null;    public <span class="hljs-keyword">int</span> longestIncreasingPath(<span class="hljs-keyword">int</span>[][] <span class="hljs-keyword">matrix</span>) &#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">matrix</span> == null || <span class="hljs-keyword">matrix</span>.length == <span class="hljs-number">0</span> || <span class="hljs-keyword">matrix</span>[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;        this.<span class="hljs-built_in">rows</span> = <span class="hljs-keyword">matrix</span>.length;        this.<span class="hljs-built_in">cols</span> = <span class="hljs-keyword">matrix</span>[<span class="hljs-number">0</span>].length;        this.marked = new boolean[<span class="hljs-built_in">rows</span>][<span class="hljs-built_in">cols</span>];        this.res = new <span class="hljs-keyword">int</span>[<span class="hljs-built_in">rows</span>][<span class="hljs-built_in">cols</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">rows</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">cols</span>; j++) &#123;                <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, dfs(<span class="hljs-keyword">matrix</span>, i, j));            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;    &#125;    public <span class="hljs-keyword">int</span> dfs(<span class="hljs-keyword">int</span>[][] <span class="hljs-keyword">matrix</span>, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) &#123;        <span class="hljs-keyword">if</span>(res[x][y] != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> res[x][y];        &#125;        marked[x][y] = true;        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] n : next) &#123;            <span class="hljs-keyword">int</span> nx = x + n[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> ny = y + n[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; <span class="hljs-built_in">rows</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; <span class="hljs-built_in">cols</span> &amp;&amp; <span class="hljs-keyword">matrix</span>[x][y] &lt; <span class="hljs-keyword">matrix</span>[nx][ny] &amp;&amp; !marked[nx][ny])                len = Math.<span class="hljs-built_in">max</span>(len, dfs(<span class="hljs-keyword">matrix</span>, nx, ny));        &#125;        marked[x][y] = false;        res[x][y] = len + <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> res[x][y];    &#125;&#125;</code></pre><h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a>93. 复原IP地址</h3><blockquote><p>给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。</p><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;25525511135&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：[<span class="hljs-string">&quot;255.255.11.135&quot;</span>,<span class="hljs-string">&quot;255.255.111.35&quot;</span>]</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;010010&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：[<span class="hljs-string">&quot;0.10.0.10&quot;</span>,<span class="hljs-string">&quot;0.100.1.0&quot;</span>]</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;101023&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：[<span class="hljs-string">&quot;1.0.10.23&quot;</span>,<span class="hljs-string">&quot;1.0.102.3&quot;</span>,<span class="hljs-string">&quot;10.1.0.23&quot;</span>,<span class="hljs-string">&quot;10.10.2.3&quot;</span>,<span class="hljs-string">&quot;101.0.2.3&quot;</span>]</span></code></pre></blockquote><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;<span class="hljs-built_in">String</span>&gt; addresses = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">restoreIpAddresses</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> s</span>)</span> &#123;                StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        dfs(<span class="hljs-number">0</span>, sb, s);        <span class="hljs-keyword">return</span> addresses;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">dfs</span>(<span class="hljs-params">int k, StringBuilder sb, <span class="hljs-built_in">String</span> s</span>)</span> &#123;        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">4</span> || s.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">4</span> &amp;&amp; s.length() == <span class="hljs-number">0</span>) &#123;                addresses.add(sb.toString());            &#125;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; s.length() &amp;&amp; i &lt;= <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">break</span>;            <span class="hljs-built_in">String</span> part = s.substring(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (Integer.valueOf(part) &lt;= <span class="hljs-number">255</span>) &#123;                <span class="hljs-keyword">if</span> (sb.length() != <span class="hljs-number">0</span>) &#123;                    part = <span class="hljs-string">&quot;.&quot;</span> + part;                &#125;                sb.append(part);                dfs(k + <span class="hljs-number">1</span>, sb, s.substring(i + <span class="hljs-number">1</span>));                sb.delete(sb.length() - part.length(),sb.length());            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS相关算法题</title>
    <link href="/2021/03/20/BFS%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/03/20/BFS%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><blockquote><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。让其组成和的完全平方数的个数最少。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：n = 12</span><span class="hljs-meta">&gt;</span><span class="bash">输出：3</span> <span class="hljs-meta">&gt;</span><span class="bash">解释：12 = 4 + 4 + 4</span><span class="hljs-meta">&gt;</span><span class="bash">输入：n = 13</span><span class="hljs-meta">&gt;</span><span class="bash">输出：2</span><span class="hljs-meta">&gt;</span><span class="bash">解释：13 = 4 + 9</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    List&lt;Integer&gt; squares = generateSquares(n);    Queue&lt;Integer&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">boolean</span>[] marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 其实感觉是为了剪枝,也可以set标记</span>    <span class="hljs-built_in">queue</span>.add(n);    marked[n] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// </span>    <span class="hljs-keyword">int</span> level = <span class="hljs-number">0</span>; <span class="hljs-comment">// </span>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">queue</span>.isEmpty()) &#123;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();        level++;        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">size</span>-- &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> cur = <span class="hljs-built_in">queue</span>.poll();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> s : squares) &#123;                <span class="hljs-keyword">int</span> next = cur - s;                <span class="hljs-keyword">if</span> (next &lt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (next == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">return</span> level;                &#125;                <span class="hljs-keyword">if</span> (marked[next]) &#123;                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 剪</span>                &#125;                marked[next] = <span class="hljs-literal">true</span>;                <span class="hljs-built_in">queue</span>.add(next);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> n;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 生成小于 n 的平方数序列</span><span class="hljs-comment"> * @return 1,4,9,...</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">generateSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    List&lt;Integer&gt; squares = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> square = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> diff = <span class="hljs-number">3</span>;    <span class="hljs-keyword">while</span> (square &lt;= n) &#123;        squares.add(square);        square += diff;        diff += <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">return</span> squares;&#125;</code></pre><h3 id="2-二叉树的最小深度"><a href="#2-二叉树的最小深度" class="headerlink" title="2. 二叉树的最小深度"></a>2. 二叉树的最小深度</h3><blockquote><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><pre><code class="hljs yaml"><span class="hljs-string">&gt;输入：root</span> <span class="hljs-string">=</span> [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<span class="hljs-string">&gt;输出：2</span><span class="hljs-string">&gt;输入：root</span> <span class="hljs-string">=</span> [<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<span class="hljs-string">&gt;输出：5</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        Queue&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 树不需要标记哦</span>        <span class="hljs-built_in">queue</span>.add(root);        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">1</span>; <span class="hljs-comment">// 根根</span>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">queue</span>.isEmpty()) &#123;            <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">size</span>-- &gt; <span class="hljs-number">0</span>) &#123;                TreeNode node = <span class="hljs-built_in">queue</span>.poll();                <span class="hljs-keyword">if</span> (node.left == null &amp;&amp; node.right == null)                    <span class="hljs-keyword">return</span> depth;                <span class="hljs-keyword">if</span> (node.left != null)                    <span class="hljs-built_in">queue</span>.add(node.left);                <span class="hljs-keyword">if</span> (node.right != null)                    <span class="hljs-built_in">queue</span>.add(node.right);            &#125;            depth++;        &#125;        <span class="hljs-keyword">return</span> depth;    &#125;&#125;</code></pre><h3 id="3-打开转盘锁"><a href="#3-打开转盘锁" class="headerlink" title="3. 打开转盘锁"></a>3. 打开转盘锁</h3><blockquote><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><pre><code class="hljs clean">&gt;输入：deadends = [<span class="hljs-string">&quot;0201&quot;</span>,<span class="hljs-string">&quot;0101&quot;</span>,<span class="hljs-string">&quot;0102&quot;</span>,<span class="hljs-string">&quot;1212&quot;</span>,<span class="hljs-string">&quot;2002&quot;</span>], target = <span class="hljs-string">&quot;0202&quot;</span>&gt;输出：<span class="hljs-number">6</span>&gt;解释：&gt;可能的移动序列为 <span class="hljs-string">&quot;0000&quot;</span> -&gt; <span class="hljs-string">&quot;1000&quot;</span> -&gt; <span class="hljs-string">&quot;1100&quot;</span> -&gt; <span class="hljs-string">&quot;1200&quot;</span> -&gt; <span class="hljs-string">&quot;1201&quot;</span> -&gt; <span class="hljs-string">&quot;1202&quot;</span> -&gt; <span class="hljs-string">&quot;0202&quot;</span>。&gt;注意 <span class="hljs-string">&quot;0000&quot;</span> -&gt; <span class="hljs-string">&quot;0001&quot;</span> -&gt; <span class="hljs-string">&quot;0002&quot;</span> -&gt; <span class="hljs-string">&quot;0102&quot;</span> -&gt; <span class="hljs-string">&quot;0202&quot;</span> 这样的序列是不能解锁的，&gt;因为当拨动到 <span class="hljs-string">&quot;0102&quot;</span> 时这个锁就会被锁定。</code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: deadends = [<span class="hljs-string">&quot;8888&quot;</span>], target = <span class="hljs-string">&quot;0009&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：1</span><span class="hljs-meta">&gt;</span><span class="bash">解释：</span><span class="hljs-meta">&gt;</span><span class="bash">把最后一位反向旋转一次即可 <span class="hljs-string">&quot;0000&quot;</span> -&gt; <span class="hljs-string">&quot;0009&quot;</span>。</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: deadends = [<span class="hljs-string">&quot;8887&quot;</span>,<span class="hljs-string">&quot;8889&quot;</span>,<span class="hljs-string">&quot;8878&quot;</span>,<span class="hljs-string">&quot;8898&quot;</span>,<span class="hljs-string">&quot;8788&quot;</span>,<span class="hljs-string">&quot;8988&quot;</span>,<span class="hljs-string">&quot;7888&quot;</span>,<span class="hljs-string">&quot;9888&quot;</span>], target = <span class="hljs-string">&quot;8888&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：-1</span><span class="hljs-meta">&gt;</span><span class="bash">解释：</span><span class="hljs-meta">&gt;</span><span class="bash">无法旋转到目标数字且不被锁定。</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] deadends, <span class="hljs-keyword">String</span> target)</span> </span>&#123;        <span class="hljs-comment">// 这里将dead和marked放在一起</span>        Set&lt;<span class="hljs-keyword">String</span>&gt; dead = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> s : deadends)            dead.add(s);        <span class="hljs-comment">// queue</span>        Queue&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        Set&lt;<span class="hljs-keyword">String</span>&gt; marked = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        <span class="hljs-built_in">queue</span>.add(<span class="hljs-string">&quot;0000&quot;</span>);        marked.add(<span class="hljs-string">&quot;0000&quot;</span>);        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-comment">// luoji</span>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">queue</span>.isEmpty()) &#123;            <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">size</span>-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">String</span> cur = <span class="hljs-built_in">queue</span>.poll();                <span class="hljs-keyword">if</span> (dead.contains(cur))                    <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">if</span> (cur.equals(target))                    <span class="hljs-keyword">return</span> cnt;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;                    <span class="hljs-keyword">String</span> up = plusOne(cur, i);                    <span class="hljs-keyword">if</span> (!marked.contains(up)) &#123;                        <span class="hljs-built_in">queue</span>.add(up);                        marked.add(up);                    &#125;                    <span class="hljs-keyword">String</span> down = minusOne(cur, i);                    <span class="hljs-keyword">if</span> (!marked.contains(down)) &#123;                        <span class="hljs-built_in">queue</span>.add(down);                        marked.add(down);                    &#125;                &#125;            &#125;            cnt++;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">plusOne</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] ch = s.toCharArray();        <span class="hljs-keyword">if</span> (ch[j] == <span class="hljs-string">&#x27;9&#x27;</span>)            ch[j] = <span class="hljs-string">&#x27;0&#x27;</span>;        <span class="hljs-keyword">else</span>            ch[j] += <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(ch);    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">minusOne</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">char</span>[] ch = s.toCharArray();        <span class="hljs-keyword">if</span> (ch[j] == <span class="hljs-string">&#x27;0&#x27;</span>)            ch[j] = <span class="hljs-string">&#x27;9&#x27;</span>;        <span class="hljs-keyword">else</span>            ch[j] -= <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(ch);    &#125;&#125;</code></pre><h3 id="4-地图分析"><a href="#4-地图分析" class="headerlink" title="4. 地图分析"></a>4. 地图分析</h3><blockquote><p>你现在手里有一份大小为 N x N 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。</p><p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>如果网格上只有陆地或者海洋，请返回 -1。</p><pre><code class="hljs lua">&gt;输入：<span class="hljs-string">[[1,0,1],[0,0,0],[1,0,1]]</span>&gt;输出：<span class="hljs-number">2</span>&gt;解释： &gt;海洋单元格 (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) 和所有陆地单元格之间的距离都达到最大，最大距离为 <span class="hljs-number">2</span>。&gt;即最中间那个方格。</code></pre><pre><code class="hljs lua">&gt;输入：<span class="hljs-string">[[1,0,0],[0,0,0],[0,0,0]]</span>&gt;输出：<span class="hljs-number">4</span>&gt;解释： &gt;海洋单元格 (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) 和所有陆地单元格之间的距离都达到最大，最大距离为 <span class="hljs-number">4</span>。&gt;即最右下角的方格。</code></pre></blockquote><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> int maxDistance(int[][] grid) &#123;        int[][] dir = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;        Queue&lt;Pair&lt;Integer, Integer&gt;&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedList</span>&lt;&gt;();        int m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-comment">// 先把所有的陆地都入队</span>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)                    q.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(i, j));            &#125;        &#125;        <span class="hljs-comment">// 判断是否都是陆地 或者没有陆地</span>        <span class="hljs-keyword">if</span> (q.size() == m * n || q.isEmpty())            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-comment">// 从各个陆地开始，一圈一圈的遍历海洋，最后遍历到的海洋就是离陆地最远的海洋。</span>        int step = <span class="hljs-number">0</span>;        Pair&lt;Integer, Integer&gt; p = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;            int size = q.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                p = q.poll();                int x = p.getKey(), y = p.getValue();                <span class="hljs-comment">// 取出队列的元素，将其四周的海洋入队。</span>                <span class="hljs-keyword">for</span> (int[] d : <span class="hljs-type">dir</span>) &#123;                    int <span class="hljs-keyword">new</span><span class="hljs-type">X</span> = x + d[<span class="hljs-number">0</span>];                    int <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> = y + d[<span class="hljs-number">1</span>];                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">X</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">new</span><span class="hljs-type">X</span> &gt;= m || <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> &gt;= n || grid[<span class="hljs-keyword">new</span><span class="hljs-type">X</span>][<span class="hljs-keyword">new</span><span class="hljs-type">Y</span>] != <span class="hljs-number">0</span>) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    grid[<span class="hljs-keyword">new</span><span class="hljs-type">X</span>][<span class="hljs-keyword">new</span><span class="hljs-type">Y</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记</span>                    q.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(<span class="hljs-keyword">new</span><span class="hljs-type">X</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Y</span>));                &#125;            &#125;            <span class="hljs-keyword">if</span> (q.size() &gt; <span class="hljs-number">0</span>)                step++;        &#125;        <span class="hljs-keyword">return</span> step;    &#125;&#125;<span class="hljs-keyword">public</span> int maxDistance(int[][] grid) &#123;    int[][] dir = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;&#125;;    Queue&lt;Pair&lt;Integer, Integer&gt;&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedList</span>&lt;&gt;();    int m = grid.length, n = grid[<span class="hljs-number">0</span>].length;    <span class="hljs-comment">// 先把所有的陆地都入队</span>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)                q.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(i, j));        &#125;    &#125;    <span class="hljs-comment">// 判断是否都是陆地 或者没有陆地</span>    <span class="hljs-keyword">if</span> (q.size() == m + n || q.isEmpty())        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-comment">// 从各个陆地开始，一圈一圈的遍历海洋，最后遍历到的海洋就是离陆地最远的海洋。</span>    Pair&lt;Integer, Integer&gt; p = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;        p = q.poll();        int x = p.getKey(), y = p.getValue();        <span class="hljs-comment">// 取出队列的元素，将其四周的海洋入队。</span>        <span class="hljs-keyword">for</span> (int[] d : <span class="hljs-type">dir</span>) &#123;            int <span class="hljs-keyword">new</span><span class="hljs-type">X</span> = x + d[<span class="hljs-number">0</span>];            int <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> = y + d[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">X</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">new</span><span class="hljs-type">X</span> &gt;= m || <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> &gt;= n || grid[<span class="hljs-keyword">new</span><span class="hljs-type">X</span>][<span class="hljs-keyword">new</span><span class="hljs-type">Y</span>] != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            grid[<span class="hljs-keyword">new</span><span class="hljs-type">X</span>][<span class="hljs-keyword">new</span><span class="hljs-type">Y</span>] = grid[x][y] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 省略了标记， 要不然要加标记并且加个变量</span>            q.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(<span class="hljs-keyword">new</span><span class="hljs-type">X</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Y</span>));        &#125;    &#125;    <span class="hljs-keyword">return</span> grid[p.getKey()][p.getValue()] - <span class="hljs-number">1</span>;&#125;</code></pre><h3 id="5-腐烂的橘子"><a href="#5-腐烂的橘子" class="headerlink" title="5. 腐烂的橘子"></a>5. 腐烂的橘子</h3><blockquote><p>在给定的网格中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。</p><p>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。</p><pre><code class="hljs lua">&gt;输入：<span class="hljs-string">[[2,1,1],[1,1,0],[0,1,1]]</span>&gt;输出：<span class="hljs-number">4</span>&gt;输入：<span class="hljs-string">[[2,1,1],[0,1,1],[1,0,1]]</span>&gt;输出：<span class="hljs-number">-1</span>&gt;解释：左下角的橘子（第 <span class="hljs-number">2</span> 行， 第 <span class="hljs-number">0</span> 列）永远不会腐烂，因为腐烂只会发生在 <span class="hljs-number">4</span> 个正向上</code></pre></blockquote><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> int orangesRotting(int[][] grid) &#123;        <span class="hljs-comment">// 俺就不判断了，直接上</span>        int[][] dir = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;        Queue&lt;Pair&lt;Integer, Integer&gt;&gt; q = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedList</span>&lt;&gt;();        int m = grid.length, n = grid[<span class="hljs-number">0</span>].length;        int cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 表示新鲜的橘子</span>        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)                    cnt++; <span class="hljs-comment">// 新鲜橘子计数</span>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>)                    q.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(i, j)); <span class="hljs-comment">// 腐烂橘子的坐标</span>            &#125;        &#125;        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span> || q.size() == m * n)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        int step = <span class="hljs-number">0</span>; <span class="hljs-comment">// 轮数</span>        <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">0</span> &amp;&amp; !q.isEmpty())&#123;            int size = q.size();            <span class="hljs-keyword">while</span> (size-- &gt; <span class="hljs-number">0</span>) &#123;                Pair&lt;Integer, Integer&gt; p = q.poll();                int x = p.getKey(), y = p.getValue();                <span class="hljs-keyword">for</span> (int[] d : <span class="hljs-type">dir</span>) &#123;                    int <span class="hljs-keyword">new</span><span class="hljs-type">X</span> = x + d[<span class="hljs-number">0</span>];                    int <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> = y + d[<span class="hljs-number">1</span>];                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">X</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">new</span><span class="hljs-type">X</span> &gt;= m || <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">new</span><span class="hljs-type">Y</span> &gt;= n) &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-keyword">if</span> (grid[<span class="hljs-keyword">new</span><span class="hljs-type">X</span>][<span class="hljs-keyword">new</span><span class="hljs-type">Y</span>] == <span class="hljs-number">1</span>) &#123;                        grid[<span class="hljs-keyword">new</span><span class="hljs-type">X</span>][<span class="hljs-keyword">new</span><span class="hljs-type">Y</span>] = <span class="hljs-number">2</span>;                        q.add(<span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(<span class="hljs-keyword">new</span><span class="hljs-type">X</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Y</span>));                        cnt--;                    &#125;                &#125;            &#125;            step++;        &#125;        <span class="hljs-keyword">return</span> cnt &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-type">step</span>;    &#125;&#125;</code></pre><h3 id="6-被围绕的区域"><a href="#6-被围绕的区域" class="headerlink" title="6. 被围绕的区域"></a>6. 被围绕的区域</h3><blockquote><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><pre><code class="hljs prolog">&gt;输入：board = [[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>]]&gt;输出：[[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>],[<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;O&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>]]&gt;解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 <span class="hljs-string">&#x27;O&#x27;</span> 都不会被填充为 <span class="hljs-string">&#x27;X&#x27;</span>。 任何不在边界上，或不与边界上的 <span class="hljs-string">&#x27;O&#x27;</span> 相连的 <span class="hljs-string">&#x27;O&#x27;</span> 最终都会被填充为 <span class="hljs-string">&#x27;X&#x27;</span>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</code></pre><pre><code class="hljs lua">&gt;输入：board = <span class="hljs-string">[[&quot;X&quot;]]</span>&gt;输出：<span class="hljs-string">[[&quot;X&quot;]]</span></code></pre></blockquote><pre><code class="hljs processing"><span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Queue;class Solution &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> solve(<span class="hljs-built_in">char</span>[][] board) &#123;        <span class="hljs-keyword">if</span> (board == <span class="hljs-keyword">null</span> || board.length == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span>;        <span class="hljs-built_in">int</span>[][] dir = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;        <span class="hljs-built_in">int</span> m = board.length, n = board[<span class="hljs-number">0</span>].length;        Queue&lt;Pair&lt;Integer, Integer&gt;&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 找到边缘的O</span>        <span class="hljs-comment">// 边缘两列</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;                q.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Pair&lt;&gt;(i, <span class="hljs-number">0</span>));                board[i][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;T&#x27;</span>;            &#125;            <span class="hljs-keyword">if</span> (board[i][n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;                q.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Pair&lt;&gt;(i, n - <span class="hljs-number">1</span>));                board[i][n - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;T&#x27;</span>;            &#125;        &#125;        <span class="hljs-comment">// 上下两列</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][i] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;                q.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Pair&lt;&gt;(<span class="hljs-number">0</span>, i));                board[<span class="hljs-number">0</span>][i] = <span class="hljs-string">&#x27;T&#x27;</span>;            &#125;            <span class="hljs-keyword">if</span> (board[m - <span class="hljs-number">1</span>][i] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;                q.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Pair&lt;&gt;(m - <span class="hljs-number">1</span>, i));                board[m - <span class="hljs-number">1</span>][i] = <span class="hljs-string">&#x27;T&#x27;</span>;            &#125;        &#125;        <span class="hljs-comment">// bfs 搜索</span>        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;            <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span> = q.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">size</span>-- &gt; <span class="hljs-number">0</span>) &#123;                Pair&lt;Integer, Integer&gt; p = q.poll();                <span class="hljs-built_in">int</span> x = p.getKey(), y = p.getValue();                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span>[] d : dir) &#123;                    <span class="hljs-built_in">int</span> nx = x + d[<span class="hljs-number">0</span>];                    <span class="hljs-built_in">int</span> ny = y + d[<span class="hljs-number">1</span>];                    <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= m || ny &lt; <span class="hljs-number">0</span> || ny &gt;= n)                        <span class="hljs-keyword">continue</span>;                    <span class="hljs-keyword">if</span> (board[nx][ny] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123;                        q.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> Pair&lt;&gt;(nx, ny));                        board[nx][ny] = <span class="hljs-string">&#x27;T&#x27;</span>;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 标记</span>        <span class="hljs-comment">// 再走全部走一遍</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-comment">// 遇见T标记O</span>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;T&#x27;</span>) &#123;                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;                    <span class="hljs-comment">// 遇见O标记X</span>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>) &#123;                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="7-零钱兑换"><a href="#7-零钱兑换" class="headerlink" title="7. 零钱兑换"></a>7. 零钱兑换</h3><blockquote><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：coins = [1, 2, 5], amount = 11</span><span class="hljs-meta">&gt;</span><span class="bash">输出：3</span> <span class="hljs-meta">&gt;</span><span class="bash">解释：11 = 5 + 5 + 1</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">2</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">3</span>&gt;输出：-<span class="hljs-number">1</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">0</span>&gt;输出：<span class="hljs-number">0</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">coins</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">amount</span> = <span class="hljs-number">2</span>&gt;输出：<span class="hljs-number">2</span></code></pre></blockquote><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> coinChange(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount) &#123;        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         <span class="hljs-comment">// bfs</span>        Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        Set&lt;Integer&gt; marked = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        q.add(amount);        marked.add(amount);        Arrays.<span class="hljs-keyword">sort</span>(coins);        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;            <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = q.<span class="hljs-keyword">size</span>();            cnt++;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">size</span>-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">int</span> cur = q.poll();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> coin : coins) &#123;                    <span class="hljs-keyword">int</span> <span class="hljs-keyword">next</span> = cur - coin;                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">next</span> &lt; <span class="hljs-number">0</span>)                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">next</span> == <span class="hljs-number">0</span>)                        <span class="hljs-keyword">return</span> cnt;                    <span class="hljs-keyword">if</span> (marked.contains(<span class="hljs-keyword">next</span>))                        <span class="hljs-keyword">continue</span>;                    q.add(<span class="hljs-keyword">next</span>);                    marked.add(<span class="hljs-keyword">next</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h3 id="8-岛屿数量"><a href="#8-岛屿数量" class="headerlink" title="8. 岛屿数量"></a>8. 岛屿数量</h3><blockquote><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><pre><code class="hljs prolog">&gt;输入：grid = [ [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]&gt;]&gt;输出：<span class="hljs-number">1</span></code></pre><pre><code class="hljs prolog">&gt;输入：grid = [ [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]&gt;]&gt;输出：<span class="hljs-number">3</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">int</span>[][] dir = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">int</span> m, n;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">this</span>.m = grid.length;        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.n = grid[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">boolean</span>[][] marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (!marked[i][j] &amp;&amp; grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;                    cnt++;                    <span class="hljs-comment">// bfs</span>                    bfs(grid, marked, i, j);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> cnt;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">boolean</span>[][] marked, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        Queue&lt;Pair&lt;Integer, Integer&gt;&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        q.add(<span class="hljs-keyword">new</span> Pair&lt;&gt;(i, j));        marked[i][j] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;            <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = q.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">size</span>-- &gt; <span class="hljs-number">0</span>) &#123;                Pair&lt;Integer, Integer&gt; p = q.poll();                <span class="hljs-keyword">int</span> x = p.<span class="hljs-built_in">getKey</span>(), y = p.getValue();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] d : dir) &#123;                    <span class="hljs-keyword">int</span> nx = x + d[<span class="hljs-number">0</span>];                    <span class="hljs-keyword">int</span> ny = y + d[<span class="hljs-number">1</span>];                    <span class="hljs-keyword">if</span> (nx &lt; <span class="hljs-number">0</span> || nx &gt;= m || ny &lt; <span class="hljs-number">0</span> || ny &gt;= n || marked[nx][ny])                        <span class="hljs-keyword">continue</span>;                    <span class="hljs-keyword">if</span> (grid[nx][ny] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;                        q.add(<span class="hljs-keyword">new</span> Pair&lt;&gt;(nx, ny));                        marked[nx][ny] = <span class="hljs-literal">true</span>;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="9-单词接龙"><a href="#9-单词接龙" class="headerlink" title="9. 单词接龙"></a>9. 单词接龙</h3><blockquote><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p><p>序列中第一个单词是 beginWord 。<br>序列中最后一个单词是 endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典 wordList 中的单词。<br>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。</p><pre><code class="hljs clean">&gt;输入：beginWord = <span class="hljs-string">&quot;hit&quot;</span>, endWord = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>,<span class="hljs-string">&quot;cog&quot;</span>]&gt;输出：<span class="hljs-number">5</span>&gt;解释：一个最短转换序列是 <span class="hljs-string">&quot;hit&quot;</span> -&gt; <span class="hljs-string">&quot;hot&quot;</span> -&gt; <span class="hljs-string">&quot;dot&quot;</span> -&gt; <span class="hljs-string">&quot;dog&quot;</span> -&gt; <span class="hljs-string">&quot;cog&quot;</span>, 返回它的长度 <span class="hljs-number">5</span>。</code></pre><pre><code class="hljs erlang">&gt;输入：<span class="hljs-keyword">begin</span>Word = <span class="hljs-string">&quot;hit&quot;</span>, <span class="hljs-keyword">end</span>Word = <span class="hljs-string">&quot;cog&quot;</span>, wordList = [<span class="hljs-string">&quot;hot&quot;</span>,<span class="hljs-string">&quot;dot&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;lot&quot;</span>,<span class="hljs-string">&quot;log&quot;</span>]&gt;输出：<span class="hljs-number">0</span>&gt;解释：<span class="hljs-keyword">end</span>Word <span class="hljs-string">&quot;cog&quot;</span> 不在字典中，所以无法进行转换。</code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(<span class="hljs-keyword">String</span> beginWord, <span class="hljs-keyword">String</span> endWord, List&lt;<span class="hljs-keyword">String</span>&gt; wordList)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!wordList.contains(endWord))            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">boolean</span>[] marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[wordList.<span class="hljs-built_in">size</span>()]; <span class="hljs-comment">// 可以set</span>        <span class="hljs-comment">//检验是否存在beginWord，如果存在，就置为访问过了,没必要访问</span>        <span class="hljs-keyword">int</span> idx = wordList.indexOf(beginWord);        <span class="hljs-keyword">if</span> (idx != <span class="hljs-number">-1</span>)            marked[idx] = <span class="hljs-literal">true</span>;        Queue&lt;<span class="hljs-keyword">String</span>&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        q.add(beginWord);        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;            <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = q.<span class="hljs-built_in">size</span>();            cnt++;            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">size</span>-- &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">String</span> start = q.poll();                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; wordList.<span class="hljs-built_in">size</span>(); i++) &#123;                    <span class="hljs-comment">// 访问过了</span>                    <span class="hljs-keyword">if</span> (marked[i])                        <span class="hljs-keyword">continue</span>;                    <span class="hljs-keyword">String</span> s = wordList.<span class="hljs-built_in">get</span>(i);                    <span class="hljs-comment">//不满足和当前只差一个字符不同，跳过，访问下一个</span>                    <span class="hljs-keyword">if</span> (!isConnect(start, s))                        <span class="hljs-keyword">continue</span>;                    <span class="hljs-comment">//和endWord匹配上了，进行返回，因为是bfs，所以找到了直接返回就是最短的</span>                    <span class="hljs-keyword">if</span> (s.equals(endWord))                        <span class="hljs-keyword">return</span> cnt+<span class="hljs-number">1</span>;                    q.add(s);                    marked[i] = <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConnect</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s1, <span class="hljs-keyword">String</span> s2)</span> </span>&#123;        <span class="hljs-keyword">int</span> diffCnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s1.length() &amp;&amp; diffCnt &lt;= <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">if</span> (s1.charAt(i) != s2.charAt(i)) &#123;                diffCnt++;            &#125;        &#125;        <span class="hljs-keyword">return</span> diffCnt == <span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划相关算法题</title>
    <link href="/2021/03/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/03/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-1、斐波那契数列"><a href="#1-1、斐波那契数列" class="headerlink" title="1.1、斐波那契数列"></a>1.1、<a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">斐波那契数列</a></h3><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p></blockquote><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">T7</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Fibonacci(<span class="hljs-built_in">int</span> n) &#123;        <span class="hljs-comment">// 条件</span>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;       <span class="hljs-comment">// 可以用自底向上的方法</span>        <span class="hljs-built_in">int</span> pre2 = <span class="hljs-number">0</span>, pre1 = <span class="hljs-number">1</span>;        <span class="hljs-built_in">int</span> f = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;            f = pre2 + pre1; <span class="hljs-comment">// 如果动态规划，这个就是dp的公式</span>            pre2 = pre1;            pre1 = f;        &#125;        <span class="hljs-keyword">return</span> f;    &#125;&#125;</code></pre><h3 id="1-2、跳台阶"><a href="#1-2、跳台阶" class="headerlink" title="1.2、跳台阶"></a>1.2、<a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">跳台阶</a></h3><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。总得还是公式F(N)=F(N-1)+F(N-2)</p></blockquote><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T8</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">JumpFloor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;        <span class="hljs-comment">// 条件</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span>;      <span class="hljs-comment">// 自底向上的方法</span>        <span class="hljs-keyword">int</span> pre2 = <span class="hljs-number">1</span>, pre1 = <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= <span class="hljs-keyword">target</span>; i++) &#123;            sum = pre2 + pre1; <span class="hljs-comment">// 一样的道理， 和上面那道题的初始值不一样</span>            pre2 = pre1;            pre1 = sum;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h3 id="1-3、矩形覆盖"><a href="#1-3、矩形覆盖" class="headerlink" title="1.3、矩形覆盖"></a>1.3、<a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">矩形覆盖</a></h3><blockquote><p>我们可以用2乘1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2乘1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？还是公式F(N)=F(N-1)+F(N-2)。</p></blockquote><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T10</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">RectCover</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;        <span class="hljs-comment">// 条件</span>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span>;      <span class="hljs-comment">// 自底向上</span>        <span class="hljs-keyword">int</span> pre2 = <span class="hljs-number">1</span>, pre1 = <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= <span class="hljs-keyword">target</span>; i++) &#123;            sum = pre2 + pre1; <span class="hljs-comment">// 同理呀</span>            pre2 = pre1;            pre1 = sum;        &#125;        <span class="hljs-keyword">return</span> sum;    &#125;&#125;</code></pre><h3 id="1-4、变态跳台阶"><a href="#1-4、变态跳台阶" class="headerlink" title="1.4、变态跳台阶"></a>1.4、<a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">变态跳台阶</a></h3><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">JumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-keyword">target</span>)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">target</span>];    Arrays.fill(dp, <span class="hljs-number">1</span>);  <span class="hljs-comment">//快速填充数组值为1，每层都有直接一步到位的情形</span>    <span class="hljs-comment">// 注意起始位置</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-keyword">target</span>; i++)    <span class="hljs-comment">// 开始跳</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)        <span class="hljs-comment">// 注意dp[i] 累计dp[j]</span>            dp[i] += dp[j];    <span class="hljs-keyword">return</span> dp[<span class="hljs-keyword">target</span> - <span class="hljs-number">1</span>];&#125;</code></pre><h3 id="2-最大子序和-1385"><a href="#2-最大子序和-1385" class="headerlink" title="2. 最大子序和(1385)"></a>2. 最大子序和(1385)</h3><blockquote><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxSubArray(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 注意两个变量的初始化</span>        <span class="hljs-built_in">int</span> preSum = nums[<span class="hljs-number">0</span>];        <span class="hljs-built_in">int</span> maxSum = preSum;        <span class="hljs-comment">// 注意从1开始</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 注意这个条件</span>            preSum = preSum &gt; <span class="hljs-number">0</span> ? preSum + nums[i] : nums[i];            maxSum = Math.max(maxSum, preSum);        &#125;        <span class="hljs-keyword">return</span> maxSum;    &#125;&#125;</code></pre><h3 id="3-1、股票的最大利润"><a href="#3-1、股票的最大利润" class="headerlink" title="3.1、股票的最大利润"></a>3.1、<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china">股票的最大利润</a></h3><blockquote><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：[7,1,5,3,6,4]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：5</span><span class="hljs-meta">&gt;</span><span class="bash">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span>    注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：prices = [7,6,4,3,1]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：0</span><span class="hljs-meta">&gt;</span><span class="bash">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;        <span class="hljs-keyword">if</span> (prices == null || prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 从1开始</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-comment">// 注意保持最小</span>            <span class="hljs-built_in">min</span> = prices[i] &lt; <span class="hljs-built_in">min</span> ? prices[i] : <span class="hljs-built_in">min</span>;             <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, prices[i] - <span class="hljs-built_in">min</span>);  <span class="hljs-comment">//即找出已经出现的最小值，每天都计算利润即可</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;    &#125;&#125;</code></pre><h3 id="3-2-买卖股票的最佳时机-II"><a href="#3-2-买卖股票的最佳时机-II" class="headerlink" title="3.2 买卖股票的最佳时机 II"></a>3.2 买卖股票的最佳时机 II</h3><blockquote><p>在上题基础上可以多次交易</p><pre><code class="hljs tap">&gt;输入: [7,1,5,3,6,4]&gt;输出: 7&gt;解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。    随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。</code></pre><pre><code class="hljs tap">&gt;输入: [1,2,3,4,5]&gt;输出: 4&gt;解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。    注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre></blockquote><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> maxProfit(<span class="hljs-built_in">int</span>[] prices) &#123;        <span class="hljs-comment">// 贪心：只要我当前数比前一个数大， 就xxx</span>        <span class="hljs-built_in">int</span> profit = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 从1开始，因为下面的if</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++) &#123;            <span class="hljs-keyword">if</span> (prices[i] &gt; prices[i - <span class="hljs-number">1</span>])                 profit += prices[i]- prices[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">return</span> profit;    &#125;&#125;</code></pre><h3 id="4-打家劫舍"><a href="#4-打家劫舍" class="headerlink" title="4. 打家劫舍"></a>4. 打家劫舍</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><pre><code class="hljs tap">&gt;输入：[1,2,3,1]&gt;输出：4&gt;解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。    偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。</code></pre><pre><code class="hljs tap">&gt;输入：[2,7,9,3,1]&gt;输出：12&gt;解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。    偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>.</code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">int</span> pre2 = <span class="hljs-number">0</span>, pre1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-comment">// 注意这个状态转移，毕竟题目是隔着偷</span>            <span class="hljs-keyword">int</span> cur = Math.<span class="hljs-built_in">max</span>(pre2 + nums[i], pre1);            pre2 = pre1;            pre1 = cur;        &#125;        <span class="hljs-keyword">return</span> pre1;    &#125;&#125;</code></pre><h3 id="5-打家劫舍-II"><a href="#5-打家劫舍-II" class="headerlink" title="5. 打家劫舍 II"></a>5. 打家劫舍 II</h3><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [2,3,2]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：3</span><span class="hljs-meta">&gt;</span><span class="bash">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span></code></pre><pre><code class="hljs tap">&gt;输入：nums = [1,2,3,1]&gt;输出：4&gt;解释：你可以先偷窃<span class="hljs-number"> 1 </span>号房屋（金额 = 1），然后偷窃<span class="hljs-number"> 3 </span>号房屋（金额 = 3）。    偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。</code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums == null || nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        <span class="hljs-comment">// 注意0-n-2 个 1 -n-1</span>        <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(rob(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">2</span>), rob(nums, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>));    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> first, <span class="hljs-keyword">int</span> last)</span> </span>&#123;        <span class="hljs-keyword">int</span> pre2 = <span class="hljs-number">0</span>, pre1 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = first; i &lt;= last; i++) &#123;            <span class="hljs-keyword">int</span> cur = Math.<span class="hljs-built_in">max</span>(pre1, pre2 + nums[i]);            pre2 = pre1;            pre1 = cur;        &#125;        <span class="hljs-keyword">return</span> pre1;    &#125;&#125;</code></pre><h3 id="6、剪绳子"><a href="#6、剪绳子" class="headerlink" title="6、剪绳子"></a>6、<a href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&tqId=33257&tPage=4&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剪绳子</a></h3><blockquote><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash">8</span><span class="hljs-meta">&gt;</span><span class="bash">返回值</span><span class="hljs-meta">&gt;</span><span class="bash">18</span></code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-comment">// 动态规划</span>public <span class="hljs-built_in">int</span> integer<span class="hljs-constructor">Break(<span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span> &#123;    <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">n</span> + <span class="hljs-number">1</span>]</span>;    dp<span class="hljs-literal">[<span class="hljs-number">1</span>]</span> = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 一厘米，没法切，所以从2</span>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)    <span class="hljs-comment">// 切从1cm开始</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)        <span class="hljs-comment">//  注意这个状态转移</span>            dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(j<span class="hljs-operator"> * </span>(i - j), dp<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-operator"> * </span>(i - j)));    return dp<span class="hljs-literal">[<span class="hljs-identifier">n</span>]</span>;&#125;</code></pre><h3 id="7、礼物的最大值"><a href="#7、礼物的最大值" class="headerlink" title="7、礼物的最大值"></a>7、<a href="https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab">礼物的最大值</a></h3><blockquote><p>小东所在公司要发年终奖，而小东恰好获得了最高福利，他要在公司年会上参与一个抽奖游戏，游戏在一个6*6的棋盘上进行，上面放着36个价值不等的礼物，每个小的棋盘上面放置着一个礼物，他需要从左上角开始游戏，每次只能向下或者向右移动一步，到达右下角停止，一路上的格子里的礼物小东都能拿到，请设计一个算法使小东拿到价值最高的礼物。</p><p>给定一个6*6的矩阵<strong>board</strong>，其中每个元素为对应格子的礼物价值,左上角为[0,0],请返回能获得的最大价值，保证每个礼物价值大于100小于1000。</p></blockquote><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">int</span> getMost(<span class="hljs-type">int</span>[][] <span class="hljs-keyword">values</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">values</span> == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">values</span>.length == <span class="hljs-number">0</span> || <span class="hljs-keyword">values</span>[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> n = <span class="hljs-keyword">values</span>[<span class="hljs-number">0</span>].length;    <span class="hljs-type">int</span>[] dp = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[n];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] <span class="hljs-keyword">value</span> : <span class="hljs-keyword">values</span>) &#123;        dp[<span class="hljs-number">0</span>] += <span class="hljs-keyword">value</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)            dp[i] = Math.max(dp[i], dp[i - <span class="hljs-number">1</span>]) + <span class="hljs-keyword">value</span>[i];    &#125;    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];&#125;</code></pre><h3 id="8-最小路径和"><a href="#8-最小路径和" class="headerlink" title="8. 最小路径和"></a>8. 最小路径和</h3><blockquote><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><pre><code class="hljs lua">&gt;输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span>&gt;输出：<span class="hljs-number">7</span>&gt;解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。</code></pre><pre><code class="hljs lua">&gt;输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span>&gt;输出：<span class="hljs-number">12</span></code></pre></blockquote><pre><code class="hljs inform7">class Solution &#123;    public int minPathSum(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> grid) &#123;        if (grid == null || grid.length == 0 || grid<span class="hljs-comment">[0]</span>.length == 0)            return 0;        int m = grid.length;        int n = grid<span class="hljs-comment">[0]</span>.length;        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> dp = new int<span class="hljs-comment">[m]</span><span class="hljs-comment">[n]</span>;        dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = grid<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span>;        // 第一列        for (int i = 1; i &lt; m; i++)&#123;            dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[0]</span> + grid<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>;        &#125;        // 第一行        for (int j = 1; j &lt; n; j++)&#123;            dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[j - 1]</span> + grid<span class="hljs-comment">[0]</span><span class="hljs-comment">[j]</span>;        &#125;        for (int i = 1; i &lt; m; i++) &#123;            for (int j = 1; j &lt; n; j++)&#123;                dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = Math.min(dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>) + grid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>;            &#125;        &#125;        return dp<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span>;            &#125;&#125;</code></pre><h3 id="9-不同路径"><a href="#9-不同路径" class="headerlink" title="9. 不同路径"></a>9. 不同路径</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：m = 3, n = 2</span><span class="hljs-meta">&gt;</span><span class="bash">输出：3</span><span class="hljs-meta">&gt;</span><span class="bash">解释：</span><span class="hljs-meta">&gt;</span><span class="bash">从左上角开始，总共有 3 条路径可以到达右下角。</span><span class="hljs-meta">&gt;</span><span class="bash">1. 向右 -&gt; 向下 -&gt; 向下</span><span class="hljs-meta">&gt;</span><span class="bash">2. 向下 -&gt; 向下 -&gt; 向右</span><span class="hljs-meta">&gt;</span><span class="bash">3. 向下 -&gt; 向右 -&gt; 向下</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">m</span> = <span class="hljs-number">7</span>, <span class="hljs-attr">n</span> = <span class="hljs-number">3</span>&gt;输出：<span class="hljs-number">28</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-comment">// 优化过后了</span>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-comment">// 注意</span>        Arrays.<span class="hljs-built_in">fill</span>(dp, <span class="hljs-number">1</span>);        <span class="hljs-comment">// 注意起始位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;                <span class="hljs-comment">// 累加</span>                dp[j] += dp[j - <span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n <span class="hljs-number">-1</span>];    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>)                    dp[i][j] = <span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span> &#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];            &#125;&#125;</code></pre><h3 id="9-2-不同路径-II"><a href="#9-2-不同路径-II" class="headerlink" title="9.2 不同路径 II"></a>9.2 不同路径 II</h3><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：2</span><span class="hljs-meta">&gt;</span><span class="bash">解释：</span><span class="hljs-meta">&gt;</span><span class="bash">3x3 网格的正中间有一个障碍物。</span><span class="hljs-meta">&gt;</span><span class="bash">从左上角到右下角一共有 2 条不同的路径：</span><span class="hljs-meta">&gt;</span><span class="bash">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><span class="hljs-meta">&gt;</span><span class="bash">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span></code></pre><pre><code class="hljs lua">&gt;输入：obstacleGrid = <span class="hljs-string">[[0,1],[0,0]]</span>&gt;输出：<span class="hljs-number">1</span></code></pre></blockquote><pre><code class="hljs inform7">class Solution &#123;    public int uniquePathsWithObstacles(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> obstacleGrid) &#123;        int m = obstacleGrid.length;        int n = obstacleGrid<span class="hljs-comment">[0]</span>.length;        // 因为if        int<span class="hljs-comment">[]</span> dp = new int<span class="hljs-comment">[n + 1]</span>;        dp<span class="hljs-comment">[1]</span> = 1; // 注意初始值        // 起始位置        for (int i = 1; i &lt;= m; i++) &#123;            for (int j = 1; j &lt;= n; j++) &#123;                // 别忘了条件                if (obstacleGrid<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j - 1]</span> == 1)                     dp<span class="hljs-comment">[j]</span> = 0;                else                     dp<span class="hljs-comment">[j]</span> += dp<span class="hljs-comment">[j - 1]</span>;            &#125;        &#125;        return dp<span class="hljs-comment">[n]</span>;    &#125;&#125;class Solution &#123;    public int uniquePathsWithObstacles(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> obstacleGrid) &#123;        int m = obstacleGrid.length;        int n = obstacleGrid<span class="hljs-comment">[0]</span>.length;        int <span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> dp = new int<span class="hljs-comment">[m+1]</span><span class="hljs-comment">[n+1]</span>;        // 第一行 和 其他行的区别在于没有来自上边的路径 但是 起点到起点 算一条路径 所以这样初始化        dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[1]</span> = 1;        for(int i = 1; i &lt;= m; i++) &#123;            for(int j = 1; j &lt;= n; j++) &#123;                if(obstacleGrid<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span> == 1) &#123;                    // 障碍 不可达 路径数量为0                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = 0;                &#125;                else &#123;                    // 左 + 上                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span> + dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>;                &#125;            &#125;        &#125;        return dp<span class="hljs-comment">[m]</span><span class="hljs-comment">[n]</span>;    &#125;&#125;class Solution &#123;    public int uniquePathsWithObstacles(int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> obstacleGrid) &#123;        int m = obstacleGrid.length;        int n = obstacleGrid<span class="hljs-comment">[0]</span>.length;        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> dp = new int<span class="hljs-comment">[m]</span><span class="hljs-comment">[n]</span>;        dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 1;        for (int i = 0; i &lt; m; i++)&#123;            for (int j = 0; j &lt; n; j++)&#123;                if (obstacleGrid<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> == 1)                    continue;                if (i == 0 &amp;&amp; j == 0)                    continue;                if(i == 0)                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>;                else if (j == 0)                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span>;                else dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = dp<span class="hljs-comment">[i - 1]</span><span class="hljs-comment">[j]</span> + dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j - 1]</span>;            &#125;        &#125;        return dp<span class="hljs-comment">[m - 1]</span><span class="hljs-comment">[n - 1]</span>;    &#125;&#125;</code></pre><h3 id="9-3-最大正方形"><a href="#9-3-最大正方形" class="headerlink" title="9.3 最大正方形"></a>9.3 最大正方形</h3><blockquote><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p><pre><code class="hljs prolog">&gt;输入：matrix = [[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]]&gt;输出：<span class="hljs-number">4</span></code></pre></blockquote><pre><code class="hljs inform7">class Solution &#123;    public int maximalSquare(char<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> matrix) &#123;        /**        dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为:         dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = 1 + min(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>);        **/        if (matrix == null ||  matrix.length == 0 || matrix<span class="hljs-comment">[0]</span>.length == 0) return 0;        int m = matrix.length;        int n = matrix<span class="hljs-comment">[0]</span>.length;        int max = 0;        int<span class="hljs-comment">[]</span><span class="hljs-comment">[]</span> dp = new int<span class="hljs-comment">[m + 1]</span><span class="hljs-comment">[n + 1]</span>;        for (int i = 1; i &lt;= m; i++) &#123;            for (int j = 1; j &lt;= n; j++)&#123;                if (matrix<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span> == &#x27;1&#x27;) &#123;                    // 左， 上，左上                    dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span> = 1 + Math.min(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>, Math.min(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>));                    max = Math.max(max, dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>);                &#125;            &#125;        &#125;        return max * max;    &#125;&#125;</code></pre><h3 id="10-解码方法"><a href="#10-解码方法" class="headerlink" title="10. 解码方法"></a>10. 解码方法</h3><blockquote><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”111” 可以将 “1” 中的每个 “1” 映射为 “A” ，从而得到 “AAA” ，或者可以将 “11” 和 “1”（分别为 “K” 和 “A” ）映射为 “KA” 。注意，”06” 不能映射为 “F” ，因为 “6” 和 “06” 不同。</p><p>给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;12&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：2</span><span class="hljs-meta">&gt;</span><span class="bash">解释：它可以解码为 <span class="hljs-string">&quot;AB&quot;</span>（1 2）或者 <span class="hljs-string">&quot;L&quot;</span>（12）。</span></code></pre><pre><code class="hljs gcode">&gt;输入：s = <span class="hljs-string">&quot;226&quot;</span>&gt;输出：<span class="hljs-number">3</span>&gt;解释：它可以解码为 <span class="hljs-string">&quot;BZ&quot;</span> <span class="hljs-comment">(2 26)</span>, <span class="hljs-string">&quot;VF&quot;</span> <span class="hljs-comment">(22 6)</span>, 或者 <span class="hljs-string">&quot;BBF&quot;</span> <span class="hljs-comment">(2 2 6)</span> 。</code></pre></blockquote><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> numDecodings(<span class="hljs-keyword">String</span> s) &#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.length() == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> n = s.length();        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始值</span>        <span class="hljs-comment">// 注意第一个元素是0？</span>        dp[<span class="hljs-number">1</span>] = s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;        <span class="hljs-comment">// 注意起始位置，</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;            <span class="hljs-comment">// substring 用的很骚</span>            <span class="hljs-keyword">int</span> one = <span class="hljs-keyword">Integer</span>.valueOf(s.substring(i - <span class="hljs-number">1</span>, i));            <span class="hljs-keyword">if</span> (one != <span class="hljs-number">0</span>) &#123;                dp[i] += dp[i - <span class="hljs-number">1</span>];            &#125;            <span class="hljs-comment">// 注意这个判断</span>            <span class="hljs-keyword">if</span> (s.charAt(i - <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">int</span> two = <span class="hljs-keyword">Integer</span>.valueOf(s.substring(i - <span class="hljs-number">2</span>, i));            <span class="hljs-keyword">if</span> (two &lt;= <span class="hljs-number">26</span>) &#123;                dp[i] += dp[i - <span class="hljs-number">2</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre><h3 id="11-最长上升子序列"><a href="#11-最长上升子序列" class="headerlink" title="11. 最长上升子序列"></a>11. 最长上升子序列</h3><blockquote><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><pre><code class="hljs dns">&gt;输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]&gt;输出：<span class="hljs-number">4</span>&gt;解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。</code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [0,1,0,3,2,3]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：4</span></code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLIS(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;        <span class="hljs-keyword">if</span> (nums.length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">nums</span>.<span class="hljs-identifier">length</span>]</span>;        <span class="hljs-comment">// 注意这个初始化</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>fill(dp, <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;                <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &gt; nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>) &#123;                    <span class="hljs-comment">// 注意if</span>                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, dp<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 关键这里，</span>                &#125;            &#125;        &#125;        <span class="hljs-comment">// 找最大</span>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>stream(dp).max<span class="hljs-literal">()</span>.<span class="hljs-keyword">or</span><span class="hljs-constructor">Else(0)</span>;    &#125;&#125;</code></pre><h3 id="12-最长公共子序列"><a href="#12-最长公共子序列" class="headerlink" title="12. 最长公共子序列"></a>12. 最长公共子序列</h3><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：text1 = <span class="hljs-string">&quot;abcde&quot;</span>, text2 = <span class="hljs-string">&quot;ace&quot;</span></span> <span class="hljs-meta">&gt;</span><span class="bash">输出：3</span>  <span class="hljs-meta">&gt;</span><span class="bash">解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span>，它的长度为 3。</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：text1 = <span class="hljs-string">&quot;abc&quot;</span>, text2 = <span class="hljs-string">&quot;abc&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：3</span><span class="hljs-meta">&gt;</span><span class="bash">解释：最长公共子序列是 <span class="hljs-string">&quot;abc&quot;</span>，它的长度为 3。</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：text1 = <span class="hljs-string">&quot;abc&quot;</span>, text2 = <span class="hljs-string">&quot;def&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：0</span><span class="hljs-meta">&gt;</span><span class="bash">解释：两个字符串没有公共子序列，返回 0。</span></code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> longest<span class="hljs-constructor">CommonSubsequence(String <span class="hljs-params">text1</span>, String <span class="hljs-params">text2</span>)</span> &#123;        <span class="hljs-built_in">int</span> n1 = text1.length<span class="hljs-literal">()</span>, n2 = text2.length<span class="hljs-literal">()</span>;        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span><span class="hljs-literal">[]</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">n1</span> + <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">n2</span> + <span class="hljs-number">1</span>]</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt;= n2; j++) &#123;                <span class="hljs-keyword">if</span> (text1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span> - 1)</span><span class="hljs-operator"> == </span>text2.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span> - 1)</span>) &#123;                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = dp<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span> + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(dp<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>, dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span>);                &#125;            &#125;        &#125;        return dp<span class="hljs-literal">[<span class="hljs-identifier">n1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">n2</span>]</span>;    &#125;&#125;</code></pre><h3 id="15-编辑距离"><a href="#15-编辑距离" class="headerlink" title="15. 编辑距离"></a>15. 编辑距离</h3><blockquote><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：3</span><span class="hljs-meta">&gt;</span><span class="bash">解释：</span><span class="hljs-meta">&gt;</span><span class="bash">horse -&gt; rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)</span><span class="hljs-meta">&gt;</span><span class="bash">rorse -&gt; rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)</span><span class="hljs-meta">&gt;</span><span class="bash">rose -&gt; ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)</span></code></pre><pre><code class="hljs xl">&gt;输入：word1 = <span class="hljs-string">&quot;intention&quot;</span>, word2 = <span class="hljs-string">&quot;execution&quot;</span>&gt;输出：<span class="hljs-number">5</span>&gt;解释：&gt;<span class="hljs-function"><span class="hljs-title">intention</span> -&gt;</span> inention (删除 <span class="hljs-string">&#x27;t&#x27;</span>)&gt;<span class="hljs-function"><span class="hljs-title">inention</span> -&gt;</span> enention (将 <span class="hljs-string">&#x27;i&#x27;</span> 替换为 <span class="hljs-string">&#x27;e&#x27;</span>)&gt;<span class="hljs-function"><span class="hljs-title">enention</span> -&gt;</span> exention (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;x&#x27;</span>)&gt;<span class="hljs-function"><span class="hljs-title">exention</span> -&gt;</span> exection (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;c&#x27;</span>)&gt;<span class="hljs-function"><span class="hljs-title">exection</span> -&gt;</span> execution (插入 <span class="hljs-string">&#x27;u&#x27;</span>)</code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> min<span class="hljs-constructor">Distance(String <span class="hljs-params">word1</span>, String <span class="hljs-params">word2</span>)</span> &#123;        <span class="hljs-keyword">if</span> (word1<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>word2<span class="hljs-operator"> == </span>null) &#123;            return <span class="hljs-number">0</span>;        &#125;        <span class="hljs-built_in">int</span> m = word1.length<span class="hljs-literal">()</span>, n = word2.length<span class="hljs-literal">()</span>;        <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span><span class="hljs-literal">[]</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">m</span> + <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">n</span> + <span class="hljs-number">1</span>]</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;            dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = i;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            dp<span class="hljs-literal">[<span class="hljs-number">0</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = i;        &#125;        <span class="hljs-comment">// 这dp</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;                <span class="hljs-keyword">if</span> (word1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span> - 1)</span><span class="hljs-operator"> == </span>word2.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span> - 1)</span>) &#123;                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = dp<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span>;                &#125; <span class="hljs-keyword">else</span> &#123;                    dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(dp<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span>, dp<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)) + <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        return dp<span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span><span class="hljs-literal">[<span class="hljs-identifier">n</span>]</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串相关算法题</title>
    <link href="/2021/03/18/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/03/18/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-字符串相加"><a href="#1-字符串相加" class="headerlink" title="1. 字符串相加"></a>1. 字符串相加</h3><blockquote><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public String add<span class="hljs-constructor">Strings(String <span class="hljs-params">num1</span>, String <span class="hljs-params">num2</span>)</span> &#123;        StringBuilder str = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder()</span>;        <span class="hljs-comment">// 三个变量 carry i j：倒着来</span>        <span class="hljs-built_in">int</span> carry = <span class="hljs-number">0</span>, i = num1.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>, j = num2.length<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>;        <span class="hljs-comment">// while循环条件 注意｜｜</span>        <span class="hljs-keyword">while</span> (carry<span class="hljs-operator"> == </span><span class="hljs-number">1</span><span class="hljs-operator"> || </span>i &gt;= <span class="hljs-number">0</span><span class="hljs-operator"> || </span>j &gt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 注意&quot;0&quot;</span>            <span class="hljs-built_in">int</span> x = i &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : num1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>--)</span> - <span class="hljs-character">&#x27;0&#x27;</span>;            <span class="hljs-built_in">int</span> y = j &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : num2.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>--)</span> - <span class="hljs-character">&#x27;0&#x27;</span>;            <span class="hljs-comment">// 老生长谈了</span>            <span class="hljs-comment">// 加的时候</span>            str.append((x + y + carry) % <span class="hljs-number">10</span>);            <span class="hljs-comment">// 注意进位</span>            carry = (x + y + carry)<span class="hljs-operator"> / </span><span class="hljs-number">10</span>;         &#125;        <span class="hljs-comment">// 别忘了反转</span>        <span class="hljs-comment">// 反转</span>        return str.reverse<span class="hljs-literal">()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;    &#125;&#125;</code></pre><h3 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h3><blockquote><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><pre><code class="hljs gcode">&gt;输入: <span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;456&quot;</span>&gt;输出: <span class="hljs-string">&quot;56088&quot;</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">String</span> num1, <span class="hljs-keyword">String</span> num2)</span> </span>&#123;        <span class="hljs-keyword">int</span> len1 = num1.length();        <span class="hljs-keyword">int</span> len2 = num2.length();        <span class="hljs-keyword">if</span> (len1 == <span class="hljs-number">0</span> || len2 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;        <span class="hljs-keyword">int</span>[] mul = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len1 + len2];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = len1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = len2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;                <span class="hljs-keyword">int</span> n = (num1.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>) * (num2.charAt(j) - <span class="hljs-string">&#x27;0&#x27;</span>) + mul[i + j + <span class="hljs-number">1</span>];                mul[i + j + <span class="hljs-number">1</span>] = n % <span class="hljs-number">10</span>;                mul[i + j] += n / <span class="hljs-number">10</span>;            &#125;        &#125;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (i &lt; len1 + len2 - <span class="hljs-number">1</span> &amp;&amp; mul[i] == <span class="hljs-number">0</span>) i++;        <span class="hljs-keyword">while</span> (i &lt; len1 + len2) sb.append(mul[i++]);        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre><h3 id="2-反转字符串-660"><a href="#2-反转字符串-660" class="headerlink" title="2. 反转字符串(660)"></a>2. 反转字符串(660)</h3><blockquote><p>写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><pre><code class="hljs css">&gt;输入：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>]</span>&gt;输出：<span class="hljs-selector-attr">[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>]</span></code></pre><pre><code class="hljs smalltalk">&gt;输入：[<span class="hljs-comment">&quot;H&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;n&quot;</span>,<span class="hljs-comment">&quot;n&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;h&quot;</span>]&gt;输出：[<span class="hljs-comment">&quot;h&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;n&quot;</span>,<span class="hljs-comment">&quot;n&quot;</span>,<span class="hljs-comment">&quot;a&quot;</span>,<span class="hljs-comment">&quot;H&quot;</span>]</code></pre></blockquote><pre><code class="hljs cpp"><span class="hljs-comment">// 利用while反转交换</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s)</span> </span>&#123;        <span class="hljs-keyword">int</span> p1 = <span class="hljs-number">0</span>, p2 = s.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(p1 &lt; p2)&#123;            swap(s, p1++, p2--);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;        <span class="hljs-keyword">char</span> temp = s[i];        s[i] = s[j];        s[j] = temp;    &#125;&#125;</code></pre><h3 id="3-无重复字符的最长子串-2862"><a href="#3-无重复字符的最长子串-2862" class="headerlink" title="3. 无重复字符的最长子串(2862)"></a>3. 无重复字符的最长子串(2862)</h3><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: s = <span class="hljs-string">&quot;abcabcbb&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出: 3</span> <span class="hljs-meta">&gt;</span><span class="bash">解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;abc&quot;</span>，所以其长度为 3。</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: s = <span class="hljs-string">&quot;bbbbb&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出: 1</span><span class="hljs-meta">&gt;</span><span class="bash">解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;b&quot;</span>，所以其长度为 1。</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: s = <span class="hljs-string">&quot;pwwkew&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出: 3</span><span class="hljs-meta">&gt;</span><span class="bash">解释: 因为无重复字符的最长子串是 <span class="hljs-string">&quot;wke&quot;</span>，所以其长度为 3。</span>    请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLongestSubstring(String <span class="hljs-params">s</span>)</span> &#123;        <span class="hljs-built_in">int</span> n = s.length<span class="hljs-literal">()</span>, ans = <span class="hljs-number">0</span>;        <span class="hljs-comment">// map 加双指针。map来保留索引，类似于滑动窗</span>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span> (map.contains<span class="hljs-constructor">Key(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">j</span>)</span>)) &#123;                i = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(map.get(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>), i);            &#125;            ans = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(ans, j - i + <span class="hljs-number">1</span>);            map.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>, j + <span class="hljs-number">1</span>);        &#125;        return ans;    &#125;&#125;</code></pre><h3 id="4-1、左旋转字符串"><a href="#4-1、左旋转字符串" class="headerlink" title="4.1、左旋转字符串"></a>4.1、<a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=3&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">左旋转字符串</a></h3><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">&quot;abcXYZdef&quot;</span>,3</span><span class="hljs-meta">&gt;</span><span class="bash">返回值</span><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">&quot;XYZdefabc&quot;</span></span></code></pre></blockquote><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> LeftRotateString(<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span> n) &#123;    <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-built_in">str</span>.length())        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>;    <span class="hljs-built_in">char</span>[] chars = <span class="hljs-built_in">str</span>.toCharArray();    <span class="hljs-comment">// 分三步反转</span>    <span class="hljs-comment">// 1. n之前反转</span>    <span class="hljs-built_in">reverse</span>(chars, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 2. n之后反转</span>    <span class="hljs-built_in">reverse</span>(chars, n, chars.length - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 3. 全部反转</span>    <span class="hljs-built_in">reverse</span>(chars, <span class="hljs-number">0</span>, chars.length - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(chars);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">char</span>[] chars, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;    <span class="hljs-keyword">while</span> (i &lt; j)        swap(chars, i++, j--);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> swap(<span class="hljs-built_in">char</span>[] chars, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;    <span class="hljs-built_in">char</span> t = chars[i];    chars[i] = chars[j];    chars[j] = t;&#125;</code></pre><h3 id="4-2、翻转单词顺序列"><a href="#4-2、翻转单词顺序列" class="headerlink" title="4.2、翻转单词顺序列"></a>4.2、<a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=3&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">翻转单词顺序列</a></h3><blockquote><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">&quot;nowcoder. a am I&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">返回值</span><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">&quot;I am a nowcoder.&quot;</span></span></code></pre></blockquote><p>正确的解法应该是和书上一样，先旋转每个单词，再旋转整个字符串。</p><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> ReverseSentence(<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>) &#123;    <span class="hljs-built_in">int</span> n = <span class="hljs-built_in">str</span>.length();    <span class="hljs-built_in">char</span>[] chars = <span class="hljs-built_in">str</span>.toCharArray();    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 双指针，滑窗，，注意边界。</span>    <span class="hljs-keyword">while</span> (j &lt;= n) &#123;        <span class="hljs-comment">// 关键是这个判断边界</span>        <span class="hljs-keyword">if</span> (j == n || chars[j] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;            <span class="hljs-comment">// 反转</span>            <span class="hljs-built_in">reverse</span>(chars, i, j - <span class="hljs-number">1</span>);            <span class="hljs-comment">// 下个单词的索引开头</span>            i = j + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 继续走</span>        j++;    &#125;    <span class="hljs-comment">// 全反转</span>    <span class="hljs-built_in">reverse</span>(chars, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(chars);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">char</span>[] c, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;    <span class="hljs-keyword">while</span> (i &lt; j)        swap(c, i++, j--);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> swap(<span class="hljs-built_in">char</span>[] c, <span class="hljs-built_in">int</span> i, <span class="hljs-built_in">int</span> j) &#123;    <span class="hljs-built_in">char</span> t = c[i];    c[i] = c[j];    c[j] = t;&#125;</code></pre><h3 id="5、把字符串转成整数"><a href="#5、把字符串转成整数" class="headerlink" title="5、把字符串转成整数"></a>5、<a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=3&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">把字符串转成整数</a></h3><blockquote><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">&quot;+2147483647&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">返回值</span><span class="hljs-meta">&gt;</span><span class="bash">2147483647</span></code></pre></blockquote><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T49</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> StrToInt(String <span class="hljs-built_in">str</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">str</span> == <span class="hljs-literal">null</span> || <span class="hljs-built_in">str</span>.length() == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// 注意第一个字符是否是-</span>        <span class="hljs-built_in">boolean</span> isNegative = <span class="hljs-built_in">str</span>.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;-&#x27;</span>;        <span class="hljs-built_in">int</span> ret = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">str</span>.length(); i++) &#123;            <span class="hljs-built_in">char</span> c = <span class="hljs-built_in">str</span>.charAt(i);            <span class="hljs-comment">// 跳过第一个字符</span>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; (c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span>))  <span class="hljs-comment">/* 符号判定 */</span>                <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// 防止非法输入</span>            <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>)                <span class="hljs-comment">/* 非法输入 */</span>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            <span class="hljs-comment">// 正常操作，注意“0”</span>            ret = ret * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);        &#125;        <span class="hljs-keyword">return</span> isNegative ? -ret : ret;    &#125;&#125;</code></pre><h3 id="5-最长回文子串-1478"><a href="#5-最长回文子串-1478" class="headerlink" title="5. 最长回文子串(1478)"></a>5. 最长回文子串(1478)</h3><blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;babad&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：<span class="hljs-string">&quot;bab&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">解释：<span class="hljs-string">&quot;aba&quot;</span> 同样是符合题意的答案。</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;cbbd&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：<span class="hljs-string">&quot;bb&quot;</span></span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;ac&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：<span class="hljs-string">&quot;a&quot;</span></span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：s = <span class="hljs-string">&quot;a&quot;</span></span><span class="hljs-meta">&gt;</span><span class="bash">输出：<span class="hljs-string">&quot;a&quot;</span></span></code></pre></blockquote><p>中心扩展</p><ul><li>两种情况</li><li>奇数长度</li><li>偶数长度</li><li>取最长，求起始和结束位置</li><li>用substring即可</li></ul><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == null || s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, <span class="hljs-built_in">end</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录起始位置</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;            <span class="hljs-comment">// 两种情况 以i为中心，以i和i+1为中心</span>            <span class="hljs-keyword">int</span> len1 = expand(s, i - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 中心扩展 </span>            <span class="hljs-keyword">int</span> len2 = expand(s, i, i + <span class="hljs-number">1</span>);            <span class="hljs-keyword">int</span> len = Math.<span class="hljs-built_in">max</span>(len1, len2); <span class="hljs-comment">// 取最长的长度</span>            <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-built_in">end</span> - start) &#123;                start = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;                <span class="hljs-built_in">end</span> = i + len / <span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> s.substring(start, <span class="hljs-built_in">end</span> + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;        <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;            l--;            r++;        &#125;        <span class="hljs-comment">// 这里要注意</span>        <span class="hljs-keyword">return</span> r - l - <span class="hljs-number">1</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组相关算法题</title>
    <link href="/2021/03/17/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/03/17/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h3><blockquote><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入: nums = [1,2,3,4,5,6,7], k = 3</span><span class="hljs-meta">&gt;</span><span class="bash">输出: [5,6,7,1,2,3,4]</span><span class="hljs-meta">&gt;</span><span class="bash">解释:</span><span class="hljs-meta">&gt;</span><span class="bash">向右旋转 1 步: [7,1,2,3,4,5,6]</span><span class="hljs-meta">&gt;</span><span class="bash">向右旋转 2 步: [6,7,1,2,3,4,5]</span><span class="hljs-meta">&gt;</span><span class="bash">向右旋转 3 步: [5,6,7,1,2,3,4]</span></code></pre><pre><code class="hljs subunit">&gt;输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3,99], k = 2&gt;输出：[3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]&gt;解释: &gt;向右旋转 1 步: [99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3]&gt;向右旋转 2 步: [3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]</code></pre></blockquote><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> rotate(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> k) &#123;        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span>;        <span class="hljs-built_in">int</span> n = nums.length;        k %= n;        <span class="hljs-keyword">reverse</span>(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);        <span class="hljs-keyword">reverse</span>(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);        <span class="hljs-keyword">reverse</span>(nums, k, n - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">reverse</span>(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> l, <span class="hljs-built_in">int</span> r) &#123;        <span class="hljs-keyword">while</span> (l &lt; r)&#123;            <span class="hljs-built_in">int</span> t = nums[l];            nums[l++] = nums[r];            nums[r--] = t;        &#125;    &#125;&#125;</code></pre><h3 id="1-搜索旋转排序数组"><a href="#1-搜索旋转排序数组" class="headerlink" title="1. 搜索旋转排序数组"></a>1. 搜索旋转排序数组</h3><blockquote><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。</p><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">0</span>&gt;输出：<span class="hljs-number">4</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">3</span>&gt;输出：-<span class="hljs-number">1</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">0</span>&gt;输出：-<span class="hljs-number">1</span></code></pre></blockquote><p>思路：如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了</p><pre><code class="hljs excel">class Solution &#123;    public <span class="hljs-built_in">int</span> <span class="hljs-built_in">search</span>(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target) &#123;        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = nums.length;        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = <span class="hljs-built_in">len</span> - <span class="hljs-number">1</span>;        while (<span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span>) &#123;            <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>;            <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] == target)                return <span class="hljs-built_in">mid</span>;            else <span class="hljs-built_in">if</span>(nums[<span class="hljs-built_in">mid</span>] &lt; nums[<span class="hljs-built_in">right</span>]) &#123;                // 注意边界                <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &lt; target &amp;&amp; target &lt;= nums[<span class="hljs-built_in">right</span>])                    <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;                else                     <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;            &#125; else &#123;                // 注意边界                <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">left</span>] &lt;= target &amp;&amp; target &lt; nums[<span class="hljs-built_in">mid</span>])                    <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;                else                     <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;            &#125;        &#125;        return -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h3 id="2-两数之和-4897"><a href="#2-两数之和-4897" class="headerlink" title="2. 两数之和(4897)"></a>2. 两数之和(4897)</h3><blockquote><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>你可以按任意顺序返回答案。</p><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9&gt;输出：<span class="hljs-comment">[0,1]</span>&gt;解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。</code></pre><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6&gt;输出：<span class="hljs-comment">[1,2]</span></code></pre><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6&gt;输出：<span class="hljs-comment">[0,1]</span></code></pre></blockquote><pre><code class="hljs axapta"><span class="hljs-comment">// 双指针</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] twoSum(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target) &#123;        <span class="hljs-built_in">int</span> p1 = <span class="hljs-number">0</span>, p2 = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (p1 &lt; p2) &#123;            <span class="hljs-built_in">int</span> <span class="hljs-keyword">sum</span> = nums[p1] + nums[p2];            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> &lt; target) p1++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sum</span> &gt; target) p2--;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123;p1, p2&#125;;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;&#125;;    &#125;&#125;</code></pre><h3 id="3-三数之和"><a href="#3-三数之和" class="headerlink" title="3. 三数之和"></a>3. 三数之和</h3><blockquote><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<strong>注意：</strong>答案中不可以包含重复的三元组。</p><pre><code class="hljs subunit">&gt;输入：nums = [<span class="hljs-string">-1</span>,0,1,2,<span class="hljs-string">-1</span>,<span class="hljs-string">-4</span>]&gt;输出：[[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,2],[<span class="hljs-string">-1</span>,0,1]]</code></pre><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[]</span>&gt;输出：<span class="hljs-comment">[]</span></code></pre><pre><code class="hljs inform7">&gt;输入：nums = <span class="hljs-comment">[0]</span>&gt;输出：<span class="hljs-comment">[]</span></code></pre></blockquote><pre><code class="hljs reasonml">排序过后的双指针，注意重复<span class="hljs-keyword">class</span> Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; three<span class="hljs-constructor">Sum(<span class="hljs-params">int</span>[] <span class="hljs-params">nums</span>)</span> &#123;        <span class="hljs-comment">// 排序</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>sort(nums);        List&lt;List&lt;Integer&gt;&gt; ls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;            <span class="hljs-comment">// 判断是否元素大于0,大于0，没必要操作了</span>            <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &gt; <span class="hljs-number">0</span>)                 break;             <span class="hljs-comment">// 判断是否重复</span>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">i</span> - <span class="hljs-number">1</span>]</span>)                 continue;            <span class="hljs-comment">// 双指针操作</span>            <span class="hljs-built_in">int</span> l = i + <span class="hljs-number">1</span>, r = nums.length - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (l &lt; r) &#123;                <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> + nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span> &lt; -nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) l++;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span> + nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span> &gt; -nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) r--;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 相等了哈</span>                    ls.add(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">nums</span>[<span class="hljs-params">i</span>], <span class="hljs-params">nums</span>[<span class="hljs-params">l</span>], <span class="hljs-params">nums</span>[<span class="hljs-params">r</span>])</span>);                    <span class="hljs-comment">// 防止重复</span>                    <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">l</span> + <span class="hljs-number">1</span>]</span>) l++;                    <span class="hljs-keyword">while</span> (l &lt; r<span class="hljs-operator"> &amp;&amp; </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span>]</span><span class="hljs-operator"> == </span>nums<span class="hljs-literal">[<span class="hljs-identifier">r</span> - <span class="hljs-number">1</span>]</span>) r--;                    l++;                    r--;                &#125;            &#125;        &#125;        return ls;    &#125;&#125;</code></pre><h3 id="5、顺时针打印矩阵"><a href="#5、顺时针打印矩阵" class="headerlink" title="5、顺时针打印矩阵"></a>5、<a href="https://github.com/www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">顺时针打印矩阵</a></h3><p>跟lc的螺旋矩阵一样</p><pre><code class="hljs armasm"><span class="hljs-symbol">public</span> class T19 &#123;    public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;()<span class="hljs-comment">;</span>        int <span class="hljs-built_in">r1</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">r2</span> = matrix.length - <span class="hljs-number">1</span>, <span class="hljs-built_in">c1</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">c2</span> = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span><span class="hljs-comment">;</span>        <span class="hljs-meta">while</span>(<span class="hljs-built_in">r1</span> &lt;= <span class="hljs-built_in">r2</span> &amp;&amp; <span class="hljs-built_in">c1</span> &lt;= <span class="hljs-built_in">c2</span>) &#123;            for (int i = <span class="hljs-built_in">c1</span><span class="hljs-comment">; i &lt;= c2; i++) &#123;</span>                list.add(matrix[<span class="hljs-built_in">r1</span>][i])<span class="hljs-comment">;</span>            &#125;            for (int i = <span class="hljs-built_in">r1</span> + <span class="hljs-number">1</span><span class="hljs-comment">; i &lt;= r2; i++) &#123;</span>                list.add(matrix[i][<span class="hljs-built_in">c2</span>])<span class="hljs-comment">;</span>            &#125;            <span class="hljs-comment">// 注意边界</span>            <span class="hljs-meta">if</span> (<span class="hljs-built_in">r1</span> != <span class="hljs-built_in">r2</span>) &#123;                for (int i = <span class="hljs-built_in">c2</span> - <span class="hljs-number">1</span><span class="hljs-comment">; i &gt;= c1; i--) &#123;</span>                    list.add(matrix[<span class="hljs-built_in">r2</span>][i])<span class="hljs-comment">;</span>                &#125;            &#125;            <span class="hljs-comment">// 注意边界</span>            <span class="hljs-meta">if</span> (<span class="hljs-built_in">c1</span> != <span class="hljs-built_in">c2</span>) &#123;                for (int i = <span class="hljs-built_in">r2</span> - <span class="hljs-number">1</span><span class="hljs-comment">; i &gt;= r1; i--) &#123;</span>                    list.add(matrix[i][<span class="hljs-built_in">c1</span>])<span class="hljs-comment">;</span>                &#125;            &#125;            <span class="hljs-built_in">r1</span>++<span class="hljs-comment">; r2--; c1++; c2--;</span>        &#125;        return list<span class="hljs-comment">;</span>    &#125;&#125;</code></pre><h3 id="6-缺失的第一个正数"><a href="#6-缺失的第一个正数" class="headerlink" title="6. 缺失的第一个正数"></a>6. 缺失的第一个正数</h3><blockquote><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [1,2,0]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：3</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [3,4,-1,1]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：2</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：nums = [7,8,9,11,12]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：1</span></code></pre></blockquote><p>采用排序的犯规操作</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> firstMissingPositive(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-built_in">int</span> ans = <span class="hljs-number">1</span>;        <span class="hljs-comment">// 犯规操作</span>        Arrays.sort(nums);        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] &gt; ans) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span> (nums[i] == ans) ans++;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre><h3 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a>448. 找到所有数组中消失的数字</h3><blockquote><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入:</span><span class="hljs-meta">&gt;</span><span class="bash">[4,3,2,7,8,2,3,1]</span><span class="hljs-meta">&gt;</span><span class="bash">输出:</span><span class="hljs-meta">&gt;</span><span class="bash">[5,6]</span></code></pre></blockquote><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 【笔记】将所有正数作为数组下标，置对应数组值为负值。那么，仍为正数的位置即为（未出现过）消失的数字。</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 举个例子：</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 原始数组：[4,3,2,7,8,2,3,1]</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 重置后为：[-4,-3,-2,-7,8,2,-3,-1]</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 结论：[8,2] 分别对应的index为[5,6]（消失的数字）</span><span class="hljs-comment"> */</span> <span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-built_in">public</span> List&lt;<span class="hljs-type">Integer</span>&gt; findDisappearedNumbers(<span class="hljs-type">int</span>[] nums) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">Integer</span> num : nums) &#123;            nums[Math.abs(num) - <span class="hljs-number">1</span>] = -Math.abs(nums[Math.abs(num) - <span class="hljs-number">1</span>]);        &#125;        List&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)                list.<span class="hljs-keyword">add</span>(i + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list.toString());        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><h3 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a>560. 和为K的子数组</h3><blockquote><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p><pre><code class="hljs inform7">&gt;输入:nums = <span class="hljs-comment">[1,1,1]</span>, k = 2&gt;输出: 2 , <span class="hljs-comment">[1,1]</span> 与 <span class="hljs-comment">[1,1]</span> 为两种不同的情况。</code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">    扫描一遍数组, 使用map记录出现同样的和的次数, 对每个i计算累计和sum并判断map内是否有sum-k</span><span class="hljs-comment">    **/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        Map&lt;Integer, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, ret = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            sum += nums[i];            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>.containsKey(sum - k))                ret += <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(sum - k);            <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(sum, <span class="hljs-built_in">map</span>.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h3><blockquote><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><pre><code class="hljs prolog">&gt;输入：intervals = [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]&gt;输出：[[<span class="hljs-number">1</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">18</span>]]&gt;解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>] 重叠, 将它们合并为 [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>].</code></pre><pre><code class="hljs lua">&gt;输入：intervals = <span class="hljs-string">[[1,4],[4,5]]</span>&gt;输出：<span class="hljs-string">[[1,5]]</span>&gt;解释：区间 [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>] 和 [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>] 可被视为重叠区间。</code></pre></blockquote><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[][] merge(<span class="hljs-built_in">int</span>[][] <span class="hljs-built_in">int</span>ervals) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>ervals == <span class="hljs-literal">null</span> || <span class="hljs-built_in">int</span>ervals.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ervals;        Arrays.sort(<span class="hljs-built_in">int</span>ervals, (a, b) -&gt; a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]);        List&lt;<span class="hljs-built_in">int</span>[]&gt; list = new ArrayList&lt;&gt;();        <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> n = <span class="hljs-built_in">int</span>ervals.length;        <span class="hljs-keyword">while</span> (i &lt; n) &#123;            <span class="hljs-built_in">int</span> l = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">0</span>];            <span class="hljs-built_in">int</span> r = <span class="hljs-built_in">int</span>ervals[i][<span class="hljs-number">1</span>];            <span class="hljs-keyword">while</span> (i &lt; n - <span class="hljs-number">1</span> &amp;&amp; r &gt;= <span class="hljs-built_in">int</span>ervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) &#123;                r = Math.max(r, <span class="hljs-built_in">int</span>ervals[i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);                i++;            &#125;            list.add(new <span class="hljs-built_in">int</span>[] &#123;l, r&#125;);            i++;        &#125;        <span class="hljs-keyword">return</span> list.toArray(new <span class="hljs-built_in">int</span>[list.size()][<span class="hljs-number">2</span>]);    &#125;&#125;</code></pre><h3 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h3><blockquote><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p><p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,5,4,7]</span>输出：3解释：最长连续递增序列是 <span class="hljs-comment">[1,3,5]</span>, 长度为3。尽管 <span class="hljs-comment">[1,3,5,7]</span> 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</code></pre><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,2,2,2,2]</span>输出：1解释：最长连续递增序列是 <span class="hljs-comment">[2]</span>, 长度为1。</code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums == null || nums.length == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>])                <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(i - d + <span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>);            <span class="hljs-keyword">else</span>                d = i;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;    &#125;&#125;</code></pre><h3 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986. 区间列表的交集"></a>986. 区间列表的交集</h3><blockquote><p>给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对 不相交 的，并且 已经排序 。</p><p>返回这 两个区间列表的交集 。</p><p>形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b 。</p><p>两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。</p><pre><code class="hljs inform7">&gt;输入：firstList = <span class="hljs-comment">[<span class="hljs-comment">[0,2]</span>,<span class="hljs-comment">[5,10]</span>,<span class="hljs-comment">[13,23]</span>,<span class="hljs-comment">[24,25]</span>]</span>, secondList = <span class="hljs-comment">[<span class="hljs-comment">[1,5]</span>,<span class="hljs-comment">[8,12]</span>,<span class="hljs-comment">[15,24]</span>,<span class="hljs-comment">[25,26]</span>]</span>&gt;输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[5,5]</span>,<span class="hljs-comment">[8,10]</span>,<span class="hljs-comment">[15,23]</span>,<span class="hljs-comment">[24,24]</span>,<span class="hljs-comment">[25,25]</span>]</span></code></pre><pre><code class="hljs inform7">&gt;输入：firstList = <span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[5,9]</span>]</span>, secondList = <span class="hljs-comment">[]</span>&gt;输出：<span class="hljs-comment">[]</span></code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span><span class="hljs-literal">[]</span> interval<span class="hljs-constructor">Intersection(<span class="hljs-params">int</span>[][] A, <span class="hljs-params">int</span>[][] B)</span> &#123;        List&lt;<span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>length<span class="hljs-operator"> &amp;&amp; </span>j &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">B</span>.</span></span>length;) &#123;            <span class="hljs-built_in">int</span> l = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(A<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>, B<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-literal">[<span class="hljs-number">0</span>]</span>);            <span class="hljs-built_in">int</span> r = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(A<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span>, B<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span>);            <span class="hljs-keyword">if</span> (l &lt; r)                <span class="hljs-built_in">list</span>.add(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;l, r&#125;);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l<span class="hljs-operator"> == </span>r)                <span class="hljs-built_in">list</span>.add(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> &#123;l, l&#125;);            <span class="hljs-keyword">if</span> (A<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span> &lt; B<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span>)                i++;            <span class="hljs-keyword">else</span>                 j++;        &#125;        return <span class="hljs-built_in">list</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">Array(<span class="hljs-params">new</span> <span class="hljs-params">int</span>[<span class="hljs-params">list</span>.<span class="hljs-params">size</span>()</span>]<span class="hljs-literal">[]</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>需要熟练的树算法题</title>
    <link href="/2021/03/17/%E9%9C%80%E8%A6%81%E7%86%9F%E7%BB%83%E7%9A%84%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/03/17/%E9%9C%80%E8%A6%81%E7%86%9F%E7%BB%83%E7%9A%84%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1、重建二叉树"><a href="#1、重建二叉树" class="headerlink" title="1、重建二叉树"></a>1、<a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">重建二叉树</a></h3><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">前序遍历 preorder = [3,9,20,15,7]</span><span class="hljs-meta">&gt;</span><span class="bash">中序遍历 inorder = [9,3,15,20,7]</span><span class="hljs-meta">&gt;</span><span class="bash">返回：</span>   3  / \ 9  20   /  \  15   7</code></pre></blockquote><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;        <span class="hljs-keyword">int</span> n = preorder.length;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> rootVal = preorder[<span class="hljs-number">0</span>], rootIndex = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 找中序根的索引</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (inorder[i] == rootVal) &#123;                rootIndex = i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(rootVal);        <span class="hljs-comment">// 注意边界</span>        <span class="hljs-comment">// left</span>        root.left = buildTree(            Arrays.copyOfRange(preorder, <span class="hljs-number">1</span>, <span class="hljs-number">1</span> + rootIndex),             Arrays.copyOfRange(inorder, <span class="hljs-number">0</span>, rootIndex));        <span class="hljs-comment">// right</span>        root.right = buildTree(            Arrays.copyOfRange(preorder, <span class="hljs-number">1</span> + rootIndex, n),             Arrays.copyOfRange(inorder, <span class="hljs-number">1</span> + rootIndex, n));        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><h3 id="2、二叉树的下一个结点"><a href="#2、二叉树的下一个结点" class="headerlink" title="2、二叉树的下一个结点"></a>2、<a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=3&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉树的下一个结点</a></h3><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p></blockquote><pre><code class="hljs typescript"><span class="hljs-comment">// 中序</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T57</span> </span>&#123;    <span class="hljs-keyword">public</span> TreeLinkNode <span class="hljs-function"><span class="hljs-title">GetNext</span>(<span class="hljs-params">TreeLinkNode pNode</span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == pNode) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">// 两种情况</span>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != pNode.right) &#123;            TreeLinkNode node = pNode.right;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> != node.left) &#123;                node = node.left;            &#125;            <span class="hljs-keyword">return</span> node;        &#125;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> != pNode.next) &#123;            TreeLinkNode parent = pNode.next;            <span class="hljs-keyword">if</span> (parent.left == pNode) &#123;                <span class="hljs-keyword">return</span> parent;            &#125;            pNode = pNode.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre><h3 id="3、树的子结构"><a href="#3、树的子结构" class="headerlink" title="3、树的子结构"></a>3、<a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">树的子结构</a></h3><blockquote><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">给定的树 A:</span>    3   / \  4   5 / \1   2<span class="hljs-meta">&gt;</span><span class="bash">给定的树 B：</span>  4  /1<span class="hljs-meta">&gt;</span><span class="bash">返回 <span class="hljs-literal">true</span>，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]&gt;输出：<span class="hljs-literal">false</span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">A</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">B</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]&gt;输出：<span class="hljs-literal">true</span></code></pre></blockquote><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> T17 &#123;public boolean <span class="hljs-constructor">HasSubtree(TreeNode <span class="hljs-params">root1</span>, TreeNode <span class="hljs-params">root2</span>)</span> &#123;        <span class="hljs-keyword">if</span> (root1<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>root2<span class="hljs-operator"> == </span>null)            return <span class="hljs-literal">false</span>;        return is<span class="hljs-constructor">SubtreeWithRoot(<span class="hljs-params">root1</span>, <span class="hljs-params">root2</span>)</span><span class="hljs-operator"> || </span><span class="hljs-constructor">HasSubtree(<span class="hljs-params">root1</span>.<span class="hljs-params">left</span>, <span class="hljs-params">root2</span>)</span><span class="hljs-operator"> || </span><span class="hljs-constructor">HasSubtree(<span class="hljs-params">root1</span>.<span class="hljs-params">right</span>, <span class="hljs-params">root2</span>)</span>;&#125;    <span class="hljs-keyword">private</span> boolean is<span class="hljs-constructor">SubtreeWithRoot(TreeNode <span class="hljs-params">root1</span>, TreeNode <span class="hljs-params">root2</span>)</span> &#123;        <span class="hljs-keyword">if</span> (root2<span class="hljs-operator"> == </span>null)            return <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (root1<span class="hljs-operator"> == </span>null)            return <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (root1.<span class="hljs-keyword">val</span> != root2.<span class="hljs-keyword">val</span>)            return <span class="hljs-literal">false</span>;        return is<span class="hljs-constructor">SubtreeWithRoot(<span class="hljs-params">root1</span>.<span class="hljs-params">left</span>, <span class="hljs-params">root2</span>.<span class="hljs-params">left</span>)</span><span class="hljs-operator"> &amp;&amp; </span>is<span class="hljs-constructor">SubtreeWithRoot(<span class="hljs-params">root1</span>.<span class="hljs-params">right</span>, <span class="hljs-params">root2</span>.<span class="hljs-params">right</span>)</span>;&#125;&#125;</code></pre><h3 id="3、二叉树的镜像"><a href="#3、二叉树的镜像" class="headerlink" title="3、二叉树的镜像"></a>3、<a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉树的镜像</a></h3><blockquote><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><pre><code class="hljs livescript">&gt;例如输入：    <span class="hljs-number">4</span>  /   <span class="hljs-string">\</span> <span class="hljs-number">2</span>     <span class="hljs-number">7</span>/ <span class="hljs-string">\</span>   / <span class="hljs-string">\</span>&gt;<span class="hljs-number">1</span>   <span class="hljs-number">3</span> <span class="hljs-number">6</span>   <span class="hljs-number">9</span>&gt;镜像输出：    <span class="hljs-number">4</span>  /   <span class="hljs-string">\</span> <span class="hljs-number">7</span>     <span class="hljs-number">2</span>/ <span class="hljs-string">\</span>   / <span class="hljs-string">\</span>&gt;<span class="hljs-number">9</span>   <span class="hljs-number">6</span> <span class="hljs-number">3</span>   <span class="hljs-number">1</span></code></pre><pre><code class="hljs accesslog">&gt;输入：root = <span class="hljs-string">[4,2,7,1,3,6,9]</span>&gt;输出：<span class="hljs-string">[4,7,2,9,6,3,1]</span></code></pre></blockquote><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T18</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">Mirror</span>(<span class="hljs-params">TreeNode root</span>)</span> &#123;        <span class="hljs-comment">// 判断</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;        swap(root);        Mirror(root.left);        Mirror(root.right);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">TreeNode root</span>)</span> &#123;        TreeNode t = root.left;        root.left = root.right;        root.right = t;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-function"><span class="hljs-title">mirrorTree</span>(<span class="hljs-params">TreeNode root</span>)</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.add(root);        TreeNode cur;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            cur = queue.poll();            <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-literal">null</span>) queue.add(cur.left);            <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) queue.add(cur.right);            swap(cur);        &#125;        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">swap</span>(<span class="hljs-params">TreeNode root</span>)</span> &#123;        TreeNode t = root.left;        root.left = root.right;        root.right = t;    &#125;&#125;</code></pre><h3 id="4、对称的二叉树"><a href="#4、对称的二叉树" class="headerlink" title="4、对称的二叉树"></a>4、<a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=3&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">对称的二叉树</a></h3><blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><pre><code class="hljs livescript">&gt;例如，二叉树 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>] 是对称的。   <span class="hljs-number">1</span>  / <span class="hljs-string">\</span> <span class="hljs-number">2</span>   <span class="hljs-number">2</span>/ <span class="hljs-string">\</span> / <span class="hljs-string">\</span>&gt;<span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span>&gt;但是下面这个 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>] 则不是镜像对称的:   <span class="hljs-number">1</span>  / <span class="hljs-string">\</span> <span class="hljs-number">2</span>   <span class="hljs-number">2</span>  <span class="hljs-string">\</span>   <span class="hljs-string">\</span>  <span class="hljs-number">3</span>    <span class="hljs-number">3</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：root = [1,2,2,3,4,4,3]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：<span class="hljs-literal">true</span></span></code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]&gt;输出：<span class="hljs-literal">false</span></code></pre></blockquote><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T58</span> </span>&#123;    boolean isSymmetrical(<span class="hljs-type">TreeNode</span> pRoot) &#123;        <span class="hljs-keyword">if</span> (null == pRoot) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> comRoot(pRoot.<span class="hljs-keyword">left</span>, pRoot.<span class="hljs-keyword">right</span>);    &#125;    <span class="hljs-keyword">private</span> boolean comRoot(<span class="hljs-type">TreeNode</span> <span class="hljs-keyword">left</span>, <span class="hljs-type">TreeNode</span> <span class="hljs-keyword">right</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">left</span> == null &amp;&amp; <span class="hljs-keyword">right</span> == null) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">left</span> == null || <span class="hljs-keyword">right</span> == null) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">left</span>.val != <span class="hljs-keyword">right</span>.val) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;<span class="hljs-comment">// 左右对比</span>        <span class="hljs-keyword">return</span> comRoot(<span class="hljs-keyword">left</span>.<span class="hljs-keyword">right</span>, <span class="hljs-keyword">right</span>.<span class="hljs-keyword">left</span>) &amp;&amp; comRoot(<span class="hljs-keyword">left</span>.<span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>.<span class="hljs-keyword">right</span>);    &#125;&#125;</code></pre><h3 id="5-1、从上往下打印二叉树"><a href="#5-1、从上往下打印二叉树" class="headerlink" title="5.1、从上往下打印二叉树"></a>5.1、<a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=2&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">从上往下打印二叉树</a></h3><blockquote><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><pre><code class="hljs livescript">&gt;如:&gt;给定二叉树: [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>],   <span class="hljs-number">3</span>  / <span class="hljs-string">\</span> <span class="hljs-number">9</span>  <span class="hljs-number">20</span>   /  <span class="hljs-string">\</span>  <span class="hljs-number">15</span>   <span class="hljs-number">7</span>&gt;返回：&gt;[<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]</code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T22</span> &#123;</span>    <span class="hljs-comment">// 层序遍历 </span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        ArrayList&lt;Integer&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 需要用到队列</span>        LinkedList&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-built_in">queue</span>.offer(root); <span class="hljs-comment">// 第一次先加根入队</span>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">queue</span>.isEmpty()) &#123;            <span class="hljs-keyword">int</span> cnt = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();            <span class="hljs-comment">// 如果队列不为空的话， 队列出一个元素</span>            <span class="hljs-keyword">while</span>(cnt-- &gt; <span class="hljs-number">0</span>) &#123;                TreeNode t = <span class="hljs-built_in">queue</span>.poll();                <span class="hljs-keyword">if</span> (t == null) <span class="hljs-keyword">continue</span>;                <span class="hljs-built_in">list</span>.add(t.val);                <span class="hljs-built_in">queue</span>.add(t.left);                <span class="hljs-built_in">queue</span>.add(t.right);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;    &#125;&#125;</code></pre><h3 id="5-2、把二叉树打印多行"><a href="#5-2、把二叉树打印多行" class="headerlink" title="5.2、把二叉树打印多行"></a>5.2、<a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=3&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">把二叉树打印多行</a></h3><blockquote><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><pre><code class="hljs lua">&gt;输入&gt;&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;&gt;返回值&gt;<span class="hljs-string">[[8],[6,10],[5,7,9,11]]</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T60</span> &#123;</span>    <span class="hljs-function">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; <span class="hljs-title">Print</span><span class="hljs-params">(TreeNode pRoot)</span> </span>&#123;        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();Queue&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-built_in">queue</span>.add(pRoot);        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">queue</span>.isEmpty()) &#123;            ArrayList&lt;Integer&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">int</span> cnt = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">while</span> (cnt-- &gt; <span class="hljs-number">0</span>) &#123;                TreeNode node = <span class="hljs-built_in">queue</span>.poll();                <span class="hljs-keyword">if</span> (node == null) <span class="hljs-keyword">continue</span>;                <span class="hljs-built_in">list</span>.add(node.val);                <span class="hljs-built_in">queue</span>.add(node.left);                <span class="hljs-built_in">queue</span>.add(node.right);            &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) ret.add(<span class="hljs-built_in">list</span>);        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre><h3 id="5-3、按之字形顺序打印二叉树"><a href="#5-3、按之字形顺序打印二叉树" class="headerlink" title="5.3、按之字形顺序打印二叉树"></a>5.3、<a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=3&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">按之字形顺序打印二叉树</a></h3><blockquote><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><pre><code class="hljs lua">&gt;输入&gt;&#123;<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>&#125;&gt;返回值&gt;<span class="hljs-string">[[8],[10,6],[5,7,9,11]]</span></code></pre></blockquote><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> T59 &#123;    <span class="hljs-built_in">public</span> ArrayList&lt;ArrayList&lt;<span class="hljs-type">Integer</span>&gt;&gt; Print(TreeNode pRoot) &#123;        ArrayList&lt;ArrayList&lt;<span class="hljs-type">Integer</span>&gt;&gt; ret = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();        Queue&lt;TreeNode&gt; queue = <span class="hljs-built_in">new</span> LinkedList&lt;&gt;();        queue.<span class="hljs-keyword">add</span>(pRoot);        <span class="hljs-type">boolean</span> <span class="hljs-keyword">reverse</span> = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">while</span> (! queue.isEmpty()) &#123;            ArrayList&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();            <span class="hljs-type">int</span> cnt = queue.size();            <span class="hljs-keyword">while</span> (cnt<span class="hljs-comment">-- &gt; 0) &#123;</span>                TreeNode node = queue.poll();                <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;                list.<span class="hljs-keyword">add</span>(node.val);                queue.<span class="hljs-keyword">add</span>(node.left);                queue.<span class="hljs-keyword">add</span>(node.right);            &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">reverse</span>) Collections.reverse(list);            <span class="hljs-keyword">reverse</span> = !<span class="hljs-keyword">reverse</span>;            <span class="hljs-keyword">if</span> (list.size() != <span class="hljs-number">0</span>) ret.<span class="hljs-keyword">add</span>(list);        &#125;        <span class="hljs-keyword">return</span> ret;&#125;</code></pre><h3 id="5-4-二叉树的右视图"><a href="#5-4-二叉树的右视图" class="headerlink" title="5.4 二叉树的右视图"></a>5.4 二叉树的右视图</h3><blockquote><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><pre><code class="hljs elm">&gt;输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,null,<span class="hljs-number">5</span>,null,<span class="hljs-number">4</span>]&gt;输出: [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]&gt;解释:  <span class="hljs-number">1</span>            &lt;-<span class="hljs-comment">--</span>/   \&gt;<span class="hljs-number">2</span>     <span class="hljs-number">3</span>         &lt;-<span class="hljs-comment">--</span>\     \ <span class="hljs-number">5</span>     <span class="hljs-number">4</span>       &lt;-<span class="hljs-comment">--</span></code></pre></blockquote><p>层序遍历，只保留最后一个结点的值</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> ret;        Queue&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-built_in">queue</span>.add(root);        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">queue</span>.isEmpty()) &#123;            <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">size</span>-- &gt; <span class="hljs-number">0</span>) &#123;                TreeNode t = <span class="hljs-built_in">queue</span>.poll();                <span class="hljs-keyword">if</span> (t.left != null) <span class="hljs-built_in">queue</span>.add(t.left);                <span class="hljs-keyword">if</span> (t.right != null) <span class="hljs-built_in">queue</span>.add(t.right);                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> == <span class="hljs-number">0</span>) ret.add(t.val);            &#125;        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre><h3 id="5-5-二叉树的左视图"><a href="#5-5-二叉树的左视图" class="headerlink" title="5.5 二叉树的左视图"></a>5.5 二叉树的左视图</h3><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        List&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> ret;        Queue&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-built_in">queue</span>.add(root);        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">queue</span>.isEmpty())&#123;            <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">int</span> tmp = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">size</span>-- &gt; <span class="hljs-number">0</span>)&#123;                TreeNode t = <span class="hljs-built_in">queue</span>.poll();                <span class="hljs-keyword">if</span>(t.left != null) <span class="hljs-built_in">queue</span>.add(t.left);                <span class="hljs-keyword">if</span>(t.right != null) <span class="hljs-built_in">queue</span>.add(t.right);                <span class="hljs-keyword">if</span>(tmp == <span class="hljs-built_in">size</span>) ret.add(t.val);            &#125;        &#125;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;</code></pre><h3 id="6、二叉搜索树的后序遍历序列"><a href="#6、二叉搜索树的后序遍历序列" class="headerlink" title="6、二叉搜索树的后序遍历序列"></a>6、<a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=2&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉搜索树的后序遍历序列</a></h3><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。（ps：我们约定空树不是二叉搜素树）</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash">[4,8,6,12,16,14,10]</span><span class="hljs-meta">&gt;</span><span class="bash">返回值</span><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-literal">true</span></span></code></pre></blockquote><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> T23 &#123;    <span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> VerifySquenceOfBST(<span class="hljs-type">int</span> [] <span class="hljs-keyword">sequence</span>)  &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sequence</span> == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">sequence</span>.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">return</span> isBST(<span class="hljs-keyword">sequence</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sequence</span>.length - <span class="hljs-number">1</span>);    &#125;private <span class="hljs-type">boolean</span> isBST(<span class="hljs-type">int</span>[] <span class="hljs-keyword">sequence</span>, <span class="hljs-type">int</span> first, <span class="hljs-type">int</span> last) &#123;        <span class="hljs-keyword">if</span> (last - first &lt;= <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-type">int</span> rootVal = <span class="hljs-keyword">sequence</span>[last];        <span class="hljs-type">int</span> cutIndex = first;        <span class="hljs-keyword">while</span> (cutIndex &lt; last &amp;&amp; <span class="hljs-keyword">sequence</span>[curIndex] &lt;= rootVal) &#123; // 二叉搜索树特征            cutIndex++;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = cutIndedx; i &lt; last; i++) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sequence</span>[i] &lt; rootVal) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> isBST(<span class="hljs-keyword">sequence</span>, first, cutIndex - <span class="hljs-number">1</span>) &amp;&amp; isBST(<span class="hljs-keyword">sequence</span>, cutIndex, last - <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h3 id="7、二叉树中和为某一值的路径"><a href="#7、二叉树中和为某一值的路径" class="headerlink" title="7、二叉树中和为某一值的路径"></a>7、<a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=2&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉树中和为某一值的路径</a></h3><blockquote><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><pre><code class="hljs tap">&gt;给定如下二叉树，以及目标和 target = 22，             5            / \          <span class="hljs-number"> 4 </span>  8          /   / \        <span class="hljs-number"> 11 </span><span class="hljs-number"> 13 </span> 4        /  \    / \      <span class="hljs-number"> 7 </span>  <span class="hljs-number"> 2 </span><span class="hljs-number"> 5 </span>  1&gt;返回:&gt;[  [5,4,11,2],  [5,8,4,5]&gt;]</code></pre></blockquote><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> T24 &#123;    private ArrayList&lt;ArrayList&lt;<span class="hljs-type">Integer</span>&gt;&gt; ret = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();    <span class="hljs-built_in">public</span> ArrayList&lt;ArrayList&lt;<span class="hljs-type">Integer</span>&gt;&gt; FindPath(TreeNode root, <span class="hljs-type">int</span> target) &#123;        backtracking(root, target, <span class="hljs-built_in">new</span> ArrayList&lt;&gt;());        <span class="hljs-keyword">return</span> ret;    &#125;    private <span class="hljs-type">void</span> backtracking(TreeNode node, <span class="hljs-type">int</span> target, ArrayList&lt;<span class="hljs-type">Integer</span>&gt; <span class="hljs-type">path</span>) &#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span>;        <span class="hljs-type">path</span>.<span class="hljs-keyword">add</span>(node.val);        target -= node.val;        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span> &amp;&amp; node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>) &#123;            ret.<span class="hljs-keyword">add</span>(<span class="hljs-built_in">new</span> ArrayList&lt;&gt;(<span class="hljs-type">path</span>));        &#125; <span class="hljs-keyword">else</span> &#123;            backtracking(node.left, target, <span class="hljs-type">path</span>);            backtracking(node.right, target, <span class="hljs-type">path</span>);        &#125;        <span class="hljs-type">path</span>.remove(<span class="hljs-type">path</span>.size() - <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h3 id="8、二叉搜索树的第k个结点"><a href="#8、二叉搜索树的第k个结点" class="headerlink" title="8、二叉搜索树的第k个结点"></a>8、<a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=4&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉搜索树的第k个结点</a></h3><blockquote><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><pre><code class="hljs livescript">&gt;输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span>  <span class="hljs-number">3</span> / <span class="hljs-string">\</span><span class="hljs-number">1</span>   <span class="hljs-number">4</span> <span class="hljs-string">\</span>  <span class="hljs-number">2</span>&gt;输出: <span class="hljs-number">4</span></code></pre><pre><code class="hljs livescript">&gt;输入: root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span>      <span class="hljs-number">5</span>     / <span class="hljs-string">\</span>    <span class="hljs-number">3</span>   <span class="hljs-number">6</span>   / <span class="hljs-string">\</span>  <span class="hljs-number">2</span>   <span class="hljs-number">4</span> /<span class="hljs-number">1</span>&gt;输出: <span class="hljs-number">4</span></code></pre></blockquote><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> int ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">kthLargest</span>(<span class="hljs-params">TreeNode root, int k</span>)</span> &#123;        <span class="hljs-comment">// clarification:  root == null?   k &lt;= 1?</span>        helper(root, k);        <span class="hljs-keyword">return</span> ans;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">helper</span>(<span class="hljs-params">TreeNode root, int k</span>)</span> &#123;        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) helper(root.right, k);                <span class="hljs-keyword">if</span> (++count == k) &#123;            ans = root.val;            <span class="hljs-keyword">return</span>;        &#125;                <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) helper(root.left, k);    &#125;&#125;</code></pre><h3 id="9-1、二叉树的深度"><a href="#9-1、二叉树的深度" class="headerlink" title="9.1、二叉树的深度"></a>9.1、<a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=2&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉树的深度</a></h3><blockquote><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入</span><span class="hljs-meta">&gt;</span><span class="bash">&#123;1,2,3,4,5,<span class="hljs-comment">#,6,#,#,7&#125;</span></span><span class="hljs-meta">&gt;</span><span class="bash">返回值</span><span class="hljs-meta">&gt;</span><span class="bash">4</span></code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T38</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-comment">// 递归取左和右的最大高度 + 1</span>        <span class="hljs-keyword">return</span> root == null ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span> + Math.<span class="hljs-built_in">max</span>(TreeDepth(root.left), TreeDepth(root.right));    &#125;&#125;<span class="hljs-comment">// 迭代 bfs</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        Queue&lt;TreeNode&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-comment">// 树不需要标记哦</span>        <span class="hljs-built_in">queue</span>.add(root);        <span class="hljs-keyword">int</span> depth = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">queue</span>.isEmpty()) &#123;            <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">size</span>-- &gt; <span class="hljs-number">0</span>) &#123;                TreeNode node = <span class="hljs-built_in">queue</span>.poll();                <span class="hljs-keyword">if</span> (node.left == null &amp;&amp; node.right == null)                    <span class="hljs-keyword">return</span> depth;                <span class="hljs-keyword">if</span> (node.left != null)                    <span class="hljs-built_in">queue</span>.add(node.left);                <span class="hljs-keyword">if</span> (node.right != null)                    <span class="hljs-built_in">queue</span>.add(node.right);            &#125;            depth++;        &#125;        <span class="hljs-keyword">return</span> depth;    &#125;&#125;</code></pre><h3 id="9-2-二叉树的直径"><a href="#9-2-二叉树的直径" class="headerlink" title="9.2 二叉树的直径"></a>9.2 二叉树的直径</h3><blockquote><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><pre><code class="hljs tap">&gt;给定二叉树         1        / \      <span class="hljs-number"> 2 </span>  3      / \         <span class="hljs-number"> 4 </span> <span class="hljs-number"> 5 </span>   &gt;返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-comment">// 定义最大高度</span>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> max = <span class="hljs-number">0</span>;    public <span class="hljs-built_in">int</span> diameter<span class="hljs-constructor">OfBinaryTree(TreeNode <span class="hljs-params">root</span>)</span> &#123;        <span class="hljs-comment">// 递归</span>        <span class="hljs-constructor">Depth(<span class="hljs-params">root</span>)</span>;        return max;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-constructor">Depth(TreeNode <span class="hljs-params">root</span>)</span> &#123;        <span class="hljs-comment">// 递归结束条件</span>        <span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>null) return <span class="hljs-number">0</span>;        <span class="hljs-comment">// 递归左的高度</span>        <span class="hljs-built_in">int</span> l = <span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;        <span class="hljs-comment">// 递归右的高度</span>        <span class="hljs-built_in">int</span> r = <span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;        <span class="hljs-comment">// 每次保持最大高度</span>        max = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(max, l + r);        <span class="hljs-comment">// 返回左和右的最大高度加1</span>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(l, r) + <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h3 id="10、平衡二叉树"><a href="#10、平衡二叉树" class="headerlink" title="10、平衡二叉树"></a>10、<a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=2&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">平衡二叉树</a></h3><blockquote><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><pre><code class="hljs yaml"><span class="hljs-string">&gt;给定二叉树</span> [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]   <span class="hljs-number">3</span>  <span class="hljs-string">/</span> <span class="hljs-string">\</span> <span class="hljs-number">9</span>  <span class="hljs-number">20</span>   <span class="hljs-string">/</span>  <span class="hljs-string">\</span>  <span class="hljs-number">15</span>   <span class="hljs-number">7</span><span class="hljs-string">&gt;返回</span> <span class="hljs-literal">true</span> <span class="hljs-string">。</span></code></pre><pre><code class="hljs livescript">&gt;给定二叉树 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]      <span class="hljs-number">1</span>     / <span class="hljs-string">\</span>    <span class="hljs-number">2</span>   <span class="hljs-number">2</span>   / <span class="hljs-string">\</span>  <span class="hljs-number">3</span>   <span class="hljs-number">3</span> / <span class="hljs-string">\</span><span class="hljs-number">4</span>   <span class="hljs-number">4</span>&gt;返回 <span class="hljs-literal">false</span> 。</code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-comment">// 定义一个平衡标记，默认平衡</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isBalanced = <span class="hljs-literal">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-comment">// 递归</span>    <span class="hljs-built_in">height</span>(root);    <span class="hljs-keyword">return</span> isBalanced;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-comment">// 递归结束条件</span>    <span class="hljs-keyword">if</span> (root == null || !isBalanced)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">// 递归左高度</span>    <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">height</span>(root.left);    <span class="hljs-comment">// 递归右高度</span>    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">height</span>(root.right);    <span class="hljs-comment">// 绝对值是否大于1</span>    <span class="hljs-keyword">if</span> (Math.<span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span>)        isBalanced = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 返回左和右的最大高度加1</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.<span class="hljs-built_in">max</span>(left, right);&#125;</code></pre><h3 id="11-1-非递归前序"><a href="#11-1-非递归前序" class="headerlink" title="11.1 非递归前序"></a>11.1 非递归前序</h3><blockquote><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><pre><code class="hljs inform7">&gt;输入：root = <span class="hljs-comment">[1,null,2,3]</span>&gt;输出：<span class="hljs-comment">[1,2,3]</span></code></pre><pre><code class="hljs inform7">&gt;输入：root = <span class="hljs-comment">[]</span>&gt;输出：<span class="hljs-comment">[]</span></code></pre><pre><code class="hljs inform7">&gt;输入：root = <span class="hljs-comment">[1,2]</span>&gt;输出：<span class="hljs-comment">[1,2]</span></code></pre><pre><code class="hljs inform7">&gt;输入：root = <span class="hljs-comment">[1,null,2]</span>&gt;输出：<span class="hljs-comment">[1,2]</span></code></pre></blockquote><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; preorderTraversal(TreeNode root) &#123;    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; ret = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// 用栈的思想</span>    <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();    <span class="hljs-comment">// 我们知道，前序：根左右</span>    <span class="hljs-comment">// 添加根</span>    <span class="hljs-built_in">stack</span>.push(root);    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stack</span>.isEmpty()) &#123;        <span class="hljs-comment">// 弹根</span>        TreeNode node = <span class="hljs-built_in">stack</span>.pop();        <span class="hljs-comment">// 判断是否为空</span>        <span class="hljs-keyword">if</span> (node == <span class="hljs-built_in">null</span>) continue;        <span class="hljs-comment">// 不为空，加val加入列表</span>        ret.add(node.val);        <span class="hljs-comment">// 先添加右，后左，这样下次就能先弹左</span>        <span class="hljs-built_in">stack</span>.push(node.right);          <span class="hljs-built_in">stack</span>.push(node.left);    &#125;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre><h3 id="11-2-后序"><a href="#11-2-后序" class="headerlink" title="11.2 后序"></a>11.2 后序</h3><blockquote><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><pre><code class="hljs css">&gt;输入: <span class="hljs-selector-attr">[1,null,2,3]</span>    1   \    2   /  3 &gt;输出: <span class="hljs-selector-attr">[3,2,1]</span></code></pre></blockquote><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; ret = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// 还是栈思想，后序：左右根，倒过来：根右左：那么就是根前序的差不多</span>    <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();    <span class="hljs-built_in">stack</span>.push(root);    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stack</span>.isEmpty()) &#123;        TreeNode node = <span class="hljs-built_in">stack</span>.pop();        <span class="hljs-keyword">if</span> (node == <span class="hljs-built_in">null</span>) continue;        ret.add(node.val);        <span class="hljs-comment">// 这里先添加左，保证弹出的是右</span>        <span class="hljs-built_in">stack</span>.push(node.left);        <span class="hljs-built_in">stack</span>.push(node.right);    &#125;    <span class="hljs-comment">// 翻转就是后序</span>    Collections.reverse(ret);    <span class="hljs-keyword">return</span> ret;&#125;</code></pre><h3 id="11-3-中序"><a href="#11-3-中序" class="headerlink" title="11.3 中序"></a>11.3 中序</h3><blockquote><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><pre><code class="hljs inform7">&gt;输入：root = <span class="hljs-comment">[1,null,2,3]</span>&gt;输出：<span class="hljs-comment">[1,3,2]</span></code></pre><pre><code class="hljs inform7">&gt;输入：root = <span class="hljs-comment">[]</span>&gt;输出：<span class="hljs-comment">[]</span></code></pre><pre><code class="hljs inform7">&gt;输入：root = <span class="hljs-comment">[1,2]</span>&gt;输出：<span class="hljs-comment">[2,1]</span></code></pre><pre><code class="hljs inform7">&gt;输入：root = <span class="hljs-comment">[1,null,2]</span>&gt;输出：<span class="hljs-comment">[1,2]</span></code></pre></blockquote><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; inorderTraversal(TreeNode root) &#123;    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; ret = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-built_in">null</span>) <span class="hljs-keyword">return</span> ret;    <span class="hljs-comment">// 还是栈：中序：左根右</span>    <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();    <span class="hljs-comment">// 虚拟结点</span>    TreeNode cur = root;    <span class="hljs-keyword">while</span> (cur != <span class="hljs-built_in">null</span> || !<span class="hljs-built_in">stack</span>.isEmpty()) &#123;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-built_in">null</span>) &#123;            <span class="hljs-comment">// 一直左</span>            <span class="hljs-built_in">stack</span>.push(cur);            cur = cur.left;        &#125;        <span class="hljs-comment">// 保证弹出的左</span>        TreeNode node = <span class="hljs-built_in">stack</span>.pop();        ret.add(node.val);        <span class="hljs-comment">// 开始移动到右</span>        cur = node.right;    &#125;    <span class="hljs-keyword">return</span> ret;&#125;</code></pre><h3 id="12-二叉树的最近公共祖先"><a href="#12-二叉树的最近公共祖先" class="headerlink" title="12 二叉树的最近公共祖先"></a>12 二叉树的最近公共祖先</h3><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">1</span>&gt;输出：<span class="hljs-number">3</span>&gt;解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span> 。</code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">4</span>&gt;输出：<span class="hljs-number">5</span>&gt;解释：节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span> 。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><pre><code class="hljs nix">&gt;输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">2</span>&gt;输出：<span class="hljs-number">1</span></code></pre></blockquote><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-function"><span class="hljs-title">lowestCommonAncestor</span>(<span class="hljs-params">TreeNode root, TreeNode p, TreeNode q</span>)</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> root;        <span class="hljs-comment">// 如果根等于p或者q，直接返回根</span>        <span class="hljs-keyword">if</span> (root == p || root == q)            <span class="hljs-keyword">return</span> root;        <span class="hljs-comment">// 递归左和pq比</span>        TreeNode left = lowestCommonAncestor(root.left, p, q);        <span class="hljs-comment">// 递归右和pq比</span>        TreeNode right = lowestCommonAncestor(root.right, p, q);        <span class="hljs-comment">// 同时不为空，则为根</span>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> root;        <span class="hljs-comment">// 左不空，则左</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> left;        <span class="hljs-comment">// 右不空，则右</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> right;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre><h3 id="13-合并二叉树"><a href="#13-合并二叉树" class="headerlink" title="13. 合并二叉树"></a>13. 合并二叉树</h3><blockquote><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><pre><code class="hljs tap">&gt;输入: Tree<span class="hljs-number"> 1 </span>                    Tree<span class="hljs-number"> 2 </span>                         <span class="hljs-number"> 1 </span>                       <span class="hljs-number"> 2 </span>                                    / \                       / \                                  <span class="hljs-number"> 3 </span> <span class="hljs-number"> 2 </span>                   <span class="hljs-number"> 1 </span> <span class="hljs-number"> 3 </span>                             /                           \   \                          <span class="hljs-number"> 5 </span>                           <span class="hljs-number"> 4 </span> <span class="hljs-number"> 7 </span>                 &gt;输出: &gt;合并后的树:     3    / \  <span class="hljs-number"> 4 </span>  5  / \   \ <span class="hljs-number"> 5 </span> <span class="hljs-number"> 4 </span>  7</code></pre></blockquote><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-function"><span class="hljs-title">mergeTrees</span>(<span class="hljs-params">TreeNode t1, TreeNode t2</span>)</span> &#123;        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span> &amp;&amp; t2 == <span class="hljs-literal">null</span>)             <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span>)             <span class="hljs-keyword">return</span> t2;        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">null</span>)             <span class="hljs-keyword">return</span> t1;        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(t1.val + t2.val);        root.left = mergeTrees(t1.left, t2.left);        root.right = mergeTrees(t1.right, t2.right);        <span class="hljs-keyword">return</span> root;     &#125;&#125;    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-function"><span class="hljs-title">mergeTrees2</span>(<span class="hljs-params">TreeNode t1, TreeNode t2</span>)</span> &#123;        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span> &amp;&amp; t2 == <span class="hljs-literal">null</span>)             <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">null</span>)             <span class="hljs-keyword">return</span> t2;        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">null</span>)             <span class="hljs-keyword">return</span> t1;        <span class="hljs-comment">// 先合并根节点</span>        t1.val += t2.val;        <span class="hljs-comment">// 再递归合并左右子树</span>        t1.left = mergeTrees(t1.left, t2.left);        t1.right = mergeTrees(t1.right, t2.right);        <span class="hljs-keyword">return</span> t1;    &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-function"><span class="hljs-title">mergeTrees</span>(<span class="hljs-params">TreeNode t1, TreeNode t2</span>)</span> &#123;        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(t1);        queue.offer(t2);        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;            TreeNode node1 = queue.poll();            TreeNode node2 = queue.poll();            <span class="hljs-comment">//合并两个值</span>            node1.val += node2.val;            <span class="hljs-comment">//左子树都不为空</span>            <span class="hljs-keyword">if</span>(node1.left != <span class="hljs-literal">null</span> &amp;&amp; node2.left!=<span class="hljs-literal">null</span>)&#123;                queue.offer(node1.left);                queue.offer(node2.left);            &#125;            <span class="hljs-keyword">if</span>(node1.left == <span class="hljs-literal">null</span>)                node1.left = node2.left;            <span class="hljs-comment">//右子树都不为空</span>            <span class="hljs-keyword">if</span>(node1.right != <span class="hljs-literal">null</span> &amp;&amp; node2.right != <span class="hljs-literal">null</span>)&#123;                queue.offer(node1.right);                queue.offer(node2.right);            &#125;            <span class="hljs-keyword">if</span>(node1.right == <span class="hljs-literal">null</span>)                node1.right = node2.right;        &#125;        <span class="hljs-keyword">return</span> t1;    &#125;&#125;</code></pre><h3 id="14-不同的二叉搜索树"><a href="#14-不同的二叉搜索树" class="headerlink" title="14. 不同的二叉搜索树"></a>14. 不同的二叉搜索树</h3><blockquote><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><pre><code class="hljs tap">&gt;输入: 3&gt;输出: 5&gt;解释:&gt;给定 n = 3, 一共有<span class="hljs-number"> 5 </span>种不同结构的二叉搜索树: <span class="hljs-number"> 1 </span>       <span class="hljs-number"> 3 </span>   <span class="hljs-number"> 3 </span>    <span class="hljs-number"> 2 </span>     1   \       /     /      / \      \   <span class="hljs-number"> 3 </span>   <span class="hljs-number"> 2 </span>   <span class="hljs-number"> 1 </span>    <span class="hljs-number"> 1 </span> <span class="hljs-number"> 3 </span>     2   /     /       \                 \ <span class="hljs-number"> 2 </span>   <span class="hljs-number"> 1 </span>       <span class="hljs-number"> 2 </span>                3</code></pre></blockquote><p>动态规划</p><p>假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数</p><p>即有:G(n) = f(1) + f(2) + f(3) + f(4) + … + f(n)</p><p>n为根节点，当i为根节点时，其左子树节点个数为[1,2,3,…,i-1]，右子树节点个数为[i+1,i+2,…n]，所以当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，即f(i) = G(i-1)*G(n-i),</p><p>上面两式可得:G(n) = G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;=n; i++)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;                dp[i] += dp[j - <span class="hljs-number">1</span>] * dp[i - j];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;</code></pre><h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h3><blockquote><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：root = [1,2,3,4,5,6]</span><span class="hljs-meta">&gt;</span><span class="bash">输出：6</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入：root = []</span><span class="hljs-meta">&gt;</span><span class="bash">输出：0</span></code></pre></blockquote><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> count<span class="hljs-constructor">Nodes(TreeNode <span class="hljs-params">root</span>)</span> &#123;        return root<span class="hljs-operator"> == </span>null ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span> + count<span class="hljs-constructor">Nodes(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span> + count<span class="hljs-constructor">Nodes(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;    &#125;&#125;</code></pre><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h3><blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">输入:</span>   2  / \ 1   3<span class="hljs-meta">&gt;</span><span class="bash">输出: <span class="hljs-literal">true</span></span></code></pre><pre><code class="hljs yaml"><span class="hljs-string">&gt;输入:</span>   <span class="hljs-number">5</span>  <span class="hljs-string">/</span> <span class="hljs-string">\</span> <span class="hljs-number">1</span>   <span class="hljs-number">4</span>    <span class="hljs-string">/</span> <span class="hljs-string">\</span>   <span class="hljs-number">3</span>   <span class="hljs-number">6</span><span class="hljs-string">&gt;输出:</span> <span class="hljs-literal">false</span><span class="hljs-string">&gt;解释:</span> <span class="hljs-string">输入为:</span> [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<span class="hljs-string">。</span>    <span class="hljs-string">根节点的值为</span> <span class="hljs-number">5</span> <span class="hljs-string">，但是其右子节点值为</span> <span class="hljs-number">4</span> <span class="hljs-string">。</span></code></pre></blockquote><pre><code class="hljs xquery">class Solution &#123;    public<span class="hljs-built_in"> boolean</span> isValidBST(TreeNode<span class="hljs-built_in"> root</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">validate</span><span class="hljs-built_in">(root</span>, Long.MIN_VALUE, Long.MAX_VALUE);    &#125;    public<span class="hljs-built_in"> boolean</span> <span class="hljs-keyword">validate</span>(TreeNode <span class="hljs-type">node</span>, long<span class="hljs-built_in"> min</span>, long<span class="hljs-built_in"> max</span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-type">node</span> == null)            <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-type">node</span>.val &lt;=<span class="hljs-built_in"> min</span> || <span class="hljs-type">node</span>.val &gt;=<span class="hljs-built_in"> max</span>)            <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">validate</span>(<span class="hljs-type">node</span>.left,<span class="hljs-built_in"> min</span>, <span class="hljs-type">node</span>.val) &amp;&amp; <span class="hljs-keyword">validate</span>(<span class="hljs-type">node</span>.right, <span class="hljs-type">node</span>.val,<span class="hljs-built_in"> max</span>);    &#125;&#125;</code></pre><h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><blockquote><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><pre><code class="hljs livescript">&gt;输入:  <span class="hljs-number">1</span>/   <span class="hljs-string">\</span>&gt;<span class="hljs-number">2</span>     <span class="hljs-number">3</span><span class="hljs-string">\</span> <span class="hljs-number">5</span>&gt;输出: [<span class="hljs-string">&quot;1-&gt;2-&gt;5&quot;</span>, <span class="hljs-string">&quot;1-&gt;3&quot;</span>]&gt;解释: 所有根节点到叶子节点的路径为: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span></code></pre></blockquote><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;    private List&lt;String&gt; res = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();    <span class="hljs-built_in">public</span> List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;        dfs(root, <span class="hljs-built_in">new</span> StringBuilder());        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(res.toString());        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> dfs(TreeNode node, StringBuilder <span class="hljs-type">path</span>) &#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">return</span>;        <span class="hljs-type">path</span>.append(node.val);        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>) &#123;            res.<span class="hljs-keyword">add</span>(<span class="hljs-type">path</span>.toString());            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            dfs(node.left, <span class="hljs-built_in">new</span> StringBuilder(<span class="hljs-type">path</span>).append(&quot;-&gt;&quot;));            dfs(node.right, <span class="hljs-built_in">new</span> StringBuilder(<span class="hljs-type">path</span>).append(&quot;-&gt;&quot;));        &#125;        // <span class="hljs-type">path</span>.deleteCharAt(<span class="hljs-type">path</span>.length() - <span class="hljs-number">1</span>);    &#125;&#125;</code></pre><h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a>124. 二叉树中的最大路径和</h3><blockquote><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><pre><code class="hljs tap">&gt;输入：root = [1,2,3]&gt;输出：6&gt;解释：最优路径是<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 3 </span>，路径和为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>= 6</code></pre><pre><code class="hljs tap">&gt;输入：root = [-10,9,20,null,null,15,7]&gt;输出：42&gt;解释：最优路径是<span class="hljs-number"> 15 </span>-&gt;<span class="hljs-number"> 20 </span>-&gt;<span class="hljs-number"> 7 </span>，路径和为<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 20 </span>+<span class="hljs-number"> 7 </span>= 42</code></pre></blockquote><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = Integer.MIN_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        help(root);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">help</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == null)             <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> left = help(root.left);        <span class="hljs-keyword">int</span> right = help(root.right);        <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, left + right + root.val);        <span class="hljs-keyword">int</span> res = root.val + Math.<span class="hljs-built_in">max</span>(left, right);        <span class="hljs-keyword">return</span> res &gt; <span class="hljs-number">0</span> ? res : <span class="hljs-number">0</span>;    &#125;&#125;</code></pre><h3 id="814-二叉树剪枝"><a href="#814-二叉树剪枝" class="headerlink" title="814. 二叉树剪枝"></a>814. 二叉树剪枝</h3><blockquote><p>给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。</p><p>返回移除了所有不包含 1 的子树的原二叉树。</p><p>( 节点 X 的子树为 X 本身，以及所有 X 的后代。)</p><pre><code class="hljs yaml"><span class="hljs-string">&gt;输入:</span> [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<span class="hljs-string">&gt;输出:</span> [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]</code></pre><pre><code class="hljs yaml"><span class="hljs-string">&gt;输入:</span> [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<span class="hljs-string">&gt;输出:</span> [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]</code></pre><pre><code class="hljs dns">&gt;输入: [<span class="hljs-number">1,1,0,1</span>,<span class="hljs-number">1,0,1,0</span>]&gt;输出: [<span class="hljs-number">1,1,0,1</span>,<span class="hljs-number">1</span>,null,<span class="hljs-number">1</span>]</code></pre></blockquote><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> TreeNode pruneTree(TreeNode root) &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        root.left = pruneTree(root.left);        root.right = pruneTree(root.right);        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-keyword">val</span> == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> root;    &#125;&#125;</code></pre><h3 id="1026-节点与其祖先之间的最大差值"><a href="#1026-节点与其祖先之间的最大差值" class="headerlink" title="1026. 节点与其祖先之间的最大差值"></a>1026. 节点与其祖先之间的最大差值</h3><blockquote><p>给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。</p><p>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p><pre><code class="hljs coq">&gt;输入：root = [<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,null,<span class="hljs-number">14</span>,null,null,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">13</span>]&gt;输出：<span class="hljs-number">7</span>&gt;解释： &gt;我们有大量的节点与其祖先的差值，其中一些如下：&gt;|<span class="hljs-type">8</span> - <span class="hljs-number">3</span>| <span class="hljs-type">= 5</span>&gt;|<span class="hljs-type">3</span> - <span class="hljs-number">7</span>| <span class="hljs-type">= 4</span>&gt;|<span class="hljs-type">8</span> - <span class="hljs-number">1</span>| <span class="hljs-type">= 7</span>&gt;|<span class="hljs-type">10</span> - <span class="hljs-number">13</span>| <span class="hljs-type">= 3</span>&gt;在所有可能的差值中，最大值 <span class="hljs-number">7</span> 由 |<span class="hljs-type">8</span> - <span class="hljs-number">1</span>| <span class="hljs-type">= 7</span> 得出。</code></pre><pre><code class="hljs yaml"><span class="hljs-string">&gt;输入：root</span> <span class="hljs-string">=</span> [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]<span class="hljs-string">&gt;输出：3</span></code></pre></blockquote><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> int maxAncestorDiff(<span class="hljs-type">TreeNode</span> root) &#123;        int <span class="hljs-keyword">left</span> = dfs(root.<span class="hljs-keyword">left</span>, root.val, root.val);        int <span class="hljs-keyword">right</span> = dfs(root.<span class="hljs-keyword">right</span>, root.val, root.val);        <span class="hljs-keyword">return</span> <span class="hljs-type">Math</span>.<span class="hljs-built_in">max</span>(<span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>);    &#125;    <span class="hljs-keyword">public</span> int dfs(<span class="hljs-type">TreeNode</span> root, int <span class="hljs-built_in">max</span>, int <span class="hljs-built_in">min</span>) &#123;        <span class="hljs-keyword">if</span> (root == null)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">max</span> = <span class="hljs-type">Math</span>.<span class="hljs-built_in">max</span>(root.val, <span class="hljs-built_in">max</span>);        <span class="hljs-built_in">min</span> = <span class="hljs-type">Math</span>.<span class="hljs-built_in">min</span>(root.val, <span class="hljs-built_in">min</span>);        <span class="hljs-keyword">if</span> (root.<span class="hljs-keyword">left</span> == null &amp;&amp; root.<span class="hljs-keyword">right</span> == null)            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span> - <span class="hljs-built_in">min</span>;        int <span class="hljs-keyword">left</span> = dfs(root.<span class="hljs-keyword">left</span>, <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span>);        int <span class="hljs-keyword">right</span> = dfs(root.<span class="hljs-keyword">right</span>, <span class="hljs-built_in">max</span>, <span class="hljs-built_in">min</span>);        <span class="hljs-keyword">return</span> <span class="hljs-type">Math</span>.<span class="hljs-built_in">max</span>(<span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>需要熟练的链表算法题</title>
    <link href="/2021/03/17/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2021/03/17/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="1、从尾到头打印链表"><a href="#1、从尾到头打印链表" class="headerlink" title="1、从尾到头打印链表"></a>1、<a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">从尾到头打印链表</a></h3><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T3</span> </span>&#123;    <span class="hljs-comment">// 创建list</span>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-function"><span class="hljs-title">printListFromTailToHead</span>(<span class="hljs-params">ListNode listNode</span>)</span> &#123;        <span class="hljs-comment">// 判断头节点是否为空</span>        <span class="hljs-keyword">if</span> (listNode != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// 递归打印</span>            <span class="hljs-built_in">this</span>.printListFromTailToHead(listNode.next);            list.add(listNode.val);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre><h3 id="2、删除链表中重复的结点"><a href="#2、删除链表中重复的结点" class="headerlink" title="2、删除链表中重复的结点"></a>2、<a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=3&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">删除链表中重复的结点</a></h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/</a></p><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> ListNode deleteDuplication(ListNode pHead) &#123;    <span class="hljs-comment">// 1. 边界，需要下一个结点做判断，因此还是需要判断下个结点是否为空</span>    <span class="hljs-keyword">if</span> (pHead == <span class="hljs-literal">null</span> || pHead.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>)        <span class="hljs-keyword">return</span> pHead;    <span class="hljs-comment">// 取下一个结点</span>    ListNode <span class="hljs-keyword">next</span> = pHead.<span class="hljs-keyword">next</span>;    <span class="hljs-comment">// 2. 判断当前结点和下一个结点是否相等</span>    <span class="hljs-keyword">if</span> (pHead.val == <span class="hljs-keyword">next</span>.val) &#123;        <span class="hljs-comment">// 3. 如果相等，判断是否一直重复</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span> &amp;&amp; pHead.val == <span class="hljs-keyword">next</span>.val)            <span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">return</span> deleteDuplication(<span class="hljs-keyword">next</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 4， 否则不重复的话，就递归下一个结点</span>        pHead.<span class="hljs-keyword">next</span> = deleteDuplication(pHead.<span class="hljs-keyword">next</span>);        <span class="hljs-keyword">return</span> pHead;    &#125;&#125;</code></pre><h3 id="3-1-环形链表"><a href="#3-1-环形链表" class="headerlink" title="3.1 环形链表"></a>3.1 环形链表</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> hasCycle(ListNode head) &#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        ListNode l1 = head, l2 = head.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span> &amp;&amp; l2.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (l1 == l2) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            l1 = l1.<span class="hljs-keyword">next</span>;            l2 = l2.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><h3 id="3-2、链表中环的入口结点"><a href="#3-2、链表中环的入口结点" class="headerlink" title="3.2、链表中环的入口结点"></a>3.2、<a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=3&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">链表中环的入口结点</a></h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/">https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/</a></p><pre><code class="hljs axapta"><span class="hljs-comment">// 快慢指针</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode detectCycle(ListNode head) &#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;                <span class="hljs-built_in">boolean</span> hasCycle = <span class="hljs-literal">false</span>;        ListNode p1 = head, p2 = head;        <span class="hljs-keyword">while</span>(p2.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span> &amp;&amp; p2.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            p1 = p1.<span class="hljs-keyword">next</span>;            p2 = p2.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            <span class="hljs-keyword">if</span> (p1 == p2) &#123;                hasCycle = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(hasCycle)&#123;            p2 = head;            <span class="hljs-keyword">while</span> (p1 != p2) &#123;                p1 = p1.<span class="hljs-keyword">next</span>;                p2 = p2.<span class="hljs-keyword">next</span>;            &#125;            <span class="hljs-keyword">return</span> p1;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        &#125;&#125;</code></pre><h3 id="4、反转链表"><a href="#4、反转链表" class="headerlink" title="4、反转链表"></a>4、<a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">反转链表</a></h3><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/</a></p><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> ListNode reverseList(ListNode head) &#123;    <span class="hljs-comment">// 总感觉，本质还是两个指针，pre不过初始化为null，cur为head当前结点</span>    ListNode pre = <span class="hljs-literal">null</span>;     ListNode cur = head;    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 1. 获取当前节点的下一个节点，方便cur下移动</span>        ListNode nextTemp = cur.<span class="hljs-keyword">next</span>;        <span class="hljs-comment">// 2. 当前节点的下个节点指向前一个节点 （反转，那肯定cur的next指向pre咯）</span>        cur.<span class="hljs-keyword">next</span> = pre;         <span class="hljs-comment">// 3. pre移动下一个结点，那肯定是cur咯</span>        pre = cur;         <span class="hljs-comment">// 4. cur移动下一个结点， 那肯定是nextTemp咯</span>        cur = nextTemp;    &#125;    <span class="hljs-keyword">return</span> pre;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T15</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode ReverseList(ListNode head) &#123;        <span class="hljs-comment">// 判断</span>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">reverse</span>(<span class="hljs-literal">null</span>, head);    &#125;    <span class="hljs-keyword">private</span> ListNode <span class="hljs-keyword">reverse</span>(ListNode pre, ListNode cur) &#123;        <span class="hljs-comment">// 递归结束判断</span>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> pre;        <span class="hljs-comment">// 1. 依然第一个方法遍历依然，得到cur的next，递归用</span>        ListNode <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;        <span class="hljs-comment">// 2. 反转操作</span>        cur.<span class="hljs-keyword">next</span> = pre;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">reverse</span>(cur, <span class="hljs-keyword">next</span>);    &#125;&#125;</code></pre><h3 id="5、链表中倒数第k个结点"><a href="#5、链表中倒数第k个结点" class="headerlink" title="5、链表中倒数第k个结点"></a>5、<a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">链表中倒数第k个结点</a></h3><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> ListNode <span class="hljs-function"><span class="hljs-title">FindKthToTail</span>(<span class="hljs-params">ListNode head, int k</span>)</span> &#123;    <span class="hljs-comment">// 还是双指针</span>    <span class="hljs-comment">// 1. 边界判断</span>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    ListNode p1 = head;    <span class="hljs-comment">// 2. 先让p1移动k步</span>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">null</span> &amp;&amp; k-- &gt; <span class="hljs-number">0</span>)        p1 = p1.next;    <span class="hljs-comment">// 3. 这一步防止k大于head的长度</span>    <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    ListNode p2 = head;    <span class="hljs-comment">// 4. 二者正常走，不过p1肯定先到末尾</span>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">null</span>) &#123;        p1 = p1.next;        p2 = p2.next;    &#125;    <span class="hljs-comment">// 5. 返回p2</span>    <span class="hljs-keyword">return</span> p2;&#125;</code></pre><h3 id="6、合并两个排序的链表"><a href="#6、合并两个排序的链表" class="headerlink" title="6、合并两个排序的链表"></a>6、<a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta%252">合并两个排序的链表</a></h3><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</a></p><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T16</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode Merge(ListNode list1,ListNode list2) &#123;        <span class="hljs-comment">// 1. 如果list1为空，返回list2</span>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list2;        <span class="hljs-comment">// 2. 如果list2为空，返回list1</span>        <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list1;        <span class="hljs-comment">// 3. 如果list1.val &lt; list2.val，则list1.next连接下一个比较值（递归比较）</span>        <span class="hljs-keyword">if</span> (list1.<span class="hljs-keyword">val</span> &lt; list2.<span class="hljs-keyword">val</span>) &#123;            list1.next = Merge(list1.next, list2);            <span class="hljs-keyword">return</span> list1;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 4. 否则，list2.next 连接下一个比较值（递归比较）</span>            list2.next = Merge(list1, list2.next);            <span class="hljs-keyword">return</span> list2;        &#125;    &#125;&#125;</code></pre><h3 id="7、两个链表的第一个公共结点"><a href="#7、两个链表的第一个公共结点" class="headerlink" title="7、两个链表的第一个公共结点"></a>7、<a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=2&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">两个链表的第一个公共结点</a></h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 还是双指针public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;    ListNode l1 = pHead1, l2 = pHead2;    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 循环条件    <span class="hljs-keyword">while</span> (l1 != l2) &#123;        <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 走完l1，从头走head2        l1 = (l1 == null) ? pHead2 : l1.<span class="hljs-keyword">next</span>;        <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. 走完l2，从头走head1        l2 = (l2 == null) ? pHead1 : l2.<span class="hljs-keyword">next</span>;    &#125;    <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>. 返回l1    return l1;&#125;</code></pre><h3 id="8-两数相加-2819"><a href="#8-两数相加-2819" class="headerlink" title="8. 两数相加(2819)"></a>8. 两数相加(2819)</h3><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">https://leetcode-cn.com/problems/add-two-numbers/</a></p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        <span class="hljs-comment">// 边界判断：3个</span>        <span class="hljs-comment">// 1. l1和l2同时为空</span>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span> &amp;&amp; l2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 2. l1为空，返回l2</span>        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l2;        <span class="hljs-comment">// 3. l2为空，返回l1</span>        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l1;        <span class="hljs-comment">// 三指针</span>        <span class="hljs-comment">// 1. p1</span>        ListNode p1 = l1;        <span class="hljs-comment">// 2. p2</span>        ListNode p2 = l2;        <span class="hljs-comment">// 3. p3 特殊：返回最值链表</span>        ListNode l3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);        ListNode p3 = l3;        <span class="hljs-comment">// 4. 注意：进位</span>        <span class="hljs-built_in">int</span> carried = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 5. 循环条件，任意一个不为空即可</span>        <span class="hljs-keyword">while</span> (p1 != <span class="hljs-literal">null</span> || p2 != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// p1不为空，获取p1val，否则0</span>            <span class="hljs-built_in">int</span> a = p1 != <span class="hljs-literal">null</span> ? p1.val : <span class="hljs-number">0</span>;            <span class="hljs-comment">// p2不为空，获取p2val，否则0</span>            <span class="hljs-built_in">int</span> b = p2 != <span class="hljs-literal">null</span> ? p2.val : <span class="hljs-number">0</span>;            <span class="hljs-comment">// 关键一步，(a+b+carried) % 10 个位</span>            p3.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">new</span> ListNode((a + b + carried) % <span class="hljs-number">10</span>);            <span class="hljs-comment">// 加完，记得进位呀(a + b + carried) / 10</span>            carried = (a + b + carried) / <span class="hljs-number">10</span>;            <span class="hljs-comment">// 三个指针开始移动</span>            p3 = p3.<span class="hljs-keyword">next</span>;            p1 = p1 != <span class="hljs-literal">null</span> ? p1.<span class="hljs-keyword">next</span> : <span class="hljs-literal">null</span>;            p2 = p2 != <span class="hljs-literal">null</span> ? p2.<span class="hljs-keyword">next</span> : <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">// 循环完之后，判断进位是否0，如果不是，new一个结点为1，是的话，就null</span>        p3.<span class="hljs-keyword">next</span> = carried != <span class="hljs-number">0</span> ? <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>) : <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 返回l3下一个结点</span>        <span class="hljs-keyword">return</span> l3.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre><h3 id="9-合并K个排序链表-924"><a href="#9-合并K个排序链表-924" class="headerlink" title="9. 合并K个排序链表(924)"></a>9. 合并K个排序链表(924)</h3><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p><p>最小堆</p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode <span class="hljs-function"><span class="hljs-title">mergeKLists</span>(<span class="hljs-params">ListNode[] lists</span>)</span> &#123;        <span class="hljs-comment">// 边界判断</span>        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-comment">// 2. 堆，大顶堆</span>        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.val - o2.val);        <span class="hljs-comment">// 3. 返回结点</span>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 4. 临时p</span>        ListNode p = dummy;        <span class="hljs-comment">// 5. 遍历k个lists，一个一个添加到queue</span>        <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) queue.add(node);        &#125;        <span class="hljs-comment">// 6. 循环堆不为空</span>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-comment">// p的下个结点指向 取出堆中最大的链表结点</span>            p.next = queue.poll();            <span class="hljs-comment">// 移动</span>            p = p.next;            <span class="hljs-comment">// 如果下一个不为空，继续添加刚才堆中最大的下一个结点</span>            <span class="hljs-keyword">if</span> (p.next != <span class="hljs-literal">null</span>) queue.add(p.next);        &#125;        <span class="hljs-comment">// 7. 返回下一个结点</span>        <span class="hljs-keyword">return</span> dummy.next;    &#125;   &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;   <span class="hljs-keyword">public</span> ListNode <span class="hljs-function"><span class="hljs-title">mergeKLists</span>(<span class="hljs-params">ListNode[] lists</span>)</span> &#123;        <span class="hljs-comment">// 归并</span>        <span class="hljs-keyword">if</span> (lists == <span class="hljs-literal">null</span> || lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">private</span> ListNode <span class="hljs-function"><span class="hljs-title">merge</span>(<span class="hljs-params">ListNode[] lists, int left, int right</span>)</span> &#123;        <span class="hljs-comment">// 归并排序一样</span>        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span> lists[left];        int mid = left + (right - left) / <span class="hljs-number">2</span>;        ListNode l1 = merge(lists, left, mid);        ListNode l2 = merge(lists, mid + <span class="hljs-number">1</span>, right);        <span class="hljs-keyword">return</span> mergeTwoLists(l1, l2);    &#125;    <span class="hljs-comment">// 不过，最后归并的时候用的是合并两个排序的链表</span>    <span class="hljs-keyword">private</span> ListNode <span class="hljs-function"><span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params">ListNode l1, ListNode l2</span>)</span> &#123;        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l2;        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> l1;        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;            l1.next = mergeTwoLists(l1.next, l2);            <span class="hljs-keyword">return</span> l1;        &#125; <span class="hljs-keyword">else</span> &#123;            l2.next = mergeTwoLists(l1,l2.next);            <span class="hljs-keyword">return</span> l2;        &#125;    &#125;&#125;</code></pre><h3 id="10-两两交换链表中的节点-947"><a href="#10-两两交换链表中的节点-947" class="headerlink" title="10. 两两交换链表中的节点(947)"></a>10. 两两交换链表中的节点(947)</h3><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p><pre><code class="hljs awk">class Solution &#123;    <span class="hljs-regexp">//</span> 两两交换，那么双指针    public ListNode swapPairs(ListNode head) &#123;        <span class="hljs-regexp">//</span> 创建一个返回结点        ListNode node = new ListNode(-<span class="hljs-number">1</span>);        <span class="hljs-regexp">//</span> 该结点的<span class="hljs-keyword">next</span>指向head        node.<span class="hljs-keyword">next</span> = head;        <span class="hljs-regexp">//</span> 在创建一个pre，移动到node        ListNode pre = node;        <span class="hljs-regexp">//</span> 循环遍历        <span class="hljs-regexp">//</span> pre的<span class="hljs-keyword">next</span>才是head，因此判断<span class="hljs-keyword">next</span> <span class="hljs-keyword">next</span>        <span class="hljs-keyword">while</span> (pre.<span class="hljs-keyword">next</span> != null &amp;&amp; pre.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> != null) &#123;            <span class="hljs-regexp">//</span> 获取l1， l2            ListNode l1 = pre.<span class="hljs-keyword">next</span>, l2 = pre.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            <span class="hljs-regexp">//</span>             ListNode <span class="hljs-keyword">next</span> = l2.<span class="hljs-keyword">next</span>;            l1.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;            l2.<span class="hljs-keyword">next</span> = l1;            pre.<span class="hljs-keyword">next</span> = l2;            <span class="hljs-regexp">//</span> pre移动一步            pre = l1;        &#125;        return node.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre><h3 id="11-链表的中间结点-853"><a href="#11-链表的中间结点-853" class="headerlink" title="11. 链表的中间结点(853)"></a>11. 链表的中间结点(853)</h3><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p><pre><code class="hljs axapta"><span class="hljs-comment">// 双指针（快慢）</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode middleNode(ListNode head) &#123;        ListNode p = head, q = head;        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">null</span> &amp;&amp; q.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            q = q.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            p = p.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">return</span> p;    &#125;&#125;</code></pre><h3 id="12-删除排序链表中的重复元素-603"><a href="#12-删除排序链表中的重复元素-603" class="headerlink" title="12. 删除排序链表中的重复元素(603)"></a>12. 删除排序链表中的重复元素(603)</h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p><pre><code class="hljs xquery">// 和那个有点区别class Solution &#123;    public ListNode deleteDuplicates(ListNode<span class="hljs-built_in"> head</span>) &#123;        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(head</span> == null ||<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> == null) <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;       <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = deleteDuplicates<span class="hljs-built_in">(head</span>.<span class="hljs-keyword">next</span>);        <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>.val ==<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>.val ?<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> :<span class="hljs-built_in"> head</span>;    &#125;&#125;</code></pre><h3 id="13-回文链表-624"><a href="#13-回文链表-624" class="headerlink" title="13. 回文链表(624)"></a>13. 回文链表(624)</h3><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p><p>这题考察了很多链表的题，挺综合额</p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isPalindrome(ListNode head) &#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-comment">// 找中点</span>        ListNode slow = head, fast = head.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            slow = slow.<span class="hljs-keyword">next</span>;            fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-comment">// 奇偶情况</span>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-literal">null</span>) slow = slow.<span class="hljs-keyword">next</span>;        <span class="hljs-comment">// cut</span>        cut(head, slow);        <span class="hljs-comment">// 比较</span>        <span class="hljs-keyword">return</span> isEqual(head, <span class="hljs-keyword">reverse</span>(slow));            &#125;        <span class="hljs-comment">// 切</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> cut (ListNode head, ListNode cutNode) &#123;        ListNode node = head;        <span class="hljs-comment">// 循环遍历找到和cutNode相等的结点的前一个结点</span>        <span class="hljs-keyword">while</span>(node.<span class="hljs-keyword">next</span> != cutNode) &#123;            node = node.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-comment">// 然后直接null</span>        node.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;    &#125;        <span class="hljs-comment">// 反转链表派上用场</span>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-keyword">reverse</span>(ListNode head) &#123;        ListNode pre = <span class="hljs-literal">null</span>;        ListNode cur = head;        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;            ListNode nextNode = cur.<span class="hljs-keyword">next</span>;            cur.<span class="hljs-keyword">next</span> = pre;            pre = cur;            cur = nextNode;        &#125;        <span class="hljs-keyword">return</span> pre;    &#125;            <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isEqual(ListNode l1, ListNode l2) &#123;        <span class="hljs-comment">// 二者都不为空才行</span>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// 二者值不相等直接false</span>            <span class="hljs-keyword">if</span>(l1.val != l2.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            <span class="hljs-comment">// 移动</span>            l1 = l1.<span class="hljs-keyword">next</span>;            l2 = l2.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-comment">// 比如就true</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><h3 id="14-奇偶链表-317"><a href="#14-奇偶链表-317" class="headerlink" title="14. 奇偶链表(317)"></a>14. 奇偶链表(317)</h3><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">https://leetcode-cn.com/problems/odd-even-linked-list/</a></p><pre><code class="hljs awk">class Solution &#123;    public ListNode oddEvenList(ListNode head) &#123;        <span class="hljs-keyword">if</span> (head == null) return head;        <span class="hljs-regexp">//</span> 临时变量 奇头 偶头下 偶头部        ListNode odd = head, even = head.<span class="hljs-keyword">next</span>, evenHead = even;        <span class="hljs-regexp">//</span> 循环遍历偶和偶下不为空        <span class="hljs-keyword">while</span> (even != null &amp;&amp; even.<span class="hljs-keyword">next</span> != null) &#123;            <span class="hljs-regexp">//</span> 奇 -&gt; 奇下下            odd.<span class="hljs-keyword">next</span> = odd.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            <span class="hljs-regexp">//</span> 奇移动一步            odd = odd.<span class="hljs-keyword">next</span>;            <span class="hljs-regexp">//</span> 偶 -&gt; 偶下下            even.<span class="hljs-keyword">next</span> = even.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            <span class="hljs-regexp">//</span> 偶移动            even = even.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-regexp">//</span> 奇 -&gt; 偶头        odd.<span class="hljs-keyword">next</span> = evenHead;        <span class="hljs-regexp">//</span> 返回head        return head;    &#125;&#125;</code></pre><h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">https://leetcode-cn.com/problems/reverse-linked-list-ii/</a></p><pre><code class="hljs axapta"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 定位到要反转部分的头节点 2，head = 2；前驱结点 1，pre = 1；</span><span class="hljs-comment"> * 当前节点的下一个节点3调整为前驱节点的下一个节点 1-&gt;3-&gt;2-&gt;4-&gt;5,</span><span class="hljs-comment"> * 当前结点仍为2， 前驱结点依然是1，重复上一步操作。。。</span><span class="hljs-comment"> * 1-&gt;4-&gt;3-&gt;2-&gt;5.</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode reverseBetween(ListNode head, <span class="hljs-built_in">int</span> m, <span class="hljs-built_in">int</span> n) &#123;        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        dummy.<span class="hljs-keyword">next</span> = head;        ListNode pre = dummy, cur, <span class="hljs-keyword">next</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)             pre = pre.<span class="hljs-keyword">next</span>;        cur  = pre.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = m; i &lt; n; i++) &#123;            <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;            cur.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = pre.<span class="hljs-keyword">next</span>;            pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">return</span> dummy.<span class="hljs-keyword">next</span>;    &#125;&#125;<span class="hljs-comment">// 投机取巧 缓存</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode reverseBetween(ListNode head, <span class="hljs-built_in">int</span> m, <span class="hljs-built_in">int</span> n) &#123;        ListNode p = head;        <span class="hljs-built_in">int</span> idx = <span class="hljs-number">1</span>;        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (idx &gt;= m &amp;&amp; idx &lt;= n)                stack.push(p.val);            idx++;            p = p.<span class="hljs-keyword">next</span>;        &#125;        idx = <span class="hljs-number">1</span>;        p = head;        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (idx &gt;= m &amp;&amp; idx &lt;= n)                p.val = stack.pop();            idx++;            p = p.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;&#125;</code></pre><h3 id="15-K-个一组翻转链表-字节爱考"><a href="#15-K-个一组翻转链表-字节爱考" class="headerlink" title="15. K 个一组翻转链表(字节爱考)"></a>15. K 个一组翻转链表(字节爱考)</h3><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p><pre><code class="hljs awk">class Solution &#123;    public ListNode reverseKGroup(ListNode head, int k) &#123;        ListNode dummy = new ListNode(<span class="hljs-number">0</span>), pre = dummy, curr = head, <span class="hljs-keyword">next</span>;        <span class="hljs-regexp">//</span> 临时赋值        dummy.<span class="hljs-keyword">next</span> = head;        <span class="hljs-regexp">//</span> 算长度        int len = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (head != null) &#123;            len++;            head = head.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-regexp">//</span> 从头        head = dummy.<span class="hljs-keyword">next</span>;        <span class="hljs-regexp">//</span> 两重<span class="hljs-keyword">for</span>遍历        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; len / k; i++) &#123;            <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; k - <span class="hljs-number">1</span>; j++) &#123;                <span class="hljs-regexp">//</span> 谜一般的操作                <span class="hljs-regexp">//</span> 临时<span class="hljs-keyword">next</span>                <span class="hljs-keyword">next</span> = curr.<span class="hljs-keyword">next</span>;                <span class="hljs-regexp">//</span> 我指向你                curr.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;                <span class="hljs-regexp">//</span> 你指向他                <span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> = pre.<span class="hljs-keyword">next</span>;                <span class="hljs-regexp">//</span> 他指向临时                pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;            &#125;            pre = curr; <span class="hljs-regexp">//</span> 移动            curr = pre.<span class="hljs-keyword">next</span>; <span class="hljs-regexp">//</span> 移动        &#125;        return dummy.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre><h3 id="16-奇数位升序偶数位降序的链表"><a href="#16-奇数位升序偶数位降序的链表" class="headerlink" title="16. 奇数位升序偶数位降序的链表"></a>16. 奇数位升序偶数位降序的链表</h3><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode oddEvenLinkedList(ListNode head) &#123;    <span class="hljs-comment">// 将偶数链表拆分出来</span>    ListNode evenHead = getEvenList(head);    <span class="hljs-comment">// 逆序偶数链表</span>    ListNode reEvenHead = reverseList(evenHead);    <span class="hljs-comment">// 归并奇偶链表</span>    ListNode mHead = mergeList(head, reEvenHead);    <span class="hljs-keyword">return</span> mHead;&#125; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode getEvenList(ListNode head) &#123;    ListNode odd = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);    ListNode even = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);    <span class="hljs-built_in">int</span> cnt = <span class="hljs-number">1</span>;    ListNode cur1 = odd, cur2 = even;    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;            cur1.<span class="hljs-keyword">next</span> = head;            cur1 = cur1.<span class="hljs-keyword">next</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            cur2.<span class="hljs-keyword">next</span> = head;            cur2 = cur2.<span class="hljs-keyword">next</span>;        &#125;        head = head.<span class="hljs-keyword">next</span>;        cnt++;    &#125;    cur1.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;    cur2.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> even.<span class="hljs-keyword">next</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode reverseList(ListNode head) &#123;    ListNode pre = <span class="hljs-literal">null</span>;    ListNode cur = head;    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;        ListNode <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;        cur.<span class="hljs-keyword">next</span> = pre;        pre = cur;        cur = <span class="hljs-keyword">next</span>;    &#125;    <span class="hljs-keyword">return</span> pre;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode mergeList(ListNode l1, ListNode l2)&#123;    <span class="hljs-comment">// 我用递归</span>    <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>)         <span class="hljs-keyword">return</span> l2;    <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>)        <span class="hljs-keyword">return</span> l1;    <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;        l1.<span class="hljs-keyword">next</span> = mergeList(l1.<span class="hljs-keyword">next</span>, l2);        <span class="hljs-keyword">return</span> l1;    &#125; <span class="hljs-keyword">else</span> &#123;        l2.<span class="hljs-keyword">next</span> = mergeList(l1, l2.<span class="hljs-keyword">next</span>);        <span class="hljs-keyword">return</span> l2;    &#125;&#125;</code></pre><h3 id="17-分隔链表"><a href="#17-分隔链表" class="headerlink" title="17. 分隔链表"></a>17. 分隔链表</h3><p><a href="https://leetcode-cn.com/problems/partition-list/">https://leetcode-cn.com/problems/partition-list/</a></p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode partition(ListNode head, <span class="hljs-built_in">int</span> x) &#123;        ListNode dummy1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode dummy2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode node1 = dummy1, node2 = dummy2;        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">if</span> (head.val &lt; x)&#123;                node1.<span class="hljs-keyword">next</span> = head;                <span class="hljs-comment">// 你左脚走</span>                head = head.<span class="hljs-keyword">next</span>;                <span class="hljs-comment">// 1也左脚走</span>                node1 = node1.<span class="hljs-keyword">next</span>;                <span class="hljs-comment">// 直接割，我不需要</span>                node1.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                node2.<span class="hljs-keyword">next</span> = head;                head = head.<span class="hljs-keyword">next</span>;                node2 = node2.<span class="hljs-keyword">next</span>;                node2.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;            &#125;        &#125;        node1.<span class="hljs-keyword">next</span> = dummy2.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">return</span> dummy1.<span class="hljs-keyword">next</span>;    &#125;&#125;</code></pre><h3 id="18-排序链表"><a href="#18-排序链表" class="headerlink" title="18 排序链表"></a>18 排序链表</h3><p><a href="https://leetcode-cn.com/problems/sort-list/">https://leetcode-cn.com/problems/sort-list/</a></p><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode <span class="hljs-function"><span class="hljs-title">sortList</span>(<span class="hljs-params">ListNode head</span>)</span> &#123;        <span class="hljs-keyword">return</span> head == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : mergeSort(head);    &#125;    <span class="hljs-keyword">private</span> ListNode <span class="hljs-function"><span class="hljs-title">mergeSort</span>(<span class="hljs-params">ListNode head</span>)</span> &#123;        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> head;        ListNode p = head, q = head, pre = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">null</span> &amp;&amp; q.next != <span class="hljs-literal">null</span>)&#123;            pre = p;            p = p.next;            q = q.next.next;        &#125;        pre.next = <span class="hljs-literal">null</span>;        ListNode l = mergeSort(head);        ListNode r = mergeSort(p);        <span class="hljs-keyword">return</span> merge(l, r);    &#125;    <span class="hljs-keyword">private</span> ListNode <span class="hljs-function"><span class="hljs-title">merge</span>(<span class="hljs-params">ListNode l1, ListNode l2</span>)</span>&#123;        <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> l2;        <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>)            <span class="hljs-keyword">return</span> l1;        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val)&#123;            l1.next = merge(l1.next, l2);            <span class="hljs-keyword">return</span> l1;        &#125; <span class="hljs-keyword">else</span> &#123;            l2.next = merge(l1, l2.next);            <span class="hljs-keyword">return</span> l2;        &#125;    &#125;&#125;</code></pre><h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h3><p><a href="https://leetcode-cn.com/problems/reorder-list/">https://leetcode-cn.com/problems/reorder-list/</a></p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> reorderList(ListNode head) &#123;        LinkedList&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        ListNode cur = head;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;            queue.addLast(cur);            cur = cur.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>)                cur = queue.pollFirst();            <span class="hljs-keyword">else</span> &#123;                cur.<span class="hljs-keyword">next</span> = queue.pollFirst();                cur = cur.<span class="hljs-keyword">next</span>;            &#125;            cur.<span class="hljs-keyword">next</span> = queue.pollLast();            cur = cur.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">null</span>)             cur.<span class="hljs-keyword">next</span> = <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h3><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode removeNthFromEnd(ListNode head, <span class="hljs-built_in">int</span> n) &#123;        ListNode fast = head;        <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;            fast = fast.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-comment">// 这里没懂， 得举例子就懂了</span>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head.<span class="hljs-keyword">next</span>;        ListNode slow = head;        <span class="hljs-keyword">while</span> (fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>) &#123;            fast = fast.<span class="hljs-keyword">next</span>;            slow = slow.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-comment">// 这里也懂了...举个例子就行</span>        slow.<span class="hljs-keyword">next</span> = slow.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">return</span> head;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL语句练习</title>
    <link href="/2021/03/17/SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/"/>
    <url>/2021/03/17/SQL%E8%AF%AD%E5%8F%A5%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1、组合两个表"><a href="#1、组合两个表" class="headerlink" title="1、组合两个表"></a>1、<a href="https://leetcode-cn.com/problems/combine-two-tables/">组合两个表</a></h2><p>表1：Person</p><pre><code class="hljs asciidoc"><span class="hljs-code">+-------------+</span>---------+| 列名         | 类型     |<span class="hljs-code">+-------------+</span>---------+| PersonId    | int     || FirstName   | varchar || LastName    | varchar |<span class="hljs-code">+-------------+</span>---------+PersonId 是上表主键</code></pre><p>表2：Address</p><pre><code class="hljs asciidoc"><span class="hljs-code">+-------------+</span>---------+| 列名         | 类型    |<span class="hljs-code">+-------------+</span>---------+| AddressId   | int     || PersonId    | int     || City        | varchar || State       | varchar |<span class="hljs-code">+-------------+</span>---------+AddressId 是上表主键</code></pre><p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> FirstName, LastName, City, State<span class="hljs-keyword">from</span> Person p <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Address a <span class="hljs-keyword">on</span> p.PersonId = a.PersonId;</code></pre><h2 id="2、第二个高薪水"><a href="#2、第二个高薪水" class="headerlink" title="2、第二个高薪水"></a>2、<a href="https://leetcode-cn.com/problems/second-highest-salary/">第二个高薪水</a></h2><p>编写一个 SQL 查询，获取 Employee 表中第二高的薪水（Salary） 。</p><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>--------+| Id | Salary |<span class="hljs-code">+----+</span>--------+| 1  | 100    || 2  | 200    || 3  | 300    |<span class="hljs-code">+----+</span>--------+</code></pre><p>例如上述 Employee 表，SQL查询应该返回 200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。</p><pre><code class="hljs asciidoc"><span class="hljs-code">+---------------------+</span>| SecondHighestSalary |<span class="hljs-code">+---------------------+</span>| 200                 |<span class="hljs-code">+---------------------+</span>select (select distinct(Salary) from Employeeorder by Salary desclimit 1,1) as SecondHighestSalary</code></pre><h2 id="3、超过经理收入的员工"><a href="#3、超过经理收入的员工" class="headerlink" title="3、超过经理收入的员工"></a>3、<a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/">超过经理收入的员工</a></h2><p>Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p><pre><code class="hljs gherkin">+----+-------+--------+-----------+|<span class="hljs-string"> Id </span>|<span class="hljs-string"> Name  </span>|<span class="hljs-string"> Salary </span>|<span class="hljs-string"> ManagerId </span>|+----+-------+--------+-----------+|<span class="hljs-string"> 1  </span>|<span class="hljs-string"> Joe   </span>|<span class="hljs-string"> 70000  </span>|<span class="hljs-string"> 3         </span>||<span class="hljs-string"> 2  </span>|<span class="hljs-string"> Henry </span>|<span class="hljs-string"> 80000  </span>|<span class="hljs-string"> 4         </span>||<span class="hljs-string"> 3  </span>|<span class="hljs-string"> Sam   </span>|<span class="hljs-string"> 60000  </span>|<span class="hljs-string"> NULL      </span>||<span class="hljs-string"> 4  </span>|<span class="hljs-string"> Max   </span>|<span class="hljs-string"> 90000  </span>|<span class="hljs-string"> NULL      </span>|+----+-------+--------+-----------+</code></pre><p>给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p><pre><code class="hljs asciidoc"><span class="hljs-code">+----------+</span>| Employee |<span class="hljs-code">+----------+</span>| Joe      |<span class="hljs-code">+----------+</span>select Name Employeefrom Employee awhere Salary &gt; (select Salary from Employee where Id = a.ManagerId);</code></pre><h2 id="4、查找重复的电子邮箱"><a href="#4、查找重复的电子邮箱" class="headerlink" title="4、查找重复的电子邮箱"></a>4、<a href="https://leetcode-cn.com/problems/duplicate-emails/">查找重复的电子邮箱</a></h2><p>编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。</p><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>---------+| Id | Email   |<span class="hljs-code">+----+</span>---------+| 1  | a@b.com || 2  | c@d.com || 3  | a@b.com |<span class="hljs-code">+----+</span>---------+</code></pre><p>根据以上输入，你的查询应返回以下结果：</p><pre><code class="hljs asciidoc"><span class="hljs-code">+---------+</span>| Email   |<span class="hljs-code">+---------+</span>| a@b.com |<span class="hljs-code">+---------+</span>select email from Person group by email having count(email)&gt;1;select distinct(p1.Email) from Person p1 join Person p2 on p1.email = p2.email and p1.Id != p2.Id;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合总结</title>
    <link href="/2021/03/17/%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"/>
    <url>/2021/03/17/%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h1><h3 id="1-Arraylist与LinkedList区别"><a href="#1-Arraylist与LinkedList区别" class="headerlink" title="1. Arraylist与LinkedList区别"></a>1. Arraylist与LinkedList区别</h3><ul><li>ArrayList是数组的数据结构（默认大小为10），LinkedList是链表的数据结构。</li><li>ArrayList随机访问效率高，LinkedList插入删除效率高。</li><li>LinkedList因还需存储引用，开销更大。</li></ul><blockquote><p>Arraylist集合插入一万条数据，如何提高效率？</p><p>ArrayList的底层是数组实现,并且数组的默认值是10,如果插入10000条要不断的扩容,耗费时间,所以我们调用ArrayList的指定容量的构造器方法ArrayList(int size) 就可以实现不扩容,就提高了性能。</p></blockquote><h3 id="2-Collections-sort和Arrays-sort的实现原理"><a href="#2-Collections-sort和Arrays-sort的实现原理" class="headerlink" title="2. Collections.sort和Arrays.sort的实现原理"></a>2. Collections.sort和Arrays.sort的实现原理</h3><p>Collection.sort是对list进行排序，Arrays.sort是对数组进行排序。</p><p>Collections.sort方法调用了list.sort方法 ，而list.sort调用Arrays.sort方法，总结即为<strong>Collections.sort方法底层就是调用的Array.sort方法</strong>。</p><blockquote><p>Arrays的sort方法底层就是：</p><ul><li>legacyMergeSort(a)，归并排序，</li><li>ComparableTimSort.sort()：即Timsort排序。</li></ul></blockquote><blockquote><p>Timsort为结合归并与插入排序得到的排序方法。</p></blockquote><h3 id="3-HashMap原理"><a href="#3-HashMap原理" class="headerlink" title="3. HashMap原理"></a>3. HashMap原理</h3><ul><li>HashMap是以键值对存储数据的集合容器</li><li>HashMap是非线性安全的。</li><li>HashMap底层数据结构：数组+(链表、红黑树)，jdk8之前是用数组+链表的方式实现，jdk8引进了红黑树</li><li>Hashmap数组的默认初始长度是16，key和value都允许null的存在</li><li>HashMap的put方法，首先计算key的hashcode值，定位到对应的数组索引，然后再在该索引的单向链表上进行循环遍历，用equals比较key是否存在，如果存在则用新的value覆盖原值，如果不存在则向后追加。</li><li>HashMap大小为什么是2的幂次方？效率高+空间分布均匀</li></ul><blockquote><p>HashMap解决哈希冲突？</p><p>Hashmap解决hash冲突，使用的是链地址法，即数组+链表的形式来解决。put执行首先判断table[i]位置，如果为空就直接插入，不为空判断和当前值是否相等，相等就覆盖，如果不相等的话，判断是否是红黑树节点，如果不是，就从table[i]位置开始遍历链表，相等覆盖，不相等插入。</p></blockquote><h3 id="4-List-和-Set，Map-的区别"><a href="#4-List-和-Set，Map-的区别" class="headerlink" title="4. List 和 Set，Map 的区别"></a>4. List 和 Set，Map 的区别</h3><ul><li>List 以索引来存取元素，有序的，元素是允许重复的，可以插入多个null。且List 有基于数组、链表实现两种方式。</li><li>Set 不能存放重复元素，无序的，只允许一个null。</li><li>Set、Map 容器有基于哈希存储和红黑树两种方式实现。</li><li>Set 基于 Map 实现，Set 里的元素值就是 Map的键值。</li><li>Map存储键值对映射。</li></ul><h3 id="5-HashMap，HashTable，ConcurrentHashMap的共同点和区别"><a href="#5-HashMap，HashTable，ConcurrentHashMap的共同点和区别" class="headerlink" title="5. HashMap，HashTable，ConcurrentHashMap的共同点和区别"></a>5. HashMap，HashTable，ConcurrentHashMap的共同点和区别</h3><h4 id="5-1-HashMap"><a href="#5-1-HashMap" class="headerlink" title="5.1.HashMap"></a>5.1.HashMap</h4><p><strong>HashMap</strong></p><ul><li>底层由链表+数组+红黑树实现</li><li>可以存储null键和null值</li><li>线性不安全</li><li>初始容量为16，扩容每次都是2的n次幂</li><li>加载因子为0.75，当Map中元素总数超过Entry数组的0.75，触发扩容操作.</li><li>并发情况下，HashMap进行put操作会引起死循环，导致CPU利用率接近100%</li><li>HashMap是对Map接口的实现</li></ul><h4 id="5-2HashTable"><a href="#5-2HashTable" class="headerlink" title="5.2HashTable"></a>5.2HashTable</h4><p><strong>HashTable</strong></p><ul><li>HashTable的底层也是由链表+数组+红黑树实现。</li><li>无论key还是value都不能为null</li><li>它是线性安全的，使用了synchronized关键字。</li><li>HashTable实现了Map接口和Dictionary抽象类</li><li>Hashtable初始容量为11</li></ul><h4 id="5-3ConcurrentHashMap"><a href="#5-3ConcurrentHashMap" class="headerlink" title="5.3ConcurrentHashMap"></a>5.3ConcurrentHashMap</h4><p><strong>ConcurrentHashMap</strong></p><ul><li>ConcurrentHashMap的底层是数组+链表+红黑树</li><li>不能存储null键和值</li><li>ConcurrentHashMap是线程安全的</li><li>ConcurrentHashMap使用锁分段技术确保线性安全</li><li>JDK8为何又放弃分段锁，是因为多个分段锁浪费内存空间，竞争同一个锁的概率非常小，分段锁反而会造成效率低。</li></ul><h3 id="6-Java中打印数组？"><a href="#6-Java中打印数组？" class="headerlink" title="6. Java中打印数组？"></a>6. Java中打印数组？</h3><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;        <span class="hljs-built_in">String</span>[] <span class="hljs-built_in">Array</span> = &#123;<span class="hljs-string">&quot;xiaoliu&quot;</span>, <span class="hljs-string">&quot;boy&quot;</span>&#125;;        System.out.println(Arrays.toString(<span class="hljs-built_in">Array</span>));    &#125;&#125;<span class="hljs-comment">//output</span>[xiaoliu, boy]</code></pre><h3 id="7-HashMap-的扩容过程"><a href="#7-HashMap-的扩容过程" class="headerlink" title="7. HashMap 的扩容过程"></a>7. HashMap 的扩容过程</h3><p>Hashmap的扩容：</p><ul><li>第一步把数组长度变为原来的两倍，</li><li>第二步把旧数组的元素重新计算hash插入到新数组中。</li><li>jdk8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。扩容过程第二步一个非常重要的方法是transfer方法，采用头插法，把旧数组的元素插入到新数组中。</li></ul><h3 id="8-HashSet是如何保证不重复的"><a href="#8-HashSet是如何保证不重复的" class="headerlink" title="8. HashSet是如何保证不重复的"></a>8. HashSet是如何保证不重复的</h3><p>其add方法，将HashMap的Key作为值存入，而HashMap的键不允许重复。</p><h3 id="9-哪些集合类是线程安全的？哪些不安全？"><a href="#9-哪些集合类是线程安全的？哪些不安全？" class="headerlink" title="9. 哪些集合类是线程安全的？哪些不安全？"></a>9. 哪些集合类是线程安全的？哪些不安全？</h3><p>线性安全的</p><ul><li>Vector：比Arraylist多了个同步化机制。</li><li>Hashtable：比Hashmap多了个线程安全。</li><li>ConcurrentHashMap:是一种高效但是线程安全的集合。</li><li>Stack：栈，也是线程安全的，继承于Vector。</li></ul><p>线性不安全的</p><ul><li>Hashmap</li><li>Arraylist</li><li>LinkedList</li><li>HashSet</li><li>TreeSet</li><li>TreeM</li></ul><h3 id="10-Collection与Collections的区别是什么？"><a href="#10-Collection与Collections的区别是什么？" class="headerlink" title="10.Collection与Collections的区别是什么？"></a>10.Collection与Collections的区别是什么？</h3><ul><li><p>Collection是Java集合框架中的基本接口，如List接口也是继承于它</p><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">List</span>&lt;<span class="hljs-symbol">E</span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Collection</span>&lt;<span class="hljs-symbol">E</span>&gt; &#123;&#125;</code></pre></li><li><p>Collections是Java集合框架提供的一个工具类，其中包含了大量用于操作或返回集合的静态方法。如列表的排序：</p><pre><code>  <pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-keyword">sort</span>(List&lt;T&gt; list) &#123;    list.<span class="hljs-keyword">sort</span>(<span class="hljs-keyword">null</span>);&#125;</code></pre></code></pre></li></ul><h3 id="11-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#11-快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="11. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>11. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h3><h4 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h4><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</p><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test &#123;    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;        List&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();        list.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);        list.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);        Iterator iterator = list.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(iterator.next());            list.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list.size());        &#125;    &#125;&#125;</code></pre><pre><code class="hljs reasonml"><span class="hljs-number">1</span>Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.util.ConcurrentModificationException<span class="hljs-number">3</span>at java.util.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayList$Itr</span>.</span></span>check<span class="hljs-constructor">ForComodification(ArrayList.<span class="hljs-params">java</span>:909)</span>at java.util.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayList$Itr</span>.</span></span>next(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ArrayList</span>.</span></span>java:<span class="hljs-number">859</span>)at <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>java:<span class="hljs-number">12</span>)</code></pre><h4 id="安全失败"><a href="#安全失败" class="headerlink" title="安全失败"></a>安全失败</h4><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test &#123;    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;        List&lt;<span class="hljs-type">Integer</span>&gt; list = <span class="hljs-built_in">new</span> CopyOnWriteArrayList&lt;&gt;();        list.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>);        list.<span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>);        Iterator iterator = list.iterator();        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(iterator.next());            list.<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>);            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;list size:&quot;+list.size());        &#125;    &#125;&#125;</code></pre><pre><code class="hljs apache"><span class="hljs-attribute">1</span><span class="hljs-attribute">list</span> size:<span class="hljs-number">3</span><span class="hljs-attribute">2</span><span class="hljs-attribute">list</span> size:<span class="hljs-number">4</span></code></pre><h3 id="12-HashMap源码中的常量意义"><a href="#12-HashMap源码中的常量意义" class="headerlink" title="12.HashMap源码中的常量意义"></a>12.HashMap源码中的常量意义</h3><blockquote><p>HashMap默认初始化大小为什么是1 &lt;&lt; 4（16）？</p><p>首先为什么是2的幂：为了更高效使用与运算，数组下标索引定位公式为i = (n - 1) &amp; hash。</p><p>而当n的大小为2的倍数时，n%hash等价于(n - 1) &amp; hash。位运算的效率比取余运算高。</p><p>其次为什么是16：如果太小，4或者8，<strong>扩容比较频繁</strong>；如果太大，32或者64甚至太大，又<strong>占用内存空间</strong>。</p></blockquote><blockquote><p>HashMap默认加载因子为什么是0.75？</p><p><strong>加载因子</strong>表示哈希表的填满程度，跟扩容息息相关。如果是0.5，哈希表填到一半就开始扩容，这样会导致<strong>扩容频繁</strong>，并且空间利用率比较低。 如果是1，哈希表完全填满才开始扩容，虽然空间利用提高了，但是<strong>哈希冲突</strong>机会却大了。</p></blockquote><blockquote><p>链表转红黑树的阈值为什么是8？</p><p>因为理想状态，随机哈希码情况下，链表中元素个数为8时的概率已经非常非常小，故阈值选为8.</p></blockquote><blockquote><p>树还原为链表的阈值为什么是6？</p><p>若设置为7.当HashMap不停插入删除时，链表长度可能在8左右振荡，导致链表和树之间频繁转换。</p></blockquote><h3 id="13-红黑树的特点"><a href="#13-红黑树的特点" class="headerlink" title="13.红黑树的特点"></a>13.红黑树的特点</h3><ul><li>每个节点或者是黑色，或者是红色。</li><li>根节点是黑色。</li><li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li><li>如果一个节点是红色的，则它的子节点必须是黑色的。</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找与双指针</title>
    <link href="/2021/03/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/03/16/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="常见的算法模板"><a href="#常见的算法模板" class="headerlink" title="常见的算法模板"></a>常见的算法模板</h1><h1 id="查找一个数的模板框架"><a href="#查找一个数的模板框架" class="headerlink" title="查找一个数的模板框架"></a>查找一个数的模板框架</h1><p>思维框架：</p><p>1.定义<strong>搜索区间</strong></p><p>2.根据搜索区间定义循环结束条件</p><p>3.取中间元素和目标元素对比</p><p>4.根据比较结果收缩区间，舍弃非法解</p><blockquote><p>数组中有无重复元素，两种情况下解法有区别，判断条件特别对待</p></blockquote><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-comment">// 左右都闭合的区间 [l, r]</span>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(nums[mid] == target)            <span class="hljs-keyword">return</span> mid;        <span class="hljs-keyword">if</span> (nums[mid] &lt; target)      <span class="hljs-comment">// 搜索区间变为 [mid+1, right]</span>            left = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (nums[mid] &gt; target)            <span class="hljs-comment">// 搜索区间变为 [left, mid - 1]</span>            right = mid - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre><h2 id="寻找数组最左边满足条件的值"><a href="#寻找数组最左边满足条件的值" class="headerlink" title="寻找数组最左边满足条件的值"></a>寻找数组最左边满足条件的值</h2><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> binarySearchLeft(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target) &#123;// 搜索区间为 [<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>]    <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = nums.length - <span class="hljs-number">1</span>;    while (<span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span>) &#123;        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span> + (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &lt; target) &#123;            // 搜索区间变为 [<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>]            <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &gt; target) &#123;            // 搜索区间变为 [<span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span>-<span class="hljs-number">1</span>]            <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] == target) &#123;            // 收缩右边界,寻找新备胎，没找到，最后<span class="hljs-built_in">left</span>收缩左边界也会返回此备胎处            <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;        &#125;    &#125;    // 检查是否越界    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &gt;= nums.length || nums[<span class="hljs-built_in">left</span>] != target)        return -<span class="hljs-number">1</span>;    return <span class="hljs-built_in">left</span>;&#125;</code></pre><h2 id="寻找数组最右边满足条件的值"><a href="#寻找数组最右边满足条件的值" class="headerlink" title="寻找数组最右边满足条件的值"></a>寻找数组最右边满足条件的值</h2><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> binarySearchRight(<span class="hljs-built_in">int</span>[] nums, <span class="hljs-built_in">int</span> target) &#123;// 搜索区间为 [<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>]    <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span> = nums.length - <span class="hljs-number">1</span>;    while (<span class="hljs-built_in">left</span> &lt;= <span class="hljs-built_in">right</span>) &#123;        <span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = <span class="hljs-built_in">left</span> + (<span class="hljs-built_in">right</span> - <span class="hljs-built_in">left</span>) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &lt; target) &#123;// 搜索区间变为 [<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>]            <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] &gt; target) &#123;// 搜索区间变为 [<span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span>-<span class="hljs-number">1</span>]            <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span> - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-built_in">if</span> (nums[<span class="hljs-built_in">mid</span>] == target) &#123;            // 收缩左边界            <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>;        &#125;    &#125;    // 检查是否越界    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">right</span> &lt; <span class="hljs-number">0</span> || nums[<span class="hljs-built_in">right</span>] != target)        return -<span class="hljs-number">1</span>;    return <span class="hljs-built_in">right</span>;&#125;</code></pre><h2 id="二维数组查找"><a href="#二维数组查找" class="headerlink" title="二维数组查找"></a>二维数组查找</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><pre><code class="hljs angelscript">编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：每行中的整数从左到右按升序排列。每行的第一个整数大于前一行的最后一个整数。示例 <span class="hljs-number">1</span>:输入:matrix = [<span class="hljs-string">  [1,   3,  5,  7]</span>,<span class="hljs-string">  [10, 11, 16, 20]</span>,<span class="hljs-string">  [23, 30, 34, 50]</span>]target = <span class="hljs-number">3</span>输出: <span class="hljs-literal">true</span>示例 <span class="hljs-number">2</span>:输入:matrix = [<span class="hljs-string">  [1,   3,  5,  7]</span>,<span class="hljs-string">  [10, 11, 16, 20]</span>,<span class="hljs-string">  [23, 30, 34, 50]</span>]target = <span class="hljs-number">13</span>输出: <span class="hljs-literal">false</span></code></pre><p>解法：从左下角元素开始寻找</p><p>模板如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchMatrix</span>(<span class="hljs-params">self, matrix: List[List[<span class="hljs-built_in">int</span>]], target: <span class="hljs-built_in">int</span></span>) -&gt; bool:</span>        m = <span class="hljs-built_in">len</span>(matrix)        <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        n = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])        x = m - <span class="hljs-number">1</span>        y = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> x &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y &lt; n:            <span class="hljs-keyword">if</span> matrix[x][y] &gt; target:                x -= <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> matrix[x][y] &lt; target:                y += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><h2 id="二分查找练习题"><a href="#二分查找练习题" class="headerlink" title="二分查找练习题"></a>二分查找练习题</h2><h3 id="857-爱吃香蕉的珂珂"><a href="#857-爱吃香蕉的珂珂" class="headerlink" title="857.爱吃香蕉的珂珂"></a>857.爱吃香蕉的珂珂</h3><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。 </p><p>示例 1：</p><p>输入: piles = [3,6,7,11], H = 8<br>输出: 4<br>示例 2：</p><p>输入: piles = [30,11,23,4,20], H = 5<br>输出: 30<br>示例 3：</p><p>输入: piles = [30,11,23,4,20], H = 6<br>输出: 23</p><pre><code class="hljs plain"></code></pre><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h3><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p><p>输入：nums = [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p><p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p><pre><code class="hljs plain"></code></pre><h3 id="354-俄罗斯套娃信封"><a href="#354-俄罗斯套娃信封" class="headerlink" title="354.俄罗斯套娃信封"></a>354.俄罗斯套娃信封</h3><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>注意：不允许旋转信封。</p><p>示例 1：</p><p>输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]<br>输出：3<br>解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。<br>示例 2：</p><p>输入：envelopes = [[1,1],[1,1],[1,1]]<br>输出：1</p><pre><code class="hljs plain"></code></pre><h3 id="17-08马戏团人塔"><a href="#17-08马戏团人塔" class="headerlink" title="17.08马戏团人塔"></a>17.08马戏团人塔</h3><p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p><p>示例：</p><p>输入：height = [65,70,56,75,60,68] weight = [100,150,90,190,95,110]<br>输出：6<br>解释：从上往下数，叠罗汉最多能叠 6 层：(56,90), (60,95), (65,100), (68,110), (70,150), (75,190)</p><pre><code class="hljs plain"></code></pre><h1 id="双指针解题模板"><a href="#双指针解题模板" class="headerlink" title="双指针解题模板"></a>双指针解题模板</h1><blockquote><p>包含三种类型：快慢指针–两指针步长不同</p><p>​                            左右端点指针–两指针分别头尾</p><p>​                            固定间距指针–两指针步长间距相等</p></blockquote><p>1.快慢指针</p><pre><code class="hljs apache"><span class="hljs-attribute">l</span> = <span class="hljs-number">0</span><span class="hljs-attribute">r</span> = <span class="hljs-number">0</span><span class="hljs-attribute">while</span> 没有遍历完  <span class="hljs-attribute">if</span> 一定条件    <span class="hljs-attribute">l</span> += <span class="hljs-number">1</span>  <span class="hljs-attribute">r</span> += <span class="hljs-number">1</span><span class="hljs-attribute">return</span> 合适的值</code></pre><p>2.左右端点指针</p><pre><code class="hljs javascript">l = <span class="hljs-number">0</span>r = n - <span class="hljs-number">1</span><span class="hljs-keyword">while</span> l &lt; r  <span class="hljs-keyword">if</span> 找到了    <span class="hljs-keyword">return</span> 找到的值  <span class="hljs-keyword">if</span> 一定条件<span class="hljs-number">1</span>    l += <span class="hljs-number">1</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>  一定条件<span class="hljs-number">2</span>    r -= <span class="hljs-number">1</span><span class="hljs-keyword">return</span> 没找到</code></pre><p>3.固定间距指针</p><pre><code class="hljs powershell">l = <span class="hljs-number">0</span><span class="hljs-built_in">r</span> = k<span class="hljs-keyword">while</span> 没有遍历完  自定义逻辑  l += <span class="hljs-number">1</span>  <span class="hljs-built_in">r</span> += <span class="hljs-number">1</span><span class="hljs-keyword">return</span> 合适的值</code></pre><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>通常用来判断链表是否有环</p><h2 id="快慢指针练习题"><a href="#快慢指针练习题" class="headerlink" title="快慢指针练习题"></a>快慢指针练习题</h2><h3 id="80-删除排序数组中的重复项"><a href="#80-删除排序数组中的重复项" class="headerlink" title="80.删除排序数组中的重复项"></a>80.删除排序数组中的重复项</h3><p>删除排序数组中的重复项，使得相同数字最多出现K次。例如最多出现两次的示例情况</p><pre><code class="hljs nix">示例 <span class="hljs-number">1</span>:给定 <span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],函数应返回新长度 <span class="hljs-attr">length</span> = <span class="hljs-number">5</span>, 并且原数组的前五个元素被修改为 <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> 。你不需要考虑数组中超出新长度后面的元素。示例 <span class="hljs-number">2</span>:给定 <span class="hljs-attr">nums</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>],函数应返回新长度 <span class="hljs-attr">length</span> = <span class="hljs-number">7</span>, 并且原数组的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span> 。</code></pre><p>最多出现一次的代码模板：</p><pre><code class="hljs axapta"><span class="hljs-comment">// 时间复杂度O(n) 空间复杂度O(1)</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> removeDuplicates(<span class="hljs-built_in">int</span>[] nums) &#123;       <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span> || nums.length  == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;i &lt; nums.length;i++)&#123;           <span class="hljs-keyword">if</span>(nums[<span class="hljs-keyword">index</span>] != nums[i])&#123;               <span class="hljs-keyword">index</span>++;               nums[<span class="hljs-keyword">index</span>] = nums[i];           &#125;       &#125;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>;   &#125;</code></pre><p>最多出现两次的代码模板：</p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> removeDuplicates(<span class="hljs-built_in">int</span>[] nums) &#123;       <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-keyword">if</span>(nums.length&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums.length;       <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> =<span class="hljs-number">1</span>;       <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i =<span class="hljs-number">2</span>;i&lt;nums.length;i++)&#123;           <span class="hljs-keyword">if</span>(nums[i]!=nums[<span class="hljs-keyword">index</span><span class="hljs-number">-1</span>])&#123;               <span class="hljs-keyword">index</span>++;               nums[<span class="hljs-keyword">index</span>]=nums[i];           &#125;       &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>最多出现K次的代码模板：</p><pre><code class="hljs glsl">public <span class="hljs-type">int</span> removeDuplicates(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> k) &#123;        <span class="hljs-keyword">if</span>(nums == null) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">length</span> &lt;= k) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">length</span>;                <span class="hljs-comment">// 1.定义[0,index] 是修改后的满足要求的数组区间,这里已经把0 1 2 ...k- 1 ,共k个数 放进去了</span>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = k - <span class="hljs-number">1</span>;        <span class="hljs-comment">// 2.判断终止条件</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k;i &lt; nums.<span class="hljs-built_in">length</span>;i++)&#123;            <span class="hljs-comment">// 3.指针移动条件</span>            <span class="hljs-keyword">if</span>(nums[i] != nums[<span class="hljs-keyword">index</span>-k+<span class="hljs-number">1</span>])&#123;     <span class="hljs-comment">//找出指针移动规律是关键</span>                <span class="hljs-keyword">index</span>++;                nums[<span class="hljs-keyword">index</span>] = nums[i];            &#125;        &#125;        <span class="hljs-comment">// 4.判断返回值</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>;    &#125;</code></pre><h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26.删除有序数组中的重复项"></a>26.删除有序数组中的重复项</h3><p>给你一个有序数组 <code>nums</code> ，请你原地删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p><pre><code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> removeDuplicates(<span class="hljs-built_in">int</span>[] nums) &#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;            <span class="hljs-keyword">if</span>(nums[<span class="hljs-keyword">index</span>] != nums[i])&#123;                <span class="hljs-keyword">index</span>++;                nums[<span class="hljs-keyword">index</span>] = nums[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h3><p>使用快慢指针找环，一个一次移动一个节点，一个一次移动两个节点，若有环，两指针一定会相遇。</p><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> hasCycle(ListNode head) &#123;    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    ListNode slow = head;    ListNode fast = head.<span class="hljs-keyword">next</span>;    <span class="hljs-keyword">while</span> (slow != fast) &#123;        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        slow = slow.<span class="hljs-keyword">next</span>;        fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><h3 id="142-环形链表2"><a href="#142-环形链表2" class="headerlink" title="142.环形链表2"></a>142.环形链表2</h3><p>判断链表是否有环，并返回进入环的节点。</p><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> ListNode detectCycle(ListNode head) &#123;        ListNode fast = head, slow = head;        <span class="hljs-comment">//获取首次相遇时候，slow的位置</span>        <span class="hljs-keyword">while</span>(fast!= <span class="hljs-literal">null</span> &amp;&amp; fast.<span class="hljs-keyword">next</span> != <span class="hljs-literal">null</span>)&#123;            fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;            slow = slow.<span class="hljs-keyword">next</span>;            <span class="hljs-keyword">if</span>(fast == slow)&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">//判断没环的情况，防止空指针</span>        <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.<span class="hljs-keyword">next</span> == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        <span class="hljs-comment">//快指针重新出发，相遇位置就是入口位置,两指针的行程关系</span>        fast = head;        <span class="hljs-keyword">while</span>(fast != slow)&#123;            fast = fast.<span class="hljs-keyword">next</span>;            slow = slow.<span class="hljs-keyword">next</span>;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;&#125;</code></pre><h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h3><p>判断一个数是不是快乐数。此题中快慢指针用来跳出循环。</p><p>输入：19<br>输出：true<br>解释：<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p><p>输入：n = 2<br>输出：false</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;       <span class="hljs-keyword">int</span> slow = n;       <span class="hljs-keyword">int</span> fast = jisuan(n);        <span class="hljs-keyword">while</span>(slow!=fast)&#123;            slow = jisuan(slow);            fast =jisuan(jisuan(fast));            <span class="hljs-keyword">if</span>(slow == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> slow==<span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jisuan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;        <span class="hljs-keyword">int</span> result =<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)&#123;            res = x%<span class="hljs-number">10</span>;            x = x/<span class="hljs-number">10</span>;            result+=res*res;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h2 id="左右端点指针练习题"><a href="#左右端点指针练习题" class="headerlink" title="左右端点指针练习题"></a>左右端点指针练习题</h2><h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h3><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。</p><p>示例：</p><p>输入：nums = [-1,2,1,-4], target = 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p><pre><code class="hljs plain"></code></pre><h3 id="713-乘积小于K的子数组"><a href="#713-乘积小于K的子数组" class="headerlink" title="713.乘积小于K的子数组"></a>713.乘积小于K的子数组</h3><p>给定一个正整数数组 <code>nums</code>。找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p><p>示例 1:</p><p>输入: nums = [10,5,2,6], k = 100<br>输出: 8<br>解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。<br>需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</p><pre><code class="hljs plain"></code></pre><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h3><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><p>示例 1：</p><p>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p> <pre><code class="hljs plain"></code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统原理</title>
    <link href="/2021/03/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <url>/2021/03/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h1><p>1.丢失修改</p><p>​    一个事务的更新操作被另一个事务更新操作替换。</p><blockquote><p>事务修改数据时必须加X锁，事务结束才释放锁，可解决丢失修改问题。</p></blockquote><p>2.读脏数据</p><p>​    在不同事务下，当前事务可以读到另外事务未提交数据（写后回滚）。</p><blockquote><p>读取数据时候必须加S锁，读取完马上释放S锁，可解决脏读。</p></blockquote><p>3.不可重复读</p><p>​    在一个事务内多次读取同一数据集合，过程中第二个事务对其进行修改，导致第一个事务两次读取数据不一致。</p><blockquote><p>读取数据时必须加S锁，直至事务结束才能释放S锁，可解决不可重复读。</p></blockquote><p>4.幻读</p><p>​    为不可重复读的一种情况，事务一读取某个范围内数据，事务二在此范围内插入新数据，造成两次读取数据不一致。</p><blockquote><p>产生并发不一致主要是破坏了事务的隔离性，可通过封锁实现并发控制来解决。数据库管理系统提供事务的隔离级别来处理并发一致性问题</p></blockquote><h1 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h1><p>封锁粒度主要有行级锁和表级锁两种。</p><p>封锁类型有读写锁和意向锁两种。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ol><li>互斥锁，即X锁，又称写锁。</li><li>共享锁，即S锁，又称读锁，加锁期间可读取，不能修改。</li></ol><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><blockquote><p>为更方便多粒度封锁提出，在存在行级锁和表级锁情况下，减少加锁时对每一行都要检测的消耗</p></blockquote><p>在原有X/S锁基础上引入IX/IS两种表锁，用法为：</p><ol><li>一个事务在获取某个数据行对象的S锁前，必须得到表的IS锁或更强锁。</li><li>一个事务在获取某个数据行对象的X锁前，必须得到表的IX锁。</li></ol><p>且任意IS/IX之间都是兼容的，因为其仅表示想要对表加锁，而非真正加锁。</p><p>各种锁的兼容关系表如下：</p><table>    <tr>        <td>锁名</td>        <td>X</td>        <td>IX</td>        <td>S</td>        <td>IS</td>    </tr>    <tr>        <td>X</td>        <td>0</td>        <td>0</td>        <td>0</td>        <td>0</td>    </tr>    <tr>        <td>IX</td>        <td>0</td>        <td> </td>        <td>0</td>        <td> </td>    </tr>    <tr>        <td>S</td>        <td>0</td>        <td>0</td>        <td> </td>        <td> </td>    </tr>    <tr>        <td>IS</td>        <td>0</td>        <td> </td>        <td> </td>        <td> </td>    </tr></table><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><table>    <tr>        <td>隔离级别</td>        <td>脏读</td>        <td>不可重复读</td>        <td>幻读</td>    </tr>    <tr>        <td>未提交读</td>        <td>×</td>        <td>×</td>        <td>×</td>           </tr>    <tr>        <td>提交读</td>        <td>√</td>        <td>×</td>        <td>×</td>         </tr>    <tr>        <td>可重复读</td>        <td>√</td>        <td>√</td>        <td>×</td>         </tr>    <tr>        <td>可串行化</td>        <td>√</td>        <td>√</td>        <td>√</td>    </tr></table><h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><blockquote><p>多版本并发控制MVCC是Mysql的InnoDB存储引擎实现隔离级别的具体方式，主要实现提交读和可重复读两种隔离级别。MVCC不能解决幻读问题。</p></blockquote><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>实际场景中读操作多于写操作，所以将读写分开处理。</p><p>MVCC利用多版本思想，事务的修改操作（删除，插入，更新）等会为数据行新增一个版本快照，写操作更新最新的版本快照，读操作读取旧版本快照。</p><p>读取时，根据快照的事务版本号，来判断数据行快照是否可用。</p><h1 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h1><p>根据数据表的函数依赖，来判断不符合范式的关系，主要可能产生以下四种异常：</p><ol><li><p>冗余数据</p></li><li><p>修改异常</p></li><li><p>删除异常</p></li><li><p>插入异常</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2></li></ol><p>为了解决异常，提出范式。</p><ol><li>第一范式：属性不可分。</li><li>第二范式：每个非主属性完全函数依赖于键码，可分解。</li><li>第三范式：非主属性不传递函数依赖于键码。</li></ol><p>属性不可分</p><h1 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h1><h2 id="数据库创建与使用"><a href="#数据库创建与使用" class="headerlink" title="数据库创建与使用"></a>数据库创建与使用</h2><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-keyword">test</span>;<span class="hljs-keyword">USE</span> <span class="hljs-keyword">test</span>；</code></pre><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> mytable (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> aaa, <span class="hljs-comment">--int类型，不为空</span>col1 <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">45</span>) <span class="hljs-literal">NULL</span>,PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>));</code></pre><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>增加列：</p><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> mytable<span class="hljs-keyword">ADD</span> <span class="hljs-keyword">col</span> <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">20</span>);</code></pre><p>删除列：</p><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> mytable<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> <span class="hljs-keyword">col</span>;</code></pre><p>删除表：</p><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> mytable;</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>普通插入：</p><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> mytable(<span class="hljs-keyword">id</span>, col1)<span class="hljs-keyword">VALUES</span>(val1, val2);</code></pre><p>插入检索出的数据：</p><pre><code class="hljs apache"><span class="hljs-attribute">INSERT</span> INTO mytable<span class="hljs-number">1</span>(col<span class="hljs-number">1</span>, col<span class="hljs-number">2</span>)<span class="hljs-attribute">SELECT</span> col<span class="hljs-number">1</span>, col<span class="hljs-number">2</span><span class="hljs-attribute">FROM</span> mytable<span class="hljs-number">2</span>;</code></pre><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> mytable<span class="hljs-keyword">SET</span> <span class="hljs-keyword">col</span> = val<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span></code></pre><p>使用更新和删除时，可以先SELECT语句进行测试，防止错误删除，一定要带Where子句</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>关键字DISTINCT：作用于所有列，完全相同的行仅出现一次。</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> col1, col2<span class="hljs-keyword">FROM</span> mytable;</code></pre><p>关键字LIMIT：限制返回行数，可设两个参数，第一个为起始行，默认0；第二个为返回总行数</p><p>返回前五行：</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">5</span>;</code></pre><p>返回3-5行：</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">LIMIT</span> <span class="hljs-number">2</span>, <span class="hljs-number">3</span>;</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>升序ASC,降序DESC</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> col1 <span class="hljs-keyword">DESC</span>, col2 <span class="hljs-keyword">ASC</span>;</code></pre><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ul><li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li><li><strong>_</strong> 匹配 ==1 个任意字符；</li><li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li><li>使用LIKE来进行通配符匹配</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> *<span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">col</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;[^AB]%&#x27;</span>; <span class="hljs-comment">-- 不以 A 和 B 开头的任意文本</span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>HAVING可与合计函数一起使用筛选</p><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(<span class="hljs-keyword">DISTINCT</span> col1) <span class="hljs-keyword">AS</span> avg_col<span class="hljs-keyword">FROM</span> mytable;</code></pre><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> A.<span class="hljs-keyword">value</span>, B.<span class="hljs-keyword">value</span><span class="hljs-keyword">FROM</span> tablea <span class="hljs-keyword">AS</span> A <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> tableb <span class="hljs-keyword">AS</span> B<span class="hljs-keyword">ON</span> A.<span class="hljs-keyword">key</span> = B.<span class="hljs-keyword">key</span>;</code></pre><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><p>内连接提供连接的列，而自然连接自动连接所有同名列。</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> A.value, B.value<span class="hljs-keyword">FROM</span> tablea <span class="hljs-keyword">AS</span> A <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> tableb <span class="hljs-keyword">AS</span> B;</code></pre><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>左外连接，全外连接，右外连接</p><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">col</span><span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">col</span> = <span class="hljs-number">1</span><span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">col</span><span class="hljs-keyword">FROM</span> mytable<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">col</span> =<span class="hljs-number">2</span>;</code></pre><h1 id="SQL语句练习"><a href="#SQL语句练习" class="headerlink" title="SQL语句练习"></a>SQL语句练习</h1><p>在SQLZOO进行</p>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些碎片</title>
    <link href="/2021/03/02/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%89%87/"/>
    <url>/2021/03/02/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="《沈从文传》"><a href="#《沈从文传》" class="headerlink" title="《沈从文传》"></a>《沈从文传》</h1><p>在旧年月里，中国传统的意识，多是好男儿志在四方。</p><p>我来寻找理想，读点书。</p><p>两个人对美好事物的追求，几乎立刻就要去实现，这就是浪漫。</p><p>乡下人喝杯甜酒吧，兆。</p><p>倘若你此时见我，你会明白我如何温柔，一切过去的种种，它的结果皆在把我推到身边心上。</p><p>爱不到人并不是失败，顽固的执着，不算失败的。</p><h1 id="《月上东山》"><a href="#《月上东山》" class="headerlink" title="《月上东山》"></a>《月上东山》</h1><p>平生快意无经纬，何惧东海换姜汤。–《螃蟹》</p><p>香炉里的灵火烧了道观</p><p>我已经讨厌极了两人相处中慢慢展现缺陷后分道扬镳的过程，所以从开始我就要给你看到，我傲慢又自大，冷血又毒舌，一肚子嫉妒心和占有欲，如果你这都愿意去接受，那我再给你不用于别人的东西。</p><p>心里有过你，不怕你知道，但是也就止步于有过了。心海翻腾，比现实生活表现得还澎湃，可最终只能化为水汽，让它代替我拥慰你。对不起，不够喜欢你，不敢把一生浪费在喜欢你这件事上。</p><p>你必须培养一些爱好，不要遥远空洞的目标，必须一觉醒来很清楚至少今天还能做什么。去楼下最辣的粉店吃早饭，去追一集刚更新的新番，去找一个知心老友唠嗑。你必须积攒这种微小的期待和快乐，这样才不会被遥不可及的梦和无法掌控的爱给拖垮。</p><p>人活着总要有个主题，让你魂梦系之。</p><h1 id="《秋原》"><a href="#《秋原》" class="headerlink" title="《秋原》"></a>《秋原》</h1><p>每一个旧的叙事元素，皆因历史上的污点而无法翻身，每一个新的叙事元素，在其受到公众认可的上升期，都会引发大规模无建设性的讨论。</p><p>阅读从来不应属于治愈系，而是应引导读者走出无病呻吟，因小失大的灰色地带和绝望深渊，深切体会到人生的苦难和困境，再对自己的伤痛和疲乏翻个白眼或做个鬼脸，更有力的前行。</p><p>北望今心，陈年不移。南望北野，经久不徙。</p><p>这世上多得是害怕主动迈出第一步的孤独之人。</p><p>我始终觉得没有哪个人能完完全全了解我，懂我，看光我的劣根性，我的阴暗面，我埋在温和外表小的偏激和歇斯底里。</p><p>不知为何，恰如其分的话总是姗姗来迟，错过最恰当的时机。</p><p>文坛中大多数人只可远观不可接近，光环脆弱，容易黯淡。</p><p>正义，总是被刻意昭彰才需要。</p><p>因难度而少有人问津的主题，这世界比比皆是，一代又一代的人生生灭灭，留给世界和后人的永远是谜团吗？</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习路线</title>
    <link href="/2021/01/18/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2021/01/18/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="几个方面"><a href="#几个方面" class="headerlink" title="几个方面"></a>几个方面</h1><h2 id="算法面试"><a href="#算法面试" class="headerlink" title="算法面试"></a>算法面试</h2><h2 id="操作系统与同步概念"><a href="#操作系统与同步概念" class="headerlink" title="操作系统与同步概念"></a>操作系统与同步概念</h2><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h2 id="ODD设计"><a href="#ODD设计" class="headerlink" title="ODD设计"></a>ODD设计</h2><h2 id="某些手撕题"><a href="#某些手撕题" class="headerlink" title="某些手撕题"></a>某些手撕题</h2><blockquote><p>杨辉三角求数字位置,118,119题相关</p></blockquote><blockquote><p>循环有序数组的查找,33题相关</p></blockquote><blockquote><p>求二叉树的最近公共祖先,236题相关</p></blockquote><blockquote><p>求阶乘后的0,172题相关</p></blockquote><blockquote><p>实现一个增删改查功能的LinkedList,707题相关</p></blockquote><blockquote><p>矩阵置零</p></blockquote><blockquote><p>二叉树的层序遍历</p></blockquote><blockquote><p>中文转数字,数字转中文</p></blockquote><blockquote><p>链表的两数相加,2题相关</p></blockquote><blockquote><p>反转链表,206题相关</p></blockquote><blockquote><p>合并两有序链表,21题相关</p></blockquote><blockquote><p>括号匹配,20题相关</p></blockquote><blockquote><p>队列实现栈,栈实现队列,225,232题相关</p></blockquote><blockquote><p>判断IP地址是否在集合内,字符串匹配</p></blockquote><blockquote><p>中缀表达式的计算,224题相关</p></blockquote><blockquote><p>划分字母区间,763题相关</p></blockquote><blockquote><p>leetcode腾讯精选50道</p></blockquote><h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><p>学习语言基础</p><h3 id="怎么读写文件"><a href="#怎么读写文件" class="headerlink" title="怎么读写文件"></a>怎么读写文件</h3><h3 id="怎么从控制台读取输入"><a href="#怎么从控制台读取输入" class="headerlink" title="怎么从控制台读取输入"></a>怎么从控制台读取输入</h3><h3 id="怎么分割字符串"><a href="#怎么分割字符串" class="headerlink" title="怎么分割字符串"></a>怎么分割字符串</h3><h3 id="怎么分配二维数组和使用"><a href="#怎么分配二维数组和使用" class="headerlink" title="怎么分配二维数组和使用"></a>怎么分配二维数组和使用</h3><h2 id="第二-三周"><a href="#第二-三周" class="headerlink" title="第二,三周"></a>第二,三周</h2><p>学习数据结构和算法</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h3 id="图-深搜和宽搜"><a href="#图-深搜和宽搜" class="headerlink" title="图(深搜和宽搜)"></a>图(深搜和宽搜)</h3><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h2 id="第四-五周"><a href="#第四-五周" class="headerlink" title="第四,五周"></a>第四,五周</h2><p>学习简单的数据结构和算法</p><h3 id="数组常见"><a href="#数组常见" class="headerlink" title="数组常见:"></a>数组常见:</h3><h4 id="怎么从数组删除偶数"><a href="#怎么从数组删除偶数" class="headerlink" title="怎么从数组删除偶数"></a>怎么从数组删除偶数</h4><h4 id="怎么合并两个排序好数组"><a href="#怎么合并两个排序好数组" class="headerlink" title="怎么合并两个排序好数组"></a>怎么合并两个排序好数组</h4><h4 id="求数组中第一个不重复数字"><a href="#求数组中第一个不重复数字" class="headerlink" title="求数组中第一个不重复数字"></a>求数组中第一个不重复数字</h4><h4 id="找到数组中第二大数字"><a href="#找到数组中第二大数字" class="headerlink" title="找到数组中第二大数字"></a>找到数组中第二大数字</h4><h3 id="链表常见"><a href="#链表常见" class="headerlink" title="链表常见"></a>链表常见</h3><h4 id="链表长度"><a href="#链表长度" class="headerlink" title="链表长度"></a>链表长度</h4><h4 id="怎么在链表中查找"><a href="#怎么在链表中查找" class="headerlink" title="怎么在链表中查找"></a>怎么在链表中查找</h4><h4 id="怎么翻转链表"><a href="#怎么翻转链表" class="headerlink" title="怎么翻转链表"></a>怎么翻转链表</h4><h4 id="怎么找链表最中间值"><a href="#怎么找链表最中间值" class="headerlink" title="怎么找链表最中间值"></a>怎么找链表最中间值</h4><h3 id="队列和栈常见"><a href="#队列和栈常见" class="headerlink" title="队列和栈常见"></a>队列和栈常见</h3><h4 id="栈中元素排序"><a href="#栈中元素排序" class="headerlink" title="栈中元素排序"></a>栈中元素排序</h4><h4 id="构造一个栈-能在O-1-时间找到最小值"><a href="#构造一个栈-能在O-1-时间找到最小值" class="headerlink" title="构造一个栈,能在O(1)时间找到最小值"></a>构造一个栈,能在O(1)时间找到最小值</h4><h4 id="如何用数组实现栈和队列"><a href="#如何用数组实现栈和队列" class="headerlink" title="如何用数组实现栈和队列"></a>如何用数组实现栈和队列</h4><h3 id="树的常见"><a href="#树的常见" class="headerlink" title="树的常见"></a>树的常见</h3><h4 id="二叉搜索树最小值"><a href="#二叉搜索树最小值" class="headerlink" title="二叉搜索树最小值"></a>二叉搜索树最小值</h4><h4 id="二叉树的高度"><a href="#二叉树的高度" class="headerlink" title="二叉树的高度"></a>二叉树的高度</h4><h4 id="BST的第K大数"><a href="#BST的第K大数" class="headerlink" title="BST的第K大数"></a>BST的第K大数</h4><h3 id="图的常见"><a href="#图的常见" class="headerlink" title="图的常见"></a>图的常见</h3><h4 id="实现宽搜"><a href="#实现宽搜" class="headerlink" title="实现宽搜"></a>实现宽搜</h4><h4 id="实现深搜"><a href="#实现深搜" class="headerlink" title="实现深搜"></a>实现深搜</h4><h4 id="检测图中是否有环"><a href="#检测图中是否有环" class="headerlink" title="检测图中是否有环"></a>检测图中是否有环</h4><h3 id="字母树常见"><a href="#字母树常见" class="headerlink" title="字母树常见"></a>字母树常见</h3><h4 id="字母树中单词个数"><a href="#字母树中单词个数" class="headerlink" title="字母树中单词个数"></a>字母树中单词个数</h4><h4 id="找到字母树中所有单词"><a href="#找到字母树中所有单词" class="headerlink" title="找到字母树中所有单词"></a>找到字母树中所有单词</h4><h3 id="堆的常见"><a href="#堆的常见" class="headerlink" title="堆的常见"></a>堆的常见</h3><h4 id="一个列表里K个最小的数"><a href="#一个列表里K个最小的数" class="headerlink" title="一个列表里K个最小的数"></a>一个列表里K个最小的数</h4><h4 id="找到数组中K个最大的数"><a href="#找到数组中K个最大的数" class="headerlink" title="找到数组中K个最大的数"></a>找到数组中K个最大的数</h4><h2 id="第六-七-八周"><a href="#第六-七-八周" class="headerlink" title="第六,七,八周"></a>第六,七,八周</h2><p>分析复杂题目:</p><blockquote><p>学会计算答案的时间和空间复杂度,面试时要清晰阐述答案的时空复杂度</p></blockquote><p>题目推荐:</p><ol><li>Implement Binary Search</li><li>Find the Intersection point of two linked lists</li><li>Reverse words in a sentence</li><li>check if two binary trees are identical</li><li>Clone a directed graph</li><li>Find solution to a Boggle game</li><li>Determine if there are any three integers in an array that sum equal to the given value</li><li>实现二分搜索</li><li>找到两个链表汇入点</li><li>翻转一个句子的单词</li><li>判断两二叉树相同</li><li>复制两个有向图</li><li>实现Boggle游戏</li><li>3Sum</li></ol><h2 id="第九-十周"><a href="#第九-十周" class="headerlink" title="第九,十周"></a>第九,十周</h2><blockquote><p>学习系统设计部分,考虑实际问题,诸如:</p><ol><li>如何解决服务器的负载均衡问题</li><li>如何共享数据库</li><li>如何保存大文件</li><li>如何架构网络,解决冗余和达到最大吞吐量</li></ol></blockquote><p>可以搜索学习的方向:</p><blockquote><p>设计Instagram</p><p>设计脸书的Newsfeed</p><p>设计Uber</p></blockquote><h2 id="第十一周"><a href="#第十一周" class="headerlink" title="第十一周"></a>第十一周</h2><p>了解线程,锁,同步等概念</p><h2 id="第十二周"><a href="#第十二周" class="headerlink" title="第十二周"></a>第十二周</h2><blockquote><p>学习ODD方面知识</p><p>设计ATM机</p><p>设计电梯</p><p>设计停车场</p></blockquote><h1 id="JAVA问题集合"><a href="#JAVA问题集合" class="headerlink" title="JAVA问题集合"></a>JAVA问题集合</h1>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习路线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch-Geometric安装笔记</title>
    <link href="/2021/01/07/Pytorch-Geometric%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/01/07/Pytorch-Geometric%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础环境"><a href="#基础环境" class="headerlink" title="基础环境"></a>基础环境</h1><p>1.操作系统：win10</p><p>2.python版本：3.6.10</p><p>3.cuda版本：10.1</p><p>4.pytorch版本：1.6.0</p><h1 id="相关依赖包"><a href="#相关依赖包" class="headerlink" title="相关依赖包"></a>相关依赖包</h1><p>安装pytorch-geometric前，需要先安装四个前置依赖，选择离线安装，这样比较快。</p><blockquote><p>torch-scatter</p><p>torch-sparse</p><p>torch-cluster</p><p>torch-spline-conv</p></blockquote><p>在<a href="https://pytorch-geometric.com/whl/%E5%8F%AF%E9%80%89%E6%8B%A9%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AFtorch-1.6.0+cu101">https://pytorch-geometric.com/whl/可选择对应版本下载，我选择的是torch-1.6.0+cu101</a></p><p>得到四个包,放入文件夹，然后本地离线加载。</p><blockquote><p>torch_cluster-1.5.7-cp36-cp36m-win_amd64.whl</p><p>torch_scatter-2.0.5-cp36-cp36m-win_amd64.whl</p><p>torch_sparse-0.6.7-cp36-cp36m-win_amd64.whl</p><p>torch_spline_conv-1.2.0-cp36-cp36m-win_amd64.whl</p></blockquote><p>然后在载入四个前置依赖后，输入</p><p>pip install torch-geometric</p><p>没有报错，即安装完成。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图计算讲座心得</title>
    <link href="/2020/12/15/%E5%9B%BE%E8%AE%A1%E7%AE%97%E8%AE%B2%E5%BA%A7%E5%BF%83%E5%BE%97/"/>
    <url>/2020/12/15/%E5%9B%BE%E8%AE%A1%E7%AE%97%E8%AE%B2%E5%BA%A7%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="《-从离线图计算到图数据库和图流计算》"><a href="#《-从离线图计算到图数据库和图流计算》" class="headerlink" title="\《******从离线图计算到图数据库和图流计算》****"></a><strong><em>\</em>《*****</strong>*从离线图计算到图数据库和图流计算》****</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="\背景介绍**"></a><strong><em>\</em>背景介绍**</strong></h3><table><thead><tr><th>主题</th><th>从离线图计算到图数据库和图流计算</th><th>时间</th><th>2020年11月23日</th><th></th><th></th></tr></thead><tbody><tr><td>地点</td><td>Bilibili图谱学苑</td><td>主讲人</td><td>陈文光</td><td>主讲人单位</td><td>清华大学</td></tr></tbody></table><h3 id="讲座内容"><a href="#讲座内容" class="headerlink" title="\讲座内容**"></a><strong><em>\</em>讲座内容**</strong></h3><p>\1. 将图计算引入传统方法可能无法良好解决的现实问题中，如失联修复（公司丢失客户联系方式，通过相关社交媒体账号找回），恶意网络攻击(基于图计算的恶意网址检测），反信用卡团伙欺诈（通过图计算发现团伙欺诈之间的关联性，利用社区发现算法发现申请间的关联性等）。上述算法本身都不复杂，复杂在图的计算上，本讲座讲述了如何处理这些巨大的图。</p><p>\2. 随着Spark成为大数据处理的实际标准，但其在图的处理上是十分低效的，具体体现在计算时间和计算空间上的巨量空耗。为解决此问题，涌现了许多图计算系统，详细介绍了三个并行图计算系统：GridGraph（高效率单机外存图计算系统，处理规模：万亿边），Gemini(分布式内存图计算系统，处理规模：万亿边），shentu(极大规模分布式内存图计算系统，处理规模：数十万亿边）。并介绍了图计算模型的基本模型和原理，如以边为中心的图处理模型，GridGraph的起点终点二维划分，Streaming-apply模式的双滑动窗口，稠密-稀疏双模式的计算模型。</p><p>\3. 讲述了对图划分算法的改进，chunk划分保留了局部性，已经局部感知性的chunking，多层次分块划分和任务窃取对负载平衡进行全局调整。也通过搜狗全中文网页有12万亿条边的例子来描述大规模分布式处理的问题。</p><p>\4. 图数据库是目前发展的最快的数据库，产品化的图数据库TuGraph通过LDBC SNB测试程序进行测试的效果介绍。最后对是否可以合并图计算和图数据库形成一站式图系统的可能进行探讨。</p><h3 id="个人心得"><a href="#个人心得" class="headerlink" title="\个人心得**"></a><strong><em>\</em>个人心得**</strong></h3><p>通过本次讲座，我系统了解到了图计算和图数据库的的相关知识，加深了从离线图计算到图数据图流计算的理解，对大规模图数据的同化计算有了新的认识，合并图计算与图数据库形成一站式图系统可能是未来一段时间图数据领域发展的重点，数据时代，图数据也发挥着越来越多的作用，可能对于越来越多的现实问题有了新的解决方法，分析节点和链接之间的关系，超大规模图计算的落地也将使大数据时代的复杂数据问题得到应有的解决。</p><h2 id="《-大规模时序图上最短路径查询》"><a href="#《-大规模时序图上最短路径查询》" class="headerlink" title="\《******大规模时序图上最短路径查询》****"></a><strong><em>\</em>《*****</strong>*大规模时序图上最短路径查询》****</h2><h3 id="背景介绍-1"><a href="#背景介绍-1" class="headerlink" title="\背景介绍**"></a><strong><em>\</em>背景介绍**</strong></h3><table><thead><tr><th>主题</th><th>大规模时序图上最短路径查询</th><th>时间</th><th>2020年11月23日</th><th></th><th></th></tr></thead><tbody><tr><td>地点</td><td>Bilibili图谱学苑</td><td>主讲人</td><td>袁野</td><td>主讲人单位</td><td>北京理工大学计算机学院</td></tr></tbody></table><h3 id="讲座内容-1"><a href="#讲座内容-1" class="headerlink" title="\讲座内容**"></a><strong><em>\</em>讲座内容**</strong></h3><p>本次讲座详细介绍了两种时序图模型，并介绍提出了一个更加通用的模型，可以普适性的解决时序图上的最短路径查询问题。袁老师线详细介绍了大图数据背景时序图的应用背景和基本定义，大图数据的计算分类为离线分析和在线查询，梳理了现有的时序图模型，然后从图查询处理帆帆，时序图管理系统等方面介绍了当前大规模时序图最短路径查询的详细研究工作。之后，详细讲解了大规模时序图上带约束的最短路径查询方法研究进展，给出了基于树分解的大图计算模型和相关应用的设计方案。就大图数据跨域计算进行了面向跨越的高效大图计算框架GeoGraph的相关扩展。最后，通过金融风险防控的实例讲解了图务实体经济上大图数据处理的应用。</p><h3 id="个人心得-1"><a href="#个人心得-1" class="headerlink" title="\个人心得**"></a><strong><em>\</em>个人心得**</strong></h3><p>最短路径查询作为图论研究的核心问题之一，现实世界中很多问题都能转化为最短路径问题求解。随着网络规模的不断扩张，传统经典的最短路径查询方法已无法满足大规模图的查询需求，本次讲座中，袁野老师通过对两种时序图模型的介绍，接着提出了目前来说更加通用的模型，在涉及大规模时序图上最短路径查询应用时，传统场景中的数据预处理都会被用作来提高查询效率的重要手段。袁老师的大规模图改进于大规模图中近似最短路径查询，又能适用于更广泛的时序图上，作为总结，不仅能为后来研究此方向的人给出新的方向和思路，也能对图论中关于大规模图最短路径问题的快速求解做出新的推进。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCN节点分类实验（一）</title>
    <link href="/2020/12/13/GCN%E8%8A%82%E7%82%B9%E5%88%86%E7%B1%BB%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/12/13/GCN%E8%8A%82%E7%82%B9%E5%88%86%E7%B1%BB%E5%AE%9E%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="GCN实验"><a href="#GCN实验" class="headerlink" title="GCN实验"></a>GCN实验</h1><h2 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h2><p>实验数据集选用Cora数据集，该数据集由2708篇论文以及代表它们之间引用关系构成的5429条边组成。</p><p>数据集里论文按照主题大致分为七类：神经网络，强化学习，规划学习，概率方法，遗传算法，理论研究，案例相关。且每篇论文特征通过词袋模型得到，维度为1433，每一维表示一个词，1表示该词在文中出现过，0表示未出现过。</p><blockquote><p>文本向量化表示–词袋模型</p><p>词袋模型使用一组词语序列来表示一段文本，这一组词语序列就是词袋模型，也可以叫词汇表。词汇表中每个词语之间的顺序是任意的，但是一旦词汇表确定后词语之间的前后顺序就不能变化了。由于词语之间的顺序任意，所以词袋模型忽略了文本的语法和语序要素。词袋模的One-Hot表示法、TF表示法、TF-IDF表示法的数值计算规则都没有考虑词语之间的共现关系。</p><p>TF表示法：词语序列中出现的词语其数值为词语在所在文本中的频次，词语序列中未出现的词语其数值为0。</p><p>TF-IDF表示法：词语序列中出现的词语其数值为词语在所在文本中的频次乘以词语的逆文档频率，词语序列中未出现的词语其数值为0。</p><p>逆文档频率：所有文档中出现频次的倒数</p></blockquote><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>主要将数据下载后，规范化数据，最后将数据规范化为以下几个部分：</p><ol><li>X：节点特征，即维度为2708*1433。</li><li>Y:节点对应标签，即上述7个类别。</li><li>A：邻接矩阵，维度为2708*2708。</li></ol><h2 id="可视化结果"><a href="#可视化结果" class="headerlink" title="可视化结果"></a>可视化结果</h2><p><img src="/img/keshihua.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GCN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记(二)</title>
    <link href="/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <url>/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote><p>传统的关系型数据库如Mysql等已不能适用所有场景，如秒杀的库存扣减，APP的首页访问流量高峰等，这些情况都很容易把数据库打崩，所有Redis作为缓存中间件横空出世。</p></blockquote><h2 id="缓存穿透与布隆过滤器"><a href="#缓存穿透与布隆过滤器" class="headerlink" title="缓存穿透与布隆过滤器"></a>缓存穿透与布隆过滤器</h2><blockquote><p>判断不存在的数据没有必要让Mysql再次查询，Redis利用布隆过滤器挡下那些明显不会有结果的查询请求。</p></blockquote><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器可以用于检索一个元素是否再一个集合中，其优点是空间效率和查询时间都远超一般算法，但有一定的误识别率和删除困难。</p><h3 id="布隆过滤器基本原理"><a href="#布隆过滤器基本原理" class="headerlink" title="布隆过滤器基本原理"></a>布隆过滤器基本原理</h3><p>布隆过滤器本质为bitmap位数组的扩展。例如有0-31范围的25个不重复数字，如何判断18在不在其中?</p><ol><li>第一种做法是建立数字数组，使用int8单字节数组，需要8*32=256位，即32字节的空间。</li><li>第二种做法使用一个int32的变量，该变量4个字节，可用bit0表示数字0，bit1表示数字1，。。。依次类推。即知我们使用4字节空间就完成了方法一32字节的工作。</li></ol><h4 id="布隆过滤器两大组件"><a href="#布隆过滤器两大组件" class="headerlink" title="布隆过滤器两大组件"></a>布隆过滤器两大组件</h4><blockquote><ol><li>一定大小的BitAarry位阵列（具体大小与存储规模相关）</li><li>N个可用的哈希函数（N的个数与存储规模，容忍误判率等有关）降低哈希冲突，尽量选用优秀的哈希函数。</li></ol></blockquote><p>两组件分工为，位阵列存储对应位的值是0/1的二进制向量，哈希函数将原始输入经过数字运算转换为一个数字值。</p><h4 id="布隆过滤器与哈希冲突"><a href="#布隆过滤器与哈希冲突" class="headerlink" title="布隆过滤器与哈希冲突"></a>布隆过滤器与哈希冲突</h4><p>哈希冲突虽然概率很低，但是在大规模数据场景下还是会出现，可尽量选用表现更优秀的哈希函数，或者多个哈希共同使用。</p><h4 id="布隆过滤器的具体使用"><a href="#布隆过滤器的具体使用" class="headerlink" title="布隆过滤器的具体使用"></a>布隆过滤器的具体使用</h4><p>假设三个哈希函数h1，h2，h3，有三个输入a,b,c已存在，分别通过三个哈希函数计算出对应整数后，对bitarray长度取模后将对应位置置1.</p><p>当布隆过滤器检索时，使用相同哈希函数进行计算，只要对应位置中，任何一个位置有0，则被检元素一定不存在，若对应位置都是1，则被检元素可能存在。</p><p>网上找图，如下所示：</p><p><img src="/img/bulong.png"></p><blockquote><p><strong>有0一定不存在，全1不一定存在</strong></p></blockquote><blockquote><p>所以布隆过滤器存在一定的误判，主要因素包括：</p><ol><li>哈希函数本身的冲突率</li><li>bitarray位数组的大小</li></ol></blockquote><blockquote><p>因为对位置重复赋值，所以一般不能从布隆过滤器删除元素</p></blockquote><h2 id="布隆过滤器的典型应用"><a href="#布隆过滤器的典型应用" class="headerlink" title="布隆过滤器的典型应用"></a>布隆过滤器的典型应用</h2><ol><li>缓存穿透过滤</li><li>检查单词拼写正确性</li><li>垃圾邮件过滤:如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</li><li>检查海量名单嫌疑人</li><li>搜索爬虫URL去重:爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记(一)</title>
    <link href="/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2020/12/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis是一个完全开源的高性能key-value数据库.</p><h2 id="Redis的数据结构与应用场景"><a href="#Redis的数据结构与应用场景" class="headerlink" title="Redis的数据结构与应用场景"></a>Redis的数据结构与应用场景</h2><blockquote><p>使用场景:缓存,共享session,消息队列系统,分布式锁</p></blockquote><blockquote><p>单线程Redis快的原因?</p><ol><li>纯内存操作</li><li>单线程操作,避免了频繁上下文切换</li><li>合理高效的数据结构</li><li>采用非阻塞I/O多路复用机制</li></ol></blockquote><h3 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h3><p>字符串是Redis最基础的数据结构.其中键都是字符串类型,剩下几种数据结构都是在字符串类型基础上构建的.常用在缓存,计数,共享session,限速等方面.</p><h3 id="Hash哈希"><a href="#Hash哈希" class="headerlink" title="Hash哈希"></a>Hash哈希</h3><p>Redis中,哈希类型是指键值本身又是一个键值对结构的数据.可用来存放用户信息,实现诸如购物车等功能.</p><h3 id="List列表-双向链表"><a href="#List列表-双向链表" class="headerlink" title="List列表(双向链表)"></a>List列表(双向链表)</h3><p>列表类型可用来存储多个有序的字符串,可做简单的消息队列功能.</p><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>集合类型可用来保存多个的字符串元素,与列表不同的是,集合中不允许重复元素且元素无序,不能通过索引下标获取元素.可通过Set的交集,并集,差集等来计算重合元素.</p><h3 id="Sorted-Set有序集合"><a href="#Sorted-Set有序集合" class="headerlink" title="Sorted Set有序集合"></a>Sorted Set有序集合</h3><p>相对Set多了一个权重参数Score,集合中元素能按Score进行排列.常用来做排行榜,取Top N.</p><h2 id="Redis的数据过期策略"><a href="#Redis的数据过期策略" class="headerlink" title="Redis的数据过期策略"></a>Redis的数据过期策略</h2><blockquote><p>Redis中数据过期策略采用定期删除与惰性删除策略</p></blockquote><h3 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h3><p>Redis会启动一个定时器定时监视所有key，判断key的时效性，若过期即删除key。此方法能保证过期的key最终都能被删除。但本方法每次都要遍历内存中所有数据，非常消耗CPU资源。并且当Key过期后，定时器还未被唤起，这一段时间内的key仍然可用。</p><h3 id="惰性删除策略"><a href="#惰性删除策略" class="headerlink" title="惰性删除策略"></a>惰性删除策略</h3><p>在获取到key时，判断key是否过期，若过期则删除。本方法缺点是：若某个key一直未被使用，则其将会一直在内存中，占用空间。</p><h3 id="两者结合策略"><a href="#两者结合策略" class="headerlink" title="两者结合策略"></a>两者结合策略</h3><p>定时删除策略不再扫描全部key。而是随机抽取部分key进行检查，从而降低对CPU的损耗。惰性删除策略弥补了可能未被检查到的key。若还是存在过期的key，既没有被定时器抽取，也没有被使用，则当内存不够时，使用内存淘汰机制进行淘汰。</p><blockquote><p>移除最近最少使用的key/随机移除某个key </p><p>LRU（Least Recently Used) 最近最少使用</p></blockquote><h4 id="如何实现LRU"><a href="#如何实现LRU" class="headerlink" title="如何实现LRU"></a>如何实现LRU</h4><p>一般使用HashMap和双向链表实现LRU。使用HashMap存储key，而value指向双向链表实现的LRU的Node节点，如图：</p><p><img src="/img/LRU.png"></p><p>h表头，t表尾，预先设置LRU的容量。若存储满了，则O（1）时间淘汰掉双向链表的表尾。每次访问数据，都可通过O（1）效率把新节点增加到队头或把已存在点移动到队头。</p><h4 id="Redis的LRU具体实现"><a href="#Redis的LRU具体实现" class="headerlink" title="Redis的LRU具体实现"></a>Redis的LRU具体实现</h4><p>Redis每次按key获取一个值时，都会更新value中的LRU字段为当前秒级别的时间戳。</p><p>第一版LRU为，随机从dict中取出五个key，淘汰一个LRU最小的。</p><p>在3.0时，改进一版算法，首先第一批随机挑选的key会放进一个pool中（默认大小16），pool中的key是按LRU字段大小顺序排列。接下来每次随机挑选的key的LRU必须小于pool的最小LRU才会继续放入，直至pool放满。放满后，若有新的key需要放入，则将pool中LRU最大的key取出。淘汰的时候，直接从pool中选取LRU最小的值进行淘汰即可。</p><h2 id="Redis如何发现热点key"><a href="#Redis如何发现热点key" class="headerlink" title="Redis如何发现热点key"></a>Redis如何发现热点key</h2><p>Redis主要有五种发现热点key的方法：</p><ol><li>凭借经验预估：提前知道某个活动的开启，将该key作为热点key。</li><li>服务端收集：在操作redis前，加入计数代码进行数据统计。</li><li>抓包评估：Redis使用TCP协议与客户端通信，通信协议采用RESP，即自己写程序监听端口能进行拦截包分析。</li><li>在proxy层，对每个redis请求进行收集上报。（proxy–代理服务器）</li><li>Redis自带命令查询：Redis4.0.4版本后，使用命令redis-cli-hotkeys能找出热点key</li></ol><h3 id="Redis缓存雪崩问题的解决"><a href="#Redis缓存雪崩问题的解决" class="headerlink" title="Redis缓存雪崩问题的解决"></a>Redis缓存雪崩问题的解决</h3><ol><li>使用Redis高可用框架：使用 Redis 集群来保证 Redis 服务不会挂掉。</li><li>缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效。</li><li>限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务。</li></ol><h3 id="Redis缓存穿透问题的解决（待详细展开）"><a href="#Redis缓存穿透问题的解决（待详细展开）" class="headerlink" title="Redis缓存穿透问题的解决（待详细展开）"></a>Redis缓存穿透问题的解决（待详细展开）</h3><ol><li>在接口做校验。</li><li>缓存击穿加锁/设置不过期</li><li>布隆过滤器拦截</li></ol><h2 id="Redis的几种集群模式"><a href="#Redis的几种集群模式" class="headerlink" title="Redis的几种集群模式"></a>Redis的几种集群模式</h2><blockquote><ol><li>主从复制</li><li>哨兵模式</li><li>cluster模式</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记(一)</title>
    <link href="/2020/12/01/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <url>/2020/12/01/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="事务的基本要素"><a href="#事务的基本要素" class="headerlink" title="事务的基本要素"></a>事务的基本要素</h2><blockquote><p>原子性,一致性,隔离性,持久性——-ACID</p></blockquote><ol><li>原子性(atomicity),即事务是一个原子操作单元,对数据的修改,要么全部执行,要么全部不执行</li><li>一致性(consistency),即事务开始与结束前,数据库的完整性约束未被破坏</li><li>隔离性(isolation),即同一时间,只允许一个事务请求同一数据,不同事务间没有任何干扰</li><li>持久性(durability),即事务完成后,事务对数据库的所有更新将被保存到数据库,不能回滚</li></ol><h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><blockquote><p>脏读,不可重复读,幻读</p></blockquote><ol><li><p>脏读,即事务A读取了事务B更新的数据,然后B进行了回滚,那A读取到的数据是脏数据</p></li><li><p>不可重复读,即事务A多次读取同一数据,事务B在A多次读取过程中,对数据做了更新并提交,导致A多次读取的内容不一致</p></li><li><p>幻读,即事务A读取了事务B已提交的新增数据.也是重复读取不一致.</p><blockquote><p>幻读是新增数据,不可重复读是更改数据.</p></blockquote></li></ol><h2 id="Mysql事务的隔离级别"><a href="#Mysql事务的隔离级别" class="headerlink" title="Mysql事务的隔离级别"></a>Mysql事务的隔离级别</h2><blockquote><p>读未提交:可以读到未提交的内容,可能产生脏读,不可重复读,幻读</p><p>不可重复读(读提交):只能读到已提交的内容</p><p>可重复读:查询事务启动时,不允许进行更改操作了,为Mysql的默认隔离级别</p><p>串行化: 数据库最高隔离级别,事务必须一个一个排队执行,按串行化顺序</p><ol><li>为何出现脏读?   select操作没有规矩</li><li>为何出现不可重复读?  update操作没有规矩</li><li>为何出现幻读?   insert和delete没有规矩</li></ol></blockquote><table><thead><tr><th align="center">事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td>是</td><td>是</td><td>是</td></tr><tr><td align="center">不可重复读(读提交)</td><td>否</td><td>是</td><td>是</td></tr><tr><td align="center">可重复读</td><td>否</td><td>否</td><td>是</td></tr><tr><td align="center">串行化</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h2 id="sql语句执行顺序"><a href="#sql语句执行顺序" class="headerlink" title="sql语句执行顺序"></a>sql语句执行顺序</h2><p>from</p><p>where</p><p>group by</p><p>having</p><p>select</p><p>order by</p><h2 id="Mysql的存储引擎"><a href="#Mysql的存储引擎" class="headerlink" title="Mysql的存储引擎"></a>Mysql的存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>是基于聚簇索引建立的,其支持事务,外键,并且通过MVCC来支持高并发以及索引数据一体存储.Mysql5.5.8版本后成为默认存储引擎</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>为5.1版本前的默认引擎,支持全文检索,压缩,空间函数,但不支持事务和行级锁,一般用在大量查询少量插入的场景,且不支持外键,其索引和数据是分开存储的</p><h2 id="Mysql的逻辑结构"><a href="#Mysql的逻辑结构" class="headerlink" title="Mysql的逻辑结构"></a>Mysql的逻辑结构</h2><blockquote><p>最上层服务类似CS结构,进行连接处理,授权处理</p></blockquote><blockquote><p>第二层为Mysql服务层,SQL语句的解析分析优化,存储过程触发器视图等都在本层实现</p></blockquote><blockquote><p>最下层为存储引擎的实现,类似Java接口实现,在调用时会屏蔽不同引擎实现间的差异</p></blockquote><h2 id="Mysql的日志系统"><a href="#Mysql的日志系统" class="headerlink" title="Mysql的日志系统"></a>Mysql的日志系统</h2><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>即回滚日志文件,主要用于事务执行失败,进行回滚,在MVCC中对数据历史版本查看.由引擎层的InnoDB引擎实现,为逻辑日志,记录数据被修改前的值.保证了事务的一致性</p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>即重做日志文件,记录数据修改后的值,用于持久化到磁盘中,由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息(诸如某个数据页上的内容发生改动).当某条数据需要更新,InnoDB会先将数据更新,然后记录redo log在内存中,找个时间将redo log操作执行到磁盘文件上.不管提交是否成功,都会记录,若进行回滚操作,也会记录回滚.保证了事务的持久性.</p><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h3><p>是Mysql中基于乐观锁理论实现隔离级别的方式,用于读提交和可重复读隔离级别的实现.在Mysql中,会在表中每条数据后添加两个字段:<strong>最近修改改行数据的事务ID</strong>和<strong>指向改行回滚段(undolog)的指针</strong>.实际上为保存了数据在某个时间节点的快照.</p><h3 id="binlog与redo-log区别"><a href="#binlog与redo-log区别" class="headerlink" title="binlog与redo log区别"></a>binlog与redo log区别</h3><ol><li>redo log是在InnoDB存储引擎层产生,而binlog是MySQL数据库的上层服务层产生</li><li>两种日志记录内容形式差异.binlog是逻辑日志,记录对应的sql语句和事务;而redo log是物理日志,记录的是关于每个页的更改的物理情况</li><li>两种日志的记录写入磁盘的时间点不同,binlog只在事务提交完成后进行一次写入.而redo log在事务进行中不断被写入.</li><li>binlog不是循环使用,在写满或重启后,才会生成新的binlog文件,redo log是循环使用</li><li>两者都能进行数据恢复.</li></ol><h2 id="Mysql如何保证一致性和持久性"><a href="#Mysql如何保证一致性和持久性" class="headerlink" title="Mysql如何保证一致性和持久性"></a>Mysql如何保证一致性和持久性</h2><p>为保证ACID中的一致性和持久性,使用了先写日志再写磁盘的操作,即WAL(write-Ahead logging)</p><p>当数据库断电再重新启动时,mysql可以通过redo log还原数据;即只要在每次事务刷新时,同步刷新redo log即可,不用同步刷新磁盘数据文件.</p><h2 id="Mysql锁的类型"><a href="#Mysql锁的类型" class="headerlink" title="Mysql锁的类型"></a>Mysql锁的类型</h2><p>mysql的锁分为共享锁和排他锁,即读锁和写锁.</p><p>读锁为共享的,可通过lock in share mode实现,只能读不能写</p><p>写锁为排他的,会阻塞其他的写锁和读锁.</p><p>另外,通过颗粒度来分,又分为表锁和行锁两种.</p><p>其中表锁会锁定整张表并阻塞其他用户对该表所有的读写操作.阻塞诸如alter修改表结构等的操作</p><p>行锁又可分为乐观锁和悲观锁两种,悲观锁通过for update实现,乐观锁通过版本号实现.</p><h3 id="InnoDB的行锁模式"><a href="#InnoDB的行锁模式" class="headerlink" title="InnoDB的行锁模式"></a>InnoDB的行锁模式</h3><ol><li>共享锁(S):用法即lock in share mode,允许一个事务去读一行,阻止其他数据获得相同数据的排他锁.意思是,若事务1对数据对象A加了S锁,事务1可以读A但不能修改A,其他事务对A也只能加S锁,而不能加X锁,直至事务1释放A上的S锁</li><li>排他锁(X):用法for update,允许获取排他锁事务更新数据,阻止其他事务对相同数据加锁.若事务1对数据A进行加锁,其他事务不能再对A加任何锁.</li></ol><blockquote><p>在没有索引的情况下,InnoDB只能使用表锁</p></blockquote><h2 id="Mysql的索引"><a href="#Mysql的索引" class="headerlink" title="Mysql的索引"></a>Mysql的索引</h2><blockquote><p>索引按照数据结构来讲,主要包含B+树和Hash索引</p></blockquote><h3 id="为什么选择B-树为索引结构"><a href="#为什么选择B-树为索引结构" class="headerlink" title="为什么选择B+树为索引结构"></a>为什么选择B+树为索引结构</h3><ul><li>Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描</li><li>二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。</li><li>平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。</li><li>红黑树：通过舍弃严格的平衡和引入红黑节点，解决了 AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。</li><li>B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效</li></ul><h3 id="B-树的叶子节点都可以存哪些东西"><a href="#B-树的叶子节点都可以存哪些东西" class="headerlink" title="B+树的叶子节点都可以存哪些东西"></a>B+树的叶子节点都可以存哪些东西</h3><p>可能存储的是整行数据，也有可能是主键的值。B+树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引</p>]]></content>
    
    
    <categories>
      
      <category>数据库相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--括号匹配</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h1><blockquote><p>可以考虑使用数组来模拟栈操作，另外让top=1，省去判断栈空，和数组越界的问题</p><p>在遇到）时，判断栈顶是否是（，以此类推</p></blockquote><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">boolean</span> <span class="hljs-title">isvalid</span><span class="hljs-params">(String s)</span></span>&#123;    <span class="hljs-keyword">char</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[s.length()+<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> top=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:s.toCharArray())&#123;        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;(&#x27;</span>||c==<span class="hljs-string">&#x27;[&#x27;</span>||c==<span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;            stack[top++]=c;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;）&#x27;</span>&amp;&amp;stack[--top]!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;stack[--top]!=<span class="hljs-string">&#x27;[&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;&#123;&#x27;</span>&amp;&amp;stack[--top]!=<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> top==<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--移除有序数组重复元素</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E7%A7%BB%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="移除有序数组重复元素"><a href="#移除有序数组重复元素" class="headerlink" title="移除有序数组重复元素"></a>移除有序数组重复元素</h1><blockquote><p>题目:移除有序数组重复元素，返回剩余元素个数。例如[1,1,2,2,3],返回3</p><p>使用一个指针指向头部，进行赋值</p></blockquote><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;    <span class="hljs-keyword">int</span> len = nums.length;    <span class="hljs-keyword">if</span>(len&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> len;    <span class="hljs-keyword">int</span> tail = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">1</span>;i&lt;len;++i)&#123;        <span class="hljs-keyword">if</span>(nums[i-<span class="hljs-number">1</span>]!=nums[i])&#123;            nums[tail++]=nums[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> tail;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--寻找子串</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找子串"><a href="#寻找子串" class="headerlink" title="寻找子串"></a>寻找子串</h1><blockquote><p>题目:在一字符串中寻找子串，返回子串首字母索引，若未找到返回-1。</p><p>即找到在s1中遍历完s2的位置可求解</p><p>例如，s1=hello，s2=ll，则返回2</p></blockquote><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">strstr</span><span class="hljs-params">(String s1,String s2)</span></span>&#123;    <span class="hljs-keyword">int</span> l1= s1.length(),l2=s2.length();    <span class="hljs-keyword">if</span>(l1&lt;l2) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;;i++)&#123;        <span class="hljs-keyword">if</span>(i+l2&gt;l1) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;     <span class="hljs-comment">//剩余长度不足以遍历完</span>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;;j++)&#123;            <span class="hljs-keyword">if</span>(j=l2) <span class="hljs-keyword">return</span> i;   <span class="hljs-comment">//遍历完s2情况</span>            <span class="hljs-keyword">if</span>(s1.charAt(i+j)!=s2.charAt(j))                <span class="hljs-keyword">break</span>;        &#125;    &#125;    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--寻找插入位置</title>
    <link href="/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
    <url>/2020/11/30/leetcode%E9%A2%98%E8%A7%A3--%E5%AF%BB%E6%89%BE%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找插入位置"><a href="#寻找插入位置" class="headerlink" title="寻找插入位置"></a>寻找插入位置</h1><blockquote><p>题目:从一个无重复元素已排序数组找到插入位置索引。例如，[1,3,5,6],插入数字2，即返回1；[1，3，5，6] 插入数字5，即返回2；</p></blockquote><p>可通过二分查找找到第一个大于等于target元素位置</p><p>代码如下:</p><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)</span></span>&#123;    <span class="hljs-keyword">int</span> left =<span class="hljs-number">0</span>,right=nums.length-<span class="hljs-number">1</span>,mid = (right+left)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(left&lt;=right)&#123;        <span class="hljs-keyword">if</span>(target&lt;=nums[mid])&#123;            right=mid-<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            left = mid+<span class="hljs-number">1</span>;        &#125;        mid = (right+left)&gt;&gt;<span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> left;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--跳水板拼凑</title>
    <link href="/2020/11/29/leetcode-%E8%B7%B3%E6%B0%B4%E6%9D%BF/"/>
    <url>/2020/11/29/leetcode-%E8%B7%B3%E6%B0%B4%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="跳水板拼凑"><a href="#跳水板拼凑" class="headerlink" title="跳水板拼凑"></a>跳水板拼凑</h1><p>题目:有两块板子，长度为x和y，假设有k块，输出所有可能的拼凑长度，例如x=1,y=2,k=3，输出[3,4,5,6]</p><p>本题可看成首项为k<em>x，末项为k</em>y，公差为y-x的等差数列，每用长的替换短的，都是加一次公差，项数为k+1.</p><p>代码如下:</p><pre><code class="hljs java">Public <span class="hljs-keyword">int</span> [] result(<span class="hljs-keyword">int</span> shorter,<span class="hljs-keyword">int</span> longer,<span class="hljs-keyword">int</span> k)&#123;    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">if</span>(shorter==longer)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;shorter*k&#125;;    &#125;    <span class="hljs-keyword">int</span>[] ans=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k+<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> sx = k*shorter;    <span class="hljs-keyword">int</span> delta = longer-shorter;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>;i&lt;=k;i++)&#123;        ans[i]=sx+i*delta;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树总结</title>
    <link href="/2020/11/28/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/"/>
    <url>/2020/11/28/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><blockquote><p>什么是二叉查找树（BST）？</p><ol><li><p><strong>左</strong>子树上所有结点的值均<strong>小于或等于</strong>它的根结点的值</p></li><li><p><strong>右</strong>子树上所有结点的值均<strong>大于或等于</strong>它的根结点的值。</p></li><li><p>左、右子树也分别为二叉排序树。</p><p>基于二分查找建树。但存在插入之后节点不平衡情况，由此引入红黑树。</p></li></ol></blockquote><p>红黑树是一种自平衡的二叉查找树，其具有如下特性：</p><ol><li>节点是红色或黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点（NIL节点）。</li><li>每个红色节点的两个子节点都是黑色。即从叶子到根不可能有两个连续的红色节点</li><li>从任意节点到其每个叶子的所有路径都包含相同数目黑色节点。</li></ol><p>典型红黑树如图：</p><p><img src="/img/hongheishu.png"> </p><p>由上述构建规则限制，保证了红黑树从根到叶子的最长路径不会超过最短路径的2倍。</p><h2 id="红黑树的调整"><a href="#红黑树的调整" class="headerlink" title="红黑树的调整"></a>红黑树的调整</h2><p>当插入和删除节点时，红黑树规则会被打破，此时要对其进行调整，以满足条件。调整有两种方法：<strong>变色</strong>和<strong>旋转</strong>，而旋转又分为左旋转和右旋转。</p><h3 id="红黑树的左旋和右旋"><a href="#红黑树的左旋和右旋" class="headerlink" title="红黑树的左旋和右旋"></a>红黑树的左旋和右旋</h3><p>左旋即<strong>逆时针</strong>旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子，如图：</p><p><img src="/img/hongheishuzuoxuan.png"></p><p>右旋即<strong>顺时针</strong>旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。如图：</p><p><img src="/img/hongheishuyouxuan.png"></p><p> 实际使用中，变色和旋转视情况混合使用。</p><h3 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h3><p>在JDK的集合类TreeMap和TreeSet底层都是红黑树实现。在Java8中，HashMap也用到了红黑树.</p>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对偶</title>
    <link href="/2020/11/27/%E5%AF%B9%E5%81%B6/"/>
    <url>/2020/11/27/%E5%AF%B9%E5%81%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="不定期更新的闪耀时刻"><a href="#不定期更新的闪耀时刻" class="headerlink" title="不定期更新的闪耀时刻"></a>不定期更新的闪耀时刻</h1><p>南风过境/梦至西洲</p><p>三山时春/四水常在</p><p>扁舟子/明月楼</p><p>轻云蔽月/流风回雪</p><p>花酿酒/水煎茶</p><p>家人闲坐，灯火可亲。</p><p>塞北风沙酒，江南烟雨桥。</p><p>玉在山而草木润，渊生珠而崖不枯。</p><p>冬月新落雪，徐步纳子岁。</p><p>投入亡地然后存，陷入绝处而后生。</p><p>为众人抱薪者，不可使其扼于风雪。</p><p>欢声笑语别枝后，漫天星子正少年。</p><p>大梦谁先觉，平生我自知。</p><p>青天有月来几时，我今停杯一问之。</p><p>长安陌上无穷树，唯有垂杨管别离。</p><p>敬这大争之世，敬这小酌之时。</p><p>虹贯荆卿之心，碧化苌弘之血。</p><p>时日低矮而天下羊白</p><p>水清鱼读月，花静鸟谈天。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java垃圾回收机制</title>
    <link href="/2020/11/27/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/11/27/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>GC虽然已经自动帮我们完成清理，但了解一下java垃圾回收机制，还是对我们性能调优，问题排查等有很大帮助。本文为博主阅读网上资料后做的相关整理。</p><h1 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h1><p>1.虚拟机栈：每个方法被执行的同时会创建<strong>栈桢</strong> ，要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息,方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机都很明确，此处<strong>不需要进行 GC</strong>。</p><p>2.本地方法栈：虚拟机栈为虚拟机执行 Java 方法时服务，本地方法栈为虚拟机执行本地方法时服务，此处也<strong>不需要进行 GC</strong>。</p><p>3.程序计数器：线程独有。可以看作是当前线程执行的字节码的行号指示器。Java虚拟机的多线程是通过线程轮流切换并分配处理器的时间来完成的。在任何一个时刻，一个处理器只会执行一个线程，如果这个线程被分配的时间片执行完了（线程被挂起），处理器会切换到另外一个线程执行，程序计数器即记录唤醒线程时上次执行到的位置。另外<strong>程序计数器是唯一一个 Java 虚拟机规范中没有规定任何 OOM 情况的区域</strong>。此处也<strong>不需要进行 GC</strong>。</p><p>4.本地内存：即堆外内存，包含元空间和直接内存，JAVA8之后此区域也<strong>不需要进行 GC</strong>。</p><p>5.堆：对象实例和数组都是在堆上分配，GC主要针对这些数据进行回收，<strong>堆是java垃圾回收处理的主要区域</strong>。</p><h1 id="系统垃圾识别"><a href="#系统垃圾识别" class="headerlink" title="系统垃圾识别"></a>系统垃圾识别</h1><p>GC如何判断堆中对象实例等是不是垃圾？</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>为对象添加引用次数属性，被引用一次，即加一。未被引用即为0，代表可被回收。</p><p>但此类无法解决循环引用的问题，在互相被引用的对象要求释放时，因为引用次数不为零，造成无法回收。因此此方法用得较少。</p><h2 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h2><p>利用一个GC Root的对象为起点出发，逐步指向下一个可达的节点，直至所有节点遍历完毕，不在生成的这个引用链上的对象，即被判断为垃圾，会被GC回收。</p><p>另外，不是a, b 对象可回收，就一定会被回收。对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收。且<strong>finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收。</strong></p><blockquote><p>GC Root是什么？哪些对象可作为GC Root？</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul></blockquote><h1 id="垃圾回收主要方法"><a href="#垃圾回收主要方法" class="headerlink" title="垃圾回收主要方法"></a>垃圾回收主要方法</h1><p>通过可达性算法识别了哪些数据是垃圾，如何对垃圾进行回收？主要有以下三种方法。</p><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><ol><li><p>根据可达性算法标记出所有的可回收对象</p></li><li><p>对可回收对象进行回收</p></li></ol><p>此种算法回收之后会造成很多零碎的小内存，不能满足连续内存的需要</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><ol><li><p>将堆分为两块区域,A,B,区域A分配对象，B不分配对象</p></li><li><p>对A使用标记法把存活的对象都标记出来，并将它们复制到区域B</p></li><li><p>把A中对象全部清理释放空间</p></li></ol><p>此方法解决了内存碎片的问题，缺点是堆空间大小利用率大大降低，复制也有资源浪费。</p><h2 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h2><ol><li><p>根据可达性算法标记出所有的可回收对象</p></li><li><p>对标记对象进行整理，将所有存活对象都往一端移动，紧密排列</p></li><li><p>清除掉另一端所有非存活对象</p></li></ol><h1 id="当前垃圾回收器对比"><a href="#当前垃圾回收器对比" class="headerlink" title="当前垃圾回收器对比"></a>当前垃圾回收器对比</h1><p>说完了垃圾回收的方法论，到了垃圾回收器就是内存回收的具体实现了，当前垃圾回收器按使用时期分为如下几类：</p><blockquote><p>JVM中的堆，一般分为三部分：新生代，老年代，永久代（JAVA8永久代移除，被元空间取代）</p><p>1.何为新生代？</p><p>主要用来存放新生对象，一般占堆空间的三分之一空间，会频繁创建对象，频繁触发GC进行垃圾回收。</p><p>新生代又分为三个区： Eden区、ServivorFrom、ServivorTo。</p><p>Eden区：Java新对象的出生地，当此区内存不够时即触发GC，对新生代区进行一次垃圾回收。</p><p>ServivorTo：保留一次GC过程中的幸存者</p><p>ServivorFrom：上一次GC的幸存者，作为本次GC的被扫描者。</p><p>本区GC一般采用复制算法。</p><p>2.何为老年代？</p><p>当新生代无法找到足够大连续空间给新创建的较大对象时，会在老年代触发GC，一般采用标记清除算法。当老年代也没有空间时，会抛出OOM异常。</p></blockquote><h2 id="新生代回收器"><a href="#新生代回收器" class="headerlink" title="新生代回收器"></a>新生代回收器</h2><p>在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge。</p><h2 id="老年代回收器"><a href="#老年代回收器" class="headerlink" title="老年代回收器"></a>老年代回收器</h2><p>在老年代工作的垃圾回收器：CMS，Serial Old, Parallel Old</p><blockquote><p>新生代回收器和老年代回收器一般配合使用，共同完成JVM中GC。</p><p>还有一个驾驭一切的垃圾回收器，在新生代，老年代都能使用，即G1。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>垃圾回收机制回收JVM堆内存里的对象空间,不负责回收栈内存数据。</li><li>对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力。</li><li>垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。</li><li>可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。</li><li>现在的JVM有多种垃圾回收实现算法，表现各异。</li><li>垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。</li><li>我们可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否进行垃圾回收依然不确定。永远不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2020/11/26/Hashmap/"/>
    <url>/2020/11/26/Hashmap/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap是由数组和链表组合构成的数据结构，数组插入键值对，当遇到哈希值相等的节点时，即在该节点上形成链表。当新的节点插入链表时，java8之前是头插法，java8之后变为尾插法，主要防止哈希表扩容时，头插法易形成循环链表。</p><h1 id="为何JAVA8之后改为尾插法？"><a href="#为何JAVA8之后改为尾插法？" class="headerlink" title="为何JAVA8之后改为尾插法？"></a>为何JAVA8之后改为尾插法？</h1><p>首先来看看HashMap的扩容机制：</p><blockquote><p>数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize.</p><p>一般有两个因素：Capacity–HashMap当前长度       LoadFactor–负载因子，默认值0.75f</p><p>即假设当前的容量大小为100，当存进第76个元素的时候，判断发现需要对哈希表进行resize。</p></blockquote><p>具体扩容分为两步进行：</p><p>  <strong>扩容</strong>：创建一个新的空数组，长度是原数组的2倍</p><p>  <strong>rehash</strong>：遍历原数组，把所有节点重新Hash到新数组</p><blockquote><p>为何要重新hash节点插入？直接复制更快？</p><p>因长度扩容之后，数组长度改变，Hash的规则也会随之改变</p></blockquote><p>具体到为什么改为尾插法更好，使用头插法，容量为2的容器，某一节点上链表A-B-C在不同线程扩容插入A,B,C时，可能会形成B-A-B的回环，而使用尾插不会改变链表上的顺序，扩容时即不会出现链表成环问题。由此JAVA8不会出现像JAVA7在多线程操作哈希表时的死循环问题。</p><p>但这并不说明JAVA8可以任意把哈希表使用在多线程中，通过源码可知put/get方法均没有加同步锁，还是无法保证上一秒put的值，下一秒get还是原值，即线程安全还是无法保证。</p><blockquote><p>哈希表的默认初始化长度是16        为经验值</p></blockquote><h1 id="为何重写equals方法要重写hashCode方法？"><a href="#为何重写equals方法要重写hashCode方法？" class="headerlink" title="为何重写equals方法要重写hashCode方法？"></a>为何重写equals方法要重写hashCode方法？</h1><p>java中所有的对象都是继承于Object类，而Ojbect类中有两个比较两个对象是否相等的方法：equals和hashCode。</p><p>而哈希表找到数组同一节点上的链表时，使用equals比较链表上不同的值，也就是说我们一定要对hashCode进行重写，以保证<strong>相同的对象返回相同的hash值，不同的对象返回不同的hash值</strong>。</p><h1 id="HashMap为何是线程不安全的"><a href="#HashMap为何是线程不安全的" class="headerlink" title="HashMap为何是线程不安全的"></a>HashMap为何是线程不安全的</h1><h2 id="jdk1-7中HashMap"><a href="#jdk1-7中HashMap" class="headerlink" title="jdk1.7中HashMap"></a>jdk1.7中HashMap</h2><p>原因一：扩容造成死循环</p><p>在对哈希表进行扩容时，扩容函数将原数据转移到新表中，也会使用头插法，造成链表顺序翻转，多线程情况下这里是形成死循环的关键点。</p><p>原因二：扩容造成数据丢失</p><p>在扩容时，也可能造成数据丢失，数据指向自己，形成自环</p><h2 id="jdk1-8中的HashMap"><a href="#jdk1-8中的HashMap" class="headerlink" title="jdk1.8中的HashMap"></a>jdk1.8中的HashMap</h2><p>在jdk1.8中对HashMap进行了优化，在发生hash碰撞，不再采用头插法方式，而是直接插入链表尾部，因此不会出现环形链表的情况，但是在多线程的情况下仍然不安全。诸如不同线程的put相互覆盖的情况。</p><h1 id="如何处理HashMap在线程不安全的情况"><a href="#如何处理HashMap在线程不安全的情况" class="headerlink" title="如何处理HashMap在线程不安全的情况"></a>如何处理HashMap在线程不安全的情况</h1><p>一般使用<strong>HashTable</strong>或者<strong>CurrentHashMap</strong>。</p><blockquote><p>虽然Hashtable和HashMap相比是线程安全的，但其在对数据操作时都会上锁，存在效率问题。另外<strong>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null</strong>。</p></blockquote><h1 id="ConcurrentHashMap如何保证线程安全？"><a href="#ConcurrentHashMap如何保证线程安全？" class="headerlink" title="ConcurrentHashMap如何保证线程安全？"></a>ConcurrentHashMap如何保证线程安全？</h1><p>ConcurrentHashMap的存值put步骤如下：</p><ol><li><p>根据 key 计算出 hashcode 。</p></li><li><p>判断是否需要进行初始化。</p></li><li><p>即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p></li><li><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p></li><li><p>如果都不满足，则利用 synchronized 锁写入数据。</p></li><li><p>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</p></li></ol><p>ConcurrentHashMap的取值get步骤如下：</p><ol><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值。</li></ol><h1 id="何为CAS，何为自旋？"><a href="#何为CAS，何为自旋？" class="headerlink" title="何为CAS，何为自旋？"></a>何为CAS，何为自旋？</h1><p>CAS 是乐观锁的一种实现方式，为一种轻量级的锁，认为并发操作并不总会发生。</p><p>具体流程为：线程在读取数据时不进行加锁，在准备写回数据时，比较原值是否修改，若未被其他线程修改则写回，若已被修改，则重新执行读取流程。</p><p>但其不能检测ABA问题，即A被某线程修改为B，再被某线程修改回A。乐观锁CAS无法检测。</p><h1 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h1><h1 id="synchronized锁升级策略"><a href="#synchronized锁升级策略" class="headerlink" title="synchronized锁升级策略"></a>synchronized锁升级策略</h1>]]></content>
    
    
    <categories>
      
      <category>Java知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《九零》（外两首）</title>
    <link href="/2020/11/25/%E3%80%8A%E4%B9%9D%E9%9B%B6%E3%80%8B%EF%BC%88%E5%A4%96%E4%B8%A4%E9%A6%96%EF%BC%89/"/>
    <url>/2020/11/25/%E3%80%8A%E4%B9%9D%E9%9B%B6%E3%80%8B%EF%BC%88%E5%A4%96%E4%B8%A4%E9%A6%96%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>​                        <strong>《九零》</strong></p><p>哨响冬末三九天，心系楚地八方援。</p><p>才笑九零纨绔子，挑灯提剑奔在前。</p><p>欲使天下除病事，敢为家国争人先。</p><p>满腔抱负今犹在，我辈英才正少年。</p><hr><p>才备腊酒留家宴，满城闭户锁门帘。</p><p>岁末不知春尚早，风将吹落谁家檐？</p><p>白衣同往御风雪，万民共载世多贤。</p><p>但看春光明媚去，家人闲坐笑谈天</p><p>呼</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--判断回文数</title>
    <link href="/2020/11/25/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2020/11/25/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>题目：判断一个数是否是回文数，12321是，但负数肯定不是，简单来说，排除负数后，判断整数反转后是否等于自身即可</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">boolean</span> <span class="hljs-title">huiwen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;       <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">10</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;       <span class="hljs-keyword">int</span> copyx=x,reverse=<span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span>(copyx!=<span class="hljs-number">0</span>)&#123;           reverse=reverse*<span class="hljs-number">10</span>+copyx%<span class="hljs-number">10</span>;           copyx/=<span class="hljs-number">10</span>;       &#125;       <span class="hljs-keyword">return</span> x==reverse;   &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--整数反转</title>
    <link href="/2020/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2020/11/25/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>题目：将整数按位反转，注意若反转后数溢出则返回0</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;    <span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(;x!=<span class="hljs-number">0</span>;x/=<span class="hljs-number">10</span>)        res = res*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;    <span class="hljs-keyword">return</span> res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE?<span class="hljs-number">0</span>;(<span class="hljs-keyword">int</span>) res;&#125;循环部分等价于    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)&#123;        res=res*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;        x=x/<span class="hljs-number">10</span>;    &#125;</code></pre><p><strong>Integer.MAX_VALUE和Integer.MIN_VALUE分别是整数int的最大和最小值</strong></p>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--罗马数字转换</title>
    <link href="/2020/11/25/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
    <url>/2020/11/25/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>题目：将罗马数字字符串转换为数字，当小字符在大字符前的时候，结果为大数减小数，如IV=4,IV=9</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"><span class="hljs-function">Public <span class="hljs-keyword">int</span> <span class="hljs-title">romantoInt</span><span class="hljs-params">(String s)</span></span>&#123;    Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-number">1</span>);    map.put(<span class="hljs-string">&#x27;V&#x27;</span>,<span class="hljs-number">5</span>);    map.put(<span class="hljs-string">&#x27;X&#x27;</span>,<span class="hljs-number">10</span>);    map.put(<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-number">50</span>);    map.put(<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">100</span>);    map.put(<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">500</span>);    map.put(<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">1000</span>);    <span class="hljs-keyword">int</span> len = s.length();    <span class="hljs-keyword">int</span> sum = map.get(s.charAt(len-<span class="hljs-number">1</span>));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;        <span class="hljs-keyword">if</span>(map.get(s.charAt(i))&lt;map.get(s.charAt(i+!)))&#123;            sum=sum-map.get(s.charAt(i));        &#125;<span class="hljs-keyword">else</span>        &#123;            sum=sum+map.get(s.charAt(i));        &#125;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode题解--两数求和</title>
    <link href="/2020/11/25/%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C/"/>
    <url>/2020/11/25/%E4%B8%A4%E6%95%B0%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目：两数求和返回下标，例如[2,7,11,15],目标值target=9，结果返回[0,1]</p><h2 id="具体代码如下（java）："><a href="#具体代码如下（java）：" class="headerlink" title="具体代码如下（java）："></a>具体代码如下（java）：</h2><pre><code class="hljs java"> Public <span class="hljs-keyword">int</span> [] towsum(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> target)&#123; <span class="hljs-keyword">int</span> len = nums.length;​HashMap&lt;Integer,Integer&gt; map= <span class="hljs-keyword">new</span> HashMap&lt;&gt;();​<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len;++i)&#123;​<span class="hljs-keyword">final</span> Integer value = map.get(nums[i]);​<span class="hljs-keyword">if</span>(value!=<span class="hljs-keyword">null</span>)&#123;​<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;value,i&#125;;​&#125;​map.put(target-nums[i],i);​&#125;​<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre><p><strong>使用哈希表，键存target-nums[i]差值，值存相对应下标，若遍历时已存在，则返回目标对应值和当前下标</strong></p>]]></content>
    
    
    <categories>
      
      <category>java算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图神经网络综述</title>
    <link href="/2020/11/25/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/"/>
    <url>/2020/11/25/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%BC%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="图神经网络综述"><a href="#图神经网络综述" class="headerlink" title="图神经网络综述"></a>图神经网络综述</h1><h2 id="GNN简介与起源"><a href="#GNN简介与起源" class="headerlink" title="GNN简介与起源"></a>GNN简介与起源</h2><p>​        关于GNN的起源来自于两种思维的碰撞，一种是卷积神经网络CNN，另一种是图嵌入（graph embedding）。众所周知，CNN擅长提取多尺度的局部特征并将其组合为更高级的表示。CNN的核心特点是局部链接，权重共享，多层叠加。类推可以发现，这些特点可良好移植到图结构中。首先，图结构是最典型局部连接结构；其次，共享权重可减少计算量；最后，多层结构保证了分级处理问题的可能。但局限的是，CNN只能良好处理欧几里得数据，诸如一维文本数据和二维图像数据，这些数据都可以看作规则连接的图结构特例。对于图结构，CNN的卷积核和池化操作很难迁移到图上。图嵌入就是对图的节点，边或子图进行学习得到一个低维的向量表示。图嵌入常见模型由DeepWalk，Node2Vec等，但这些方法普遍有严重不足，一是节点编码中权重未进行共享而导致权重数量随着节点增多线性增大。再是直接嵌入方法缺乏泛化能力，无法将模型泛化到处理新的图。基于此，两者结合，提出了图神经网路GNN。</p><h2 id="GNN与传统NN区别"><a href="#GNN与传统NN区别" class="headerlink" title="GNN与传统NN区别"></a>GNN与传统NN区别</h2><p>​        传统神经网络诸如CNN和RNN因都需要节点的特征按照一定的顺序排列，而图结构并没有特定的顺序，导致它们不能适当处理图结构输入。若将图拆分为所有可能的多个序列，将会造成非常大的计算冗余。GNN采用在每个节点上分别进行传播的方式进行学习，由此忽略节点顺序，从而GNN输出会随着输入的不同而不同。另外，GNN通过邻居节点的加权求和来更新节点隐藏状态。传统神经网络主要处理的数据对象是欧式空间的，例如文本序列，图片等等，而图神经网络主要是处理非欧空间的数据，例如社群关系，知识图谱等。具体到图神经网络的两种实现形式，第一种是将非欧空间的图转换为欧式空间的图，也就是基于谱域的实现，另一种是直接在图上抽特征，随机游走等的方式来做的，就是基于空域的实现。</p><h2 id="GNN分类"><a href="#GNN分类" class="headerlink" title="GNN分类"></a>GNN分类</h2><p>​    从空域视角看图卷积神经网络，本质上是一个迭代式聚合邻居的过程，这一行为启发了一大类模型对聚合操作的重新设计，这些设计在某些方面大大加强了图神经网络对图数据的适应性，下面对图神经网络的典型变体和通用表达框架进行介绍。</p><h3 id="GraphSAGE"><a href="#GraphSAGE" class="headerlink" title="GraphSAGE"></a>GraphSAGE</h3><p>​        GraphSAGE从两个方面对GCN进行了改动，一方面是通过采样邻居策略将GCN由全图训练方式改造成以节点为中心的小批量训练，这使得大规模图数据的分布式训练变得可能。另一方面对聚合邻居的操作进行了扩展，提出了替换GCN操作的几种新的方式。</p><p>​        在之前的GCN模型中，训练方式是一种全图形式，也就是一轮迭代，所有节点样本的损失只会贡献一次梯度数据，无法做到DNN中常用的小批量式更新，这是很低效的。GraphSAGE从聚合邻居出发，对邻居进行随机采样来控制实际运算时节点K阶子图的数据规模，在此基础上对采样的子图进行随机组合来完成小批量式的训练。在GCN中，节点在k+1层的特征只与其邻居在K层的特征有关，即节点在第k层的特征只与自己的K阶子图有关。GraphSAGE研究了几种新的聚合方法，即对聚合节点数量自适应，使聚合操作对聚合节点具有排列不变性。总之，GraphSAGE对空域视角下的GCN做了一次解构，提出了几种邻居的聚合操作算子，同时通过采样邻居，大大提高了算法的工程价值。在引文[61]中通过该方法完成了对工业级大规模推荐系统的应用，且效果十分显著。</p><h3 id="图注意力网络GAT"><a href="#图注意力网络GAT" class="headerlink" title="图注意力网络GAT"></a>图注意力网络GAT</h3><p>​        图注意力网络通过注意力机制对邻居节点做聚合操作，实现了对不同邻居权重的自适应分配，从而大幅提高图神经网络的表达能力。图注意力网络通过注意力机制来对邻居节点做聚合操作，实现对不同邻居权重的自适应分配，从而大大提高了图神经网络模型的表达能力。</p><p>​        DNN中的注意力机制是通过人对信息处理机制的轻重来启发的。注意力机制的核心在于对给定信息进行权重分配，权重高的信息意味着需要系统进行重点加工。注意力机制里包含三要素：Query，Source，Attention Value。即当前中心节点的特征向量，所有邻居的特征向量，中心节点经过聚合操作后的新的特征向量。具体到网络结构中，图注意力层比GCN里的图卷积层多了一个自适应的边权重系数维度。</p><h3 id="GNN的General-Framework"><a href="#GNN的General-Framework" class="headerlink" title="GNN的General Framework"></a>GNN的General Framework</h3><p>（1）消息传播神经网络MPNN</p><p>MPNN通过消息传播机制对多种GCN模型做出一般化总结。其基本思路为：节点的表示向量都是通过消息函数M和更新函数U进行K轮消息传播机制的迭代后得到。MPNN的核心在于消息函数和更新函数，原则上可以把他们设计成任意一种DNN模型，MPNN的消息函数是作用在RDF三元组上，因此对于常见的同构图，异构图，属性图等都具有一定的适应性。</p><p>（2）非局部神经网络NLNN</p><p>非局部神经网络NLNN是对注意力机制的一般化总结，GTA即为其一个特例。NLNN通过non-local操作将任意位置的输出响应计算为所有位置特征的加权和。位置可以是图像中的空间坐标，也可以是序列数据中的时间坐标，在图数据中，位置可以直接以节点替代。</p><p>（3）图网络GN</p><p>Graph Network是比MPNN和NLNN，对GNN的更一般的总结，基本计算单元包含三个元素，节点的状态，边的状态，图的状态。GN对图里面的节点，边，图全都维护了相应的状态，这三者可分别对应节点层面的任务，边层面的任务，全图层面的任务，这也就是说GN可依据图数据以及相关任务的实际情况，对GN进行相应的简化处理。</p><h2 id="GNN应用"><a href="#GNN应用" class="headerlink" title="GNN应用"></a>GNN应用</h2><h3 id="网络分析"><a href="#网络分析" class="headerlink" title="网络分析"></a>网络分析</h3><p>​        在社会网络分析领域，引文网络是最为常见的数据，即节点为论文，连边关系为引用关系，常见的数据集包括Cora，DBLP，Citeseer等.这些常见的网络的数据集的描述如表1以所示。一个典型的分类任务是给定每篇文章的内容信息和文章之间的引用关系，将每篇文章分类到对应的领域中．例如，在节点的半监督分类场景下，已知节点的属性信息包括文章的标题或摘要信息，以及节点之间的引用关系构成的网络信息， 给定少量的数据标签，通过机器学习的方式，对网络中的每个节点的所属领域进行划分．在该任务中，图卷积神经网络将节点文本属性和引用网络结构有效的建模，取得了巨大的成功。</p><h3 id="交通预测"><a href="#交通预测" class="headerlink" title="交通预测"></a>交通预测</h3><p>​        交通预测问题也是图卷积神经网络得到广泛应用的任务之一．其目的是在给定历史交通速度和路线图的情况下，预测未来的交通的速率．在交通预测问题中，节点表示在道路中放置的传感器，而边则表示节点对的物理距离．每个节点包含一个时序的特征．相比于传统的图分析问题．交通预测问题中包括时间和空间两个方面的建模，而如何利用图卷积神经网络更好地建模交通中的路网带来了机遇和挑战。</p><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><p>​        图卷积神经网络被认为能够很好地建模图的结构属性和节点特征信息，而推荐系统既可以被视为一个矩阵补全问题， 也可以被视为是二部图（ 用户和商品） 的链接预测问题．相比传统的方法，图卷积神经网络能够更好地利用在推荐系统中普遍存在的用户属性和商品属性信息，这也是图卷积神经网络能够在推荐系统任务上引起人们广泛关注的原因。</p><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>​        图卷积神经网络在计算机视觉中的应用，主要用在少样本学习，零样本学习，点云建模等领域。在图片分类方面，主要创新在零样本学习和少样本学习上的表现，在计算机视觉领域，研究者在完成包括物体识别，图片分类，语义分割过程中，更多关注物体在少量样本或复杂语义情况下的建模和学习过程，对图关联的注意较少，而图卷积神经网络着重关注了此方面，是对图数据建模的有效方法。</p><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p>​        图卷积神经网络在自然语言处理领域有大量的应用．在该领域中， 较为常见的图数据为知识图谱、句法依赖图和抽象含义表达图、词共现图以及其他方式构建的图．抽象含义表达（即AMR）是一种将一个句子的含义编码为有根有向图．在使用图卷积神经网络模型后，各项自然语言处理任务的结果都出现了一定的提升。图结构的使用，使得对象之间的复杂的语义关系得到了有效地挖掘。相比传统的对于自然语言处理的序列化建模，使用图卷积神经网络能够挖掘出非线性的复杂语义关系。</p><h3 id="生物化学"><a href="#生物化学" class="headerlink" title="生物化学"></a>生物化学</h3><p>​        除了传统的图数据的建模外，图卷积神经网络在生物化学等领域也受到了研究人员的大量关注。相比传统的图数据的研究，在生物化学领域，人们通常将一个化学结构或一个蛋白质视为一个图，图中的节点是更小的分子，边代表键或者相互作用。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GCN</tag>
      
      <tag>GNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
